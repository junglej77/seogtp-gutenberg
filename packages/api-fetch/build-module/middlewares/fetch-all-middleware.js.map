{"version":3,"names":["addQueryArgs","apiFetch","modifyQuery","path","url","options","queryArgs","parseResponse","response","json","Promise","reject","parseLinkHeader","linkHeader","match","next","getNextPageUrl","headers","get","requestContainsUnboundedQuery","pathIsUnbounded","indexOf","urlIsUnbounded","fetchAllMiddleware","parse","per_page","results","Array","isArray","nextPage","mergedResults","concat","nextResponse","undefined","nextResults"],"sources":["@wordpress/api-fetch/src/middlewares/fetch-all-middleware.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { addQueryArgs } from '@wordpress/url';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport apiFetch from '..';\r\n\r\n/**\r\n * Apply query arguments to both URL and Path, whichever is present.\r\n *\r\n * @param {import('../types').APIFetchOptions} props\r\n * @param {Record<string, string | number>}    queryArgs\r\n * @return {import('../types').APIFetchOptions} The request with the modified query args\r\n */\r\nconst modifyQuery = ( { path, url, ...options }, queryArgs ) => ( {\r\n\t...options,\r\n\turl: url && addQueryArgs( url, queryArgs ),\r\n\tpath: path && addQueryArgs( path, queryArgs ),\r\n} );\r\n\r\n/**\r\n * Duplicates parsing functionality from apiFetch.\r\n *\r\n * @param {Response} response\r\n * @return {Promise<any>} Parsed response json.\r\n */\r\nconst parseResponse = ( response ) =>\r\n\tresponse.json ? response.json() : Promise.reject( response );\r\n\r\n/**\r\n * @param {string | null} linkHeader\r\n * @return {{ next?: string }} The parsed link header.\r\n */\r\nconst parseLinkHeader = ( linkHeader ) => {\r\n\tif ( ! linkHeader ) {\r\n\t\treturn {};\r\n\t}\r\n\tconst match = linkHeader.match( /<([^>]+)>; rel=\"next\"/ );\r\n\treturn match\r\n\t\t? {\r\n\t\t\t\tnext: match[ 1 ],\r\n\t\t  }\r\n\t\t: {};\r\n};\r\n\r\n/**\r\n * @param {Response} response\r\n * @return {string | undefined} The next page URL.\r\n */\r\nconst getNextPageUrl = ( response ) => {\r\n\tconst { next } = parseLinkHeader( response.headers.get( 'link' ) );\r\n\treturn next;\r\n};\r\n\r\n/**\r\n * @param {import('../types').APIFetchOptions} options\r\n * @return {boolean} True if the request contains an unbounded query.\r\n */\r\nconst requestContainsUnboundedQuery = ( options ) => {\r\n\tconst pathIsUnbounded =\r\n\t\t!! options.path && options.path.indexOf( 'per_page=-1' ) !== -1;\r\n\tconst urlIsUnbounded =\r\n\t\t!! options.url && options.url.indexOf( 'per_page=-1' ) !== -1;\r\n\treturn pathIsUnbounded || urlIsUnbounded;\r\n};\r\n\r\n/**\r\n * The REST API enforces an upper limit on the per_page option. To handle large\r\n * collections, apiFetch consumers can pass `per_page=-1`; this middleware will\r\n * then recursively assemble a full response array from all available pages.\r\n *\r\n * @type {import('../types').APIFetchMiddleware}\r\n */\r\nconst fetchAllMiddleware = async ( options, next ) => {\r\n\tif ( options.parse === false ) {\r\n\t\t// If a consumer has opted out of parsing, do not apply middleware.\r\n\t\treturn next( options );\r\n\t}\r\n\tif ( ! requestContainsUnboundedQuery( options ) ) {\r\n\t\t// If neither url nor path is requesting all items, do not apply middleware.\r\n\t\treturn next( options );\r\n\t}\r\n\r\n\t// Retrieve requested page of results.\r\n\tconst response = await apiFetch( {\r\n\t\t...modifyQuery( options, {\r\n\t\t\tper_page: 100,\r\n\t\t} ),\r\n\t\t// Ensure headers are returned for page 1.\r\n\t\tparse: false,\r\n\t} );\r\n\r\n\tconst results = await parseResponse( response );\r\n\r\n\tif ( ! Array.isArray( results ) ) {\r\n\t\t// We have no reliable way of merging non-array results.\r\n\t\treturn results;\r\n\t}\r\n\r\n\tlet nextPage = getNextPageUrl( response );\r\n\r\n\tif ( ! nextPage ) {\r\n\t\t// There are no further pages to request.\r\n\t\treturn results;\r\n\t}\r\n\r\n\t// Iteratively fetch all remaining pages until no \"next\" header is found.\r\n\tlet mergedResults = /** @type {any[]} */ ( [] ).concat( results );\r\n\twhile ( nextPage ) {\r\n\t\tconst nextResponse = await apiFetch( {\r\n\t\t\t...options,\r\n\t\t\t// Ensure the URL for the next page is used instead of any provided path.\r\n\t\t\tpath: undefined,\r\n\t\t\turl: nextPage,\r\n\t\t\t// Ensure we still get headers so we can identify the next page.\r\n\t\t\tparse: false,\r\n\t\t} );\r\n\t\tconst nextResults = await parseResponse( nextResponse );\r\n\t\tmergedResults = mergedResults.concat( nextResults );\r\n\t\tnextPage = getNextPageUrl( nextResponse );\r\n\t}\r\n\treturn mergedResults;\r\n};\r\n\r\nexport default fetchAllMiddleware;\r\n"],"mappings":"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","ignoreList":[]}