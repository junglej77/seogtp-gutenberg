{"version":3,"names":["__","parseResponse","response","shouldParseResponse","status","json","Promise","reject","parseJsonAndNormalizeError","invalidJsonError","code","message","catch","parseResponseAndNormalizeError","resolve","res","parseAndThrowError","then","error","unknownError"],"sources":["@wordpress/api-fetch/src/utils/response.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { __ } from '@wordpress/i18n';\r\n\r\n/**\r\n * Parses the apiFetch response.\r\n *\r\n * @param {Response} response\r\n * @param {boolean}  shouldParseResponse\r\n *\r\n * @return {Promise<any> | null | Response} Parsed response.\r\n */\r\nconst parseResponse = ( response, shouldParseResponse = true ) => {\r\n\tif ( shouldParseResponse ) {\r\n\t\tif ( response.status === 204 ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn response.json ? response.json() : Promise.reject( response );\r\n\t}\r\n\r\n\treturn response;\r\n};\r\n\r\n/**\r\n * Calls the `json` function on the Response, throwing an error if the response\r\n * doesn't have a json function or if parsing the json itself fails.\r\n *\r\n * @param {Response} response\r\n * @return {Promise<any>} Parsed response.\r\n */\r\nconst parseJsonAndNormalizeError = ( response ) => {\r\n\tconst invalidJsonError = {\r\n\t\tcode: 'invalid_json',\r\n\t\tmessage: __( 'The response is not a valid JSON response.' ),\r\n\t};\r\n\r\n\tif ( ! response || ! response.json ) {\r\n\t\tthrow invalidJsonError;\r\n\t}\r\n\r\n\treturn response.json().catch( () => {\r\n\t\tthrow invalidJsonError;\r\n\t} );\r\n};\r\n\r\n/**\r\n * Parses the apiFetch response properly and normalize response errors.\r\n *\r\n * @param {Response} response\r\n * @param {boolean}  shouldParseResponse\r\n *\r\n * @return {Promise<any>} Parsed response.\r\n */\r\nexport const parseResponseAndNormalizeError = (\r\n\tresponse,\r\n\tshouldParseResponse = true\r\n) => {\r\n\treturn Promise.resolve(\r\n\t\tparseResponse( response, shouldParseResponse )\r\n\t).catch( ( res ) => parseAndThrowError( res, shouldParseResponse ) );\r\n};\r\n\r\n/**\r\n * Parses a response, throwing an error if parsing the response fails.\r\n *\r\n * @param {Response} response\r\n * @param {boolean}  shouldParseResponse\r\n * @return {Promise<any>} Parsed response.\r\n */\r\nexport function parseAndThrowError( response, shouldParseResponse = true ) {\r\n\tif ( ! shouldParseResponse ) {\r\n\t\tthrow response;\r\n\t}\r\n\r\n\treturn parseJsonAndNormalizeError( response ).then( ( error ) => {\r\n\t\tconst unknownError = {\r\n\t\t\tcode: 'unknown_error',\r\n\t\t\tmessage: __( 'An unknown error occurred.' ),\r\n\t\t};\r\n\r\n\t\tthrow error || unknownError;\r\n\t} );\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,EAAE,QAAQ,iBAAiB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,GAAGA,CAAEC,QAAQ,EAAEC,mBAAmB,GAAG,IAAI,KAAM;EACjE,IAAKA,mBAAmB,EAAG;IAC1B,IAAKD,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAG;MAC9B,OAAO,IAAI;IACZ;IAEA,OAAOF,QAAQ,CAACG,IAAI,GAAGH,QAAQ,CAACG,IAAI,CAAC,CAAC,GAAGC,OAAO,CAACC,MAAM,CAAEL,QAAS,CAAC;EACpE;EAEA,OAAOA,QAAQ;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,0BAA0B,GAAKN,QAAQ,IAAM;EAClD,MAAMO,gBAAgB,GAAG;IACxBC,IAAI,EAAE,cAAc;IACpBC,OAAO,EAAEX,EAAE,CAAE,4CAA6C;EAC3D,CAAC;EAED,IAAK,CAAEE,QAAQ,IAAI,CAAEA,QAAQ,CAACG,IAAI,EAAG;IACpC,MAAMI,gBAAgB;EACvB;EAEA,OAAOP,QAAQ,CAACG,IAAI,CAAC,CAAC,CAACO,KAAK,CAAE,MAAM;IACnC,MAAMH,gBAAgB;EACvB,CAAE,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,8BAA8B,GAAGA,CAC7CX,QAAQ,EACRC,mBAAmB,GAAG,IAAI,KACtB;EACJ,OAAOG,OAAO,CAACQ,OAAO,CACrBb,aAAa,CAAEC,QAAQ,EAAEC,mBAAoB,CAC9C,CAAC,CAACS,KAAK,CAAIG,GAAG,IAAMC,kBAAkB,CAAED,GAAG,EAAEZ,mBAAoB,CAAE,CAAC;AACrE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASa,kBAAkBA,CAAEd,QAAQ,EAAEC,mBAAmB,GAAG,IAAI,EAAG;EAC1E,IAAK,CAAEA,mBAAmB,EAAG;IAC5B,MAAMD,QAAQ;EACf;EAEA,OAAOM,0BAA0B,CAAEN,QAAS,CAAC,CAACe,IAAI,CAAIC,KAAK,IAAM;IAChE,MAAMC,YAAY,GAAG;MACpBT,IAAI,EAAE,eAAe;MACrBC,OAAO,EAAEX,EAAE,CAAE,4BAA6B;IAC3C,CAAC;IAED,MAAMkB,KAAK,IAAIC,YAAY;EAC5B,CAAE,CAAC;AACJ","ignoreList":[]}