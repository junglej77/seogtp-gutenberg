{"version":3,"names":["DEFAULT_MAXIMUM_VIEWPORT_WIDTH","DEFAULT_MINIMUM_VIEWPORT_WIDTH","DEFAULT_SCALE_FACTOR","DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN","DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX","DEFAULT_MINIMUM_FONT_SIZE_LIMIT","getComputedFluidTypographyValue","minimumFontSize","maximumFontSize","fontSize","minimumViewportWidth","maximumViewportWidth","scaleFactor","minimumFontSizeLimit","getTypographyValueAndUnit","fontSizeParsed","unit","minimumFontSizeLimitParsed","coerceTo","value","fontSizeValueInPx","minimumFontSizeFactor","Math","min","max","log2","calculatedMinimumFontSize","roundToPrecision","minimumFontSizeParsed","fontSizeUnit","maximumFontSizeParsed","minimumFontSizeRem","maximumViewportWidthParsed","minimumViewportWidthParsed","linearDenominator","minViewportWidthOffsetValue","viewportWidthOffset","linearFactor","linearFactorScaled","fluidTargetFontSize","rawValue","options","isFinite","rootSizeValue","acceptableUnits","acceptableUnitsGroup","join","regexUnits","RegExp","matches","match","length","returnValue","parseFloat","digits","base","pow","Number","round","undefined"],"sources":["@wordpress/block-editor/src/components/font-sizes/fluid-utils.js"],"sourcesContent":["/**\r\n * The fluid utilities must match the backend equivalent.\r\n * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php\r\n * ---------------------------------------------------------------\r\n */\r\n\r\n// Defaults.\r\nconst DEFAULT_MAXIMUM_VIEWPORT_WIDTH = '1600px';\r\nconst DEFAULT_MINIMUM_VIEWPORT_WIDTH = '320px';\r\nconst DEFAULT_SCALE_FACTOR = 1;\r\nconst DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN = 0.25;\r\nconst DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX = 0.75;\r\nconst DEFAULT_MINIMUM_FONT_SIZE_LIMIT = '14px';\r\n\r\n/**\r\n * Computes a fluid font-size value that uses clamp(). A minimum and maximum\r\n * font size OR a single font size can be specified.\r\n *\r\n * If a single font size is specified, it is scaled up and down using a logarithmic scale.\r\n *\r\n * @example\r\n * ```js\r\n * // Calculate fluid font-size value from a minimum and maximum value.\r\n * const fontSize = getComputedFluidTypographyValue( {\r\n *     minimumFontSize: '20px',\r\n *     maximumFontSize: '45px'\r\n * } );\r\n * // Calculate fluid font-size value from a single font size.\r\n * const fontSize = getComputedFluidTypographyValue( {\r\n *     fontSize: '30px',\r\n * } );\r\n * ```\r\n *\r\n * @param {Object}        args\r\n * @param {?string}       args.minimumViewportWidth Minimum viewport size from which type will have fluidity. Optional if fontSize is specified.\r\n * @param {?string}       args.maximumViewportWidth Maximum size up to which type will have fluidity. Optional if fontSize is specified.\r\n * @param {string|number} [args.fontSize]           Size to derive maximumFontSize and minimumFontSize from, if necessary. Optional if minimumFontSize and maximumFontSize are specified.\r\n * @param {?string}       args.maximumFontSize      Maximum font size for any clamp() calculation. Optional.\r\n * @param {?string}       args.minimumFontSize      Minimum font size for any clamp() calculation. Optional.\r\n * @param {?number}       args.scaleFactor          A scale factor to determine how fast a font scales within boundaries. Optional.\r\n * @param {?string}       args.minimumFontSizeLimit The smallest a calculated font size may be. Optional.\r\n *\r\n * @return {string|null} A font-size value using clamp().\r\n */\r\nexport function getComputedFluidTypographyValue( {\r\n\tminimumFontSize,\r\n\tmaximumFontSize,\r\n\tfontSize,\r\n\tminimumViewportWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,\r\n\tmaximumViewportWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,\r\n\tscaleFactor = DEFAULT_SCALE_FACTOR,\r\n\tminimumFontSizeLimit,\r\n} ) {\r\n\t// Validate incoming settings and set defaults.\r\n\tminimumFontSizeLimit = !! getTypographyValueAndUnit( minimumFontSizeLimit )\r\n\t\t? minimumFontSizeLimit\r\n\t\t: DEFAULT_MINIMUM_FONT_SIZE_LIMIT;\r\n\r\n\t/*\r\n\t * Calculates missing minimumFontSize and maximumFontSize from\r\n\t * defaultFontSize if provided.\r\n\t */\r\n\tif ( fontSize ) {\r\n\t\t// Parses default font size.\r\n\t\tconst fontSizeParsed = getTypographyValueAndUnit( fontSize );\r\n\r\n\t\t// Protect against invalid units.\r\n\t\tif ( ! fontSizeParsed?.unit ) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Parses the minimum font size limit, so we can perform checks using it.\r\n\t\tconst minimumFontSizeLimitParsed = getTypographyValueAndUnit(\r\n\t\t\tminimumFontSizeLimit,\r\n\t\t\t{\r\n\t\t\t\tcoerceTo: fontSizeParsed.unit,\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Don't enforce minimum font size if a font size has explicitly set a min and max value.\r\n\t\tif (\r\n\t\t\t!! minimumFontSizeLimitParsed?.value &&\r\n\t\t\t! minimumFontSize &&\r\n\t\t\t! maximumFontSize\r\n\t\t) {\r\n\t\t\t/*\r\n\t\t\t * If a minimum size was not passed to this function\r\n\t\t\t * and the user-defined font size is lower than $minimum_font_size_limit,\r\n\t\t\t * do not calculate a fluid value.\r\n\t\t\t */\r\n\t\t\tif ( fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If no fluid max font size is available use the incoming value.\r\n\t\tif ( ! maximumFontSize ) {\r\n\t\t\tmaximumFontSize = `${ fontSizeParsed.value }${ fontSizeParsed.unit }`;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If no minimumFontSize is provided, create one using\r\n\t\t * the given font size multiplied by the min font size scale factor.\r\n\t\t */\r\n\t\tif ( ! minimumFontSize ) {\r\n\t\t\tconst fontSizeValueInPx =\r\n\t\t\t\tfontSizeParsed.unit === 'px'\r\n\t\t\t\t\t? fontSizeParsed.value\r\n\t\t\t\t\t: fontSizeParsed.value * 16;\r\n\r\n\t\t\t/*\r\n\t\t\t * The scale factor is a multiplier that affects how quickly the curve will move towards the minimum,\r\n\t\t\t * that is, how quickly the size factor reaches 0 given increasing font size values.\r\n\t\t\t * For a - b * log2(), lower values of b will make the curve move towards the minimum faster.\r\n\t\t\t * The scale factor is constrained between min and max values.\r\n\t\t\t */\r\n\t\t\tconst minimumFontSizeFactor = Math.min(\r\n\t\t\t\tMath.max(\r\n\t\t\t\t\t1 - 0.075 * Math.log2( fontSizeValueInPx ),\r\n\t\t\t\t\tDEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN\r\n\t\t\t\t),\r\n\t\t\t\tDEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX\r\n\t\t\t);\r\n\r\n\t\t\t// Calculates the minimum font size.\r\n\t\t\tconst calculatedMinimumFontSize = roundToPrecision(\r\n\t\t\t\tfontSizeParsed.value * minimumFontSizeFactor,\r\n\t\t\t\t3\r\n\t\t\t);\r\n\r\n\t\t\t// Only use calculated min font size if it's > $minimum_font_size_limit value.\r\n\t\t\tif (\r\n\t\t\t\t!! minimumFontSizeLimitParsed?.value &&\r\n\t\t\t\tcalculatedMinimumFontSize < minimumFontSizeLimitParsed?.value\r\n\t\t\t) {\r\n\t\t\t\tminimumFontSize = `${ minimumFontSizeLimitParsed.value }${ minimumFontSizeLimitParsed.unit }`;\r\n\t\t\t} else {\r\n\t\t\t\tminimumFontSize = `${ calculatedMinimumFontSize }${ fontSizeParsed.unit }`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Grab the minimum font size and normalize it in order to use the value for calculations.\r\n\tconst minimumFontSizeParsed = getTypographyValueAndUnit( minimumFontSize );\r\n\r\n\t// We get a 'preferred' unit to keep units consistent when calculating,\r\n\t// otherwise the result will not be accurate.\r\n\tconst fontSizeUnit = minimumFontSizeParsed?.unit || 'rem';\r\n\r\n\t// Grabs the maximum font size and normalize it in order to use the value for calculations.\r\n\tconst maximumFontSizeParsed = getTypographyValueAndUnit( maximumFontSize, {\r\n\t\tcoerceTo: fontSizeUnit,\r\n\t} );\r\n\r\n\t// Checks for mandatory min and max sizes, and protects against unsupported units.\r\n\tif ( ! minimumFontSizeParsed || ! maximumFontSizeParsed ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Uses rem for accessible fluid target font scaling.\r\n\tconst minimumFontSizeRem = getTypographyValueAndUnit( minimumFontSize, {\r\n\t\tcoerceTo: 'rem',\r\n\t} );\r\n\r\n\t// Viewport widths defined for fluid typography. Normalize units\r\n\tconst maximumViewportWidthParsed = getTypographyValueAndUnit(\r\n\t\tmaximumViewportWidth,\r\n\t\t{ coerceTo: fontSizeUnit }\r\n\t);\r\n\tconst minimumViewportWidthParsed = getTypographyValueAndUnit(\r\n\t\tminimumViewportWidth,\r\n\t\t{ coerceTo: fontSizeUnit }\r\n\t);\r\n\r\n\t// Protect against unsupported units.\r\n\tif (\r\n\t\t! maximumViewportWidthParsed ||\r\n\t\t! minimumViewportWidthParsed ||\r\n\t\t! minimumFontSizeRem\r\n\t) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Calculates the linear factor denominator. If it's 0, we cannot calculate a fluid value.\r\n\tconst linearDenominator =\r\n\t\tmaximumViewportWidthParsed.value - minimumViewportWidthParsed.value;\r\n\tif ( ! linearDenominator ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Build CSS rule.\r\n\t// Borrowed from https://websemantics.uk/tools/responsive-font-calculator/.\r\n\tconst minViewportWidthOffsetValue = roundToPrecision(\r\n\t\tminimumViewportWidthParsed.value / 100,\r\n\t\t3\r\n\t);\r\n\r\n\tconst viewportWidthOffset =\r\n\t\troundToPrecision( minViewportWidthOffsetValue, 3 ) + fontSizeUnit;\r\n\tconst linearFactor =\r\n\t\t100 *\r\n\t\t( ( maximumFontSizeParsed.value - minimumFontSizeParsed.value ) /\r\n\t\t\tlinearDenominator );\r\n\tconst linearFactorScaled = roundToPrecision(\r\n\t\t( linearFactor || 1 ) * scaleFactor,\r\n\t\t3\r\n\t);\r\n\tconst fluidTargetFontSize = `${ minimumFontSizeRem.value }${ minimumFontSizeRem.unit } + ((1vw - ${ viewportWidthOffset }) * ${ linearFactorScaled })`;\r\n\r\n\treturn `clamp(${ minimumFontSize }, ${ fluidTargetFontSize }, ${ maximumFontSize })`;\r\n}\r\n\r\n/**\r\n * Internal method that checks a string for a unit and value and returns an array consisting of `'value'` and `'unit'`, e.g., [ '42', 'rem' ].\r\n * A raw font size of `value + unit` is expected. If the value is an integer, it will convert to `value + 'px'`.\r\n *\r\n * @param {string|number}    rawValue Raw size value from theme.json.\r\n * @param {Object|undefined} options  Calculation options.\r\n *\r\n * @return {{ unit: string, value: number }|null} An object consisting of `'value'` and `'unit'` properties.\r\n */\r\nexport function getTypographyValueAndUnit( rawValue, options = {} ) {\r\n\tif ( typeof rawValue !== 'string' && typeof rawValue !== 'number' ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Converts numeric values to pixel values by default.\r\n\tif ( isFinite( rawValue ) ) {\r\n\t\trawValue = `${ rawValue }px`;\r\n\t}\r\n\r\n\tconst { coerceTo, rootSizeValue, acceptableUnits } = {\r\n\t\tcoerceTo: '',\r\n\t\t// Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( \"html\" ) ).fontSize`.\r\n\t\trootSizeValue: 16,\r\n\t\tacceptableUnits: [ 'rem', 'px', 'em' ],\r\n\t\t...options,\r\n\t};\r\n\r\n\tconst acceptableUnitsGroup = acceptableUnits?.join( '|' );\r\n\tconst regexUnits = new RegExp(\r\n\t\t`^(\\\\d*\\\\.?\\\\d+)(${ acceptableUnitsGroup }){1,1}$`\r\n\t);\r\n\r\n\tconst matches = rawValue.match( regexUnits );\r\n\r\n\t// We need a number value and a unit.\r\n\tif ( ! matches || matches.length < 3 ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet [ , value, unit ] = matches;\r\n\r\n\tlet returnValue = parseFloat( value );\r\n\r\n\tif ( 'px' === coerceTo && ( 'em' === unit || 'rem' === unit ) ) {\r\n\t\treturnValue = returnValue * rootSizeValue;\r\n\t\tunit = coerceTo;\r\n\t}\r\n\r\n\tif ( 'px' === unit && ( 'em' === coerceTo || 'rem' === coerceTo ) ) {\r\n\t\treturnValue = returnValue / rootSizeValue;\r\n\t\tunit = coerceTo;\r\n\t}\r\n\r\n\t/*\r\n\t * No calculation is required if swapping between em and rem yet,\r\n\t * since we assume a root size value. Later we might like to differentiate between\r\n\t * :root font size (rem) and parent element font size (em) relativity.\r\n\t */\r\n\tif (\r\n\t\t( 'em' === coerceTo || 'rem' === coerceTo ) &&\r\n\t\t( 'em' === unit || 'rem' === unit )\r\n\t) {\r\n\t\tunit = coerceTo;\r\n\t}\r\n\r\n\treturn {\r\n\t\tvalue: roundToPrecision( returnValue, 3 ),\r\n\t\tunit,\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a value rounded to defined precision.\r\n * Returns `undefined` if the value is not a valid finite number.\r\n *\r\n * @param {number} value  Raw value.\r\n * @param {number} digits The number of digits to appear after the decimal point\r\n *\r\n * @return {number|undefined} Value rounded to standard precision.\r\n */\r\nexport function roundToPrecision( value, digits = 3 ) {\r\n\tconst base = Math.pow( 10, digits );\r\n\treturn Number.isFinite( value )\r\n\t\t? parseFloat( Math.round( value * base ) / base )\r\n\t\t: undefined;\r\n}\r\n"],"mappings":"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","ignoreList":[]}