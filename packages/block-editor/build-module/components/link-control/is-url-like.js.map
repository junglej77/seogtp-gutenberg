{"version":3,"names":["getProtocol","isValidProtocol","isValidFragment","isURLLike","val","hasSpaces","includes","protocol","protocolIsValid","mayBeTLD","hasPossibleTLD","isWWW","startsWith","isInternal","url","maxLength","cleanedURL","split","regex","RegExp","test"],"sources":["@wordpress/block-editor/src/components/link-control/is-url-like.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { getProtocol, isValidProtocol, isValidFragment } from '@wordpress/url';\r\n\r\n/**\r\n * Determines whether a given value could be a URL. Note this does not\r\n * guarantee the value is a URL only that it looks like it might be one. For\r\n * example, just because a string has `www.` in it doesn't make it a URL,\r\n * but it does make it highly likely that it will be so in the context of\r\n * creating a link it makes sense to treat it like one.\r\n *\r\n * @param {string} val the candidate for being URL-like (or not).\r\n *\r\n * @return {boolean} whether or not the value is potentially a URL.\r\n */\r\nexport default function isURLLike( val ) {\r\n\tconst hasSpaces = val.includes( ' ' );\r\n\r\n\tif ( hasSpaces ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tconst protocol = getProtocol( val );\r\n\tconst protocolIsValid = isValidProtocol( protocol );\r\n\r\n\tconst mayBeTLD = hasPossibleTLD( val );\r\n\r\n\tconst isWWW = val?.startsWith( 'www.' );\r\n\r\n\tconst isInternal = val?.startsWith( '#' ) && isValidFragment( val );\r\n\r\n\treturn protocolIsValid || isWWW || isInternal || mayBeTLD;\r\n}\r\n\r\n/**\r\n * Checks if a given URL has a valid Top-Level Domain (TLD).\r\n *\r\n * @param {string} url       - The URL to check.\r\n * @param {number} maxLength - The maximum length of the TLD.\r\n * @return {boolean} Returns true if the URL has a valid TLD, false otherwise.\r\n */\r\nfunction hasPossibleTLD( url, maxLength = 6 ) {\r\n\t// Clean the URL by removing anything after the first occurrence of \"?\" or \"#\".\r\n\tconst cleanedURL = url.split( /[?#]/ )[ 0 ];\r\n\r\n\t// Regular expression explanation:\r\n\t// - (?<=\\S)                  : Positive lookbehind assertion to ensure there is at least one non-whitespace character before the TLD\r\n\t// - \\.                       : Matches a literal dot (.)\r\n\t// - [a-zA-Z_]{2,maxLength}   : Matches 2 to maxLength letters or underscores, representing the TLD\r\n\t// - (?:\\/|$)                 : Non-capturing group that matches either a forward slash (/) or the end of the string\r\n\tconst regex = new RegExp(\r\n\t\t`(?<=\\\\S)\\\\.(?:[a-zA-Z_]{2,${ maxLength }})(?:\\\\/|$)`\r\n\t);\r\n\r\n\treturn regex.test( cleanedURL );\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,WAAW,EAAEC,eAAe,EAAEC,eAAe,QAAQ,gBAAgB;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,SAASA,CAAEC,GAAG,EAAG;EACxC,MAAMC,SAAS,GAAGD,GAAG,CAACE,QAAQ,CAAE,GAAI,CAAC;EAErC,IAAKD,SAAS,EAAG;IAChB,OAAO,KAAK;EACb;EAEA,MAAME,QAAQ,GAAGP,WAAW,CAAEI,GAAI,CAAC;EACnC,MAAMI,eAAe,GAAGP,eAAe,CAAEM,QAAS,CAAC;EAEnD,MAAME,QAAQ,GAAGC,cAAc,CAAEN,GAAI,CAAC;EAEtC,MAAMO,KAAK,GAAGP,GAAG,EAAEQ,UAAU,CAAE,MAAO,CAAC;EAEvC,MAAMC,UAAU,GAAGT,GAAG,EAAEQ,UAAU,CAAE,GAAI,CAAC,IAAIV,eAAe,CAAEE,GAAI,CAAC;EAEnE,OAAOI,eAAe,IAAIG,KAAK,IAAIE,UAAU,IAAIJ,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAAEI,GAAG,EAAEC,SAAS,GAAG,CAAC,EAAG;EAC7C;EACA,MAAMC,UAAU,GAAGF,GAAG,CAACG,KAAK,CAAE,MAAO,CAAC,CAAE,CAAC,CAAE;;EAE3C;EACA;EACA;EACA;EACA;EACA,MAAMC,KAAK,GAAG,IAAIC,MAAM,CACtB,6BAA6BJ,SAAW,aAC1C,CAAC;EAED,OAAOG,KAAK,CAACE,IAAI,CAAEJ,UAAW,CAAC;AAChC","ignoreList":[]}