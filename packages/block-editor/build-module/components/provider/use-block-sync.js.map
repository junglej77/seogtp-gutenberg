{"version":3,"names":["useEffect","useRef","useRegistry","useSelect","cloneBlock","store","blockEditorStore","noop","useBlockSync","clientId","value","controlledBlocks","selection","controlledSelection","onChange","onInput","registry","resetBlocks","resetSelection","replaceInnerBlocks","setHasControlledInnerBlocks","__unstableMarkNextChangeAsNotPersistent","dispatch","getBlockName","getBlocks","getSelectionStart","getSelectionEnd","select","isControlled","areInnerBlocksControlled","pendingChangesRef","incoming","outgoing","subscribedRef","setControlledBlocks","batch","storeBlocks","map","block","current","unsetControlledBlocks","onInputRef","onChangeRef","includes","length","selectionStart","selectionEnd","initialPosition","isMountedRef","getSelectedBlocksInitialCaretPosition","isLastBlockChangePersistent","__unstableIsLastBlockChangeIgnored","blocks","isPersistent","previousAreBlocksDifferent","unsubscribe","subscribe","isStillControlled","newIsPersistent","newBlocks","areBlocksDifferent","didPersistenceChange","push","updateParent"],"sources":["@wordpress/block-editor/src/components/provider/use-block-sync.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { useEffect, useRef } from '@wordpress/element';\r\nimport { useRegistry, useSelect } from '@wordpress/data';\r\nimport { cloneBlock } from '@wordpress/blocks';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport { store as blockEditorStore } from '../../store';\r\n\r\nconst noop = () => {};\r\n\r\n/**\r\n * A function to call when the block value has been updated in the block-editor\r\n * store.\r\n *\r\n * @callback onBlockUpdate\r\n * @param {Object[]} blocks  The updated blocks.\r\n * @param {Object}   options The updated block options, such as selectionStart\r\n *                           and selectionEnd.\r\n */\r\n\r\n/**\r\n * useBlockSync is a side effect which handles bidirectional sync between the\r\n * block-editor store and a controlling data source which provides blocks. This\r\n * is most commonly used by the BlockEditorProvider to synchronize the contents\r\n * of the block-editor store with the root entity, like a post.\r\n *\r\n * Another example would be the template part block, which provides blocks from\r\n * a separate entity data source than a root entity. This hook syncs edits to\r\n * the template part in the block editor back to the entity and vice-versa.\r\n *\r\n * Here are some of its basic functions:\r\n * - Initalizes the block-editor store for the given clientID to the blocks\r\n *   given via props.\r\n * - Adds incoming changes (like undo) to the block-editor store.\r\n * - Adds outgoing changes (like editing content) to the controlling entity,\r\n *   determining if a change should be considered persistent or not.\r\n * - Handles edge cases and race conditions which occur in those operations.\r\n * - Ignores changes which happen to other entities (like nested inner block\r\n *   controllers.\r\n * - Passes selection state from the block-editor store to the controlling entity.\r\n *\r\n * @param {Object}        props           Props for the block sync hook\r\n * @param {string}        props.clientId  The client ID of the inner block controller.\r\n *                                        If none is passed, then it is assumed to be a\r\n *                                        root controller rather than an inner block\r\n *                                        controller.\r\n * @param {Object[]}      props.value     The control value for the blocks. This value\r\n *                                        is used to initalize the block-editor store\r\n *                                        and for resetting the blocks to incoming\r\n *                                        changes like undo.\r\n * @param {Object}        props.selection The selection state responsible to restore the selection on undo/redo.\r\n * @param {onBlockUpdate} props.onChange  Function to call when a persistent\r\n *                                        change has been made in the block-editor blocks\r\n *                                        for the given clientId. For example, after\r\n *                                        this function is called, an entity is marked\r\n *                                        dirty because it has changes to save.\r\n * @param {onBlockUpdate} props.onInput   Function to call when a non-persistent\r\n *                                        change has been made in the block-editor blocks\r\n *                                        for the given clientId. When this is called,\r\n *                                        controlling sources do not become dirty.\r\n */\r\nexport default function useBlockSync( {\r\n\tclientId = null,\r\n\tvalue: controlledBlocks,\r\n\tselection: controlledSelection,\r\n\tonChange = noop,\r\n\tonInput = noop,\r\n} ) {\r\n\tconst registry = useRegistry();\r\n\r\n\tconst {\r\n\t\tresetBlocks,\r\n\t\tresetSelection,\r\n\t\treplaceInnerBlocks,\r\n\t\tsetHasControlledInnerBlocks,\r\n\t\t__unstableMarkNextChangeAsNotPersistent,\r\n\t} = registry.dispatch( blockEditorStore );\r\n\tconst { getBlockName, getBlocks, getSelectionStart, getSelectionEnd } =\r\n\t\tregistry.select( blockEditorStore );\r\n\tconst isControlled = useSelect(\r\n\t\t( select ) => {\r\n\t\t\treturn (\r\n\t\t\t\t! clientId ||\r\n\t\t\t\tselect( blockEditorStore ).areInnerBlocksControlled( clientId )\r\n\t\t\t);\r\n\t\t},\r\n\t\t[ clientId ]\r\n\t);\r\n\r\n\tconst pendingChangesRef = useRef( { incoming: null, outgoing: [] } );\r\n\tconst subscribedRef = useRef( false );\r\n\r\n\tconst setControlledBlocks = () => {\r\n\t\tif ( ! controlledBlocks ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We don't need to persist this change because we only replace\r\n\t\t// controlled inner blocks when the change was caused by an entity,\r\n\t\t// and so it would already be persisted.\r\n\t\t__unstableMarkNextChangeAsNotPersistent();\r\n\t\tif ( clientId ) {\r\n\t\t\t// It is important to batch here because otherwise,\r\n\t\t\t// as soon as `setHasControlledInnerBlocks` is called\r\n\t\t\t// the effect to restore might be triggered\r\n\t\t\t// before the actual blocks get set properly in state.\r\n\t\t\tregistry.batch( () => {\r\n\t\t\t\tsetHasControlledInnerBlocks( clientId, true );\r\n\t\t\t\tconst storeBlocks = controlledBlocks.map( ( block ) =>\r\n\t\t\t\t\tcloneBlock( block )\r\n\t\t\t\t);\r\n\t\t\t\tif ( subscribedRef.current ) {\r\n\t\t\t\t\tpendingChangesRef.current.incoming = storeBlocks;\r\n\t\t\t\t}\r\n\t\t\t\t__unstableMarkNextChangeAsNotPersistent();\r\n\t\t\t\treplaceInnerBlocks( clientId, storeBlocks );\r\n\t\t\t} );\r\n\t\t} else {\r\n\t\t\tif ( subscribedRef.current ) {\r\n\t\t\t\tpendingChangesRef.current.incoming = controlledBlocks;\r\n\t\t\t}\r\n\t\t\tresetBlocks( controlledBlocks );\r\n\t\t}\r\n\t};\r\n\r\n\t// Clean up the changes made by setControlledBlocks() when the component\r\n\t// containing useBlockSync() unmounts.\r\n\tconst unsetControlledBlocks = () => {\r\n\t\t__unstableMarkNextChangeAsNotPersistent();\r\n\t\tif ( clientId ) {\r\n\t\t\tsetHasControlledInnerBlocks( clientId, false );\r\n\t\t\t__unstableMarkNextChangeAsNotPersistent();\r\n\t\t\treplaceInnerBlocks( clientId, [] );\r\n\t\t} else {\r\n\t\t\tresetBlocks( [] );\r\n\t\t}\r\n\t};\r\n\r\n\t// Add a subscription to the block-editor registry to detect when changes\r\n\t// have been made. This lets us inform the data source of changes. This\r\n\t// is an effect so that the subscriber can run synchronously without\r\n\t// waiting for React renders for changes.\r\n\tconst onInputRef = useRef( onInput );\r\n\tconst onChangeRef = useRef( onChange );\r\n\tuseEffect( () => {\r\n\t\tonInputRef.current = onInput;\r\n\t\tonChangeRef.current = onChange;\r\n\t}, [ onInput, onChange ] );\r\n\r\n\t// Determine if blocks need to be reset when they change.\r\n\tuseEffect( () => {\r\n\t\tif ( pendingChangesRef.current.outgoing.includes( controlledBlocks ) ) {\r\n\t\t\t// Skip block reset if the value matches expected outbound sync\r\n\t\t\t// triggered by this component by a preceding change detection.\r\n\t\t\t// Only skip if the value matches expectation, since a reset should\r\n\t\t\t// still occur if the value is modified (not equal by reference),\r\n\t\t\t// to allow that the consumer may apply modifications to reflect\r\n\t\t\t// back on the editor.\r\n\t\t\tif (\r\n\t\t\t\tpendingChangesRef.current.outgoing[\r\n\t\t\t\t\tpendingChangesRef.current.outgoing.length - 1\r\n\t\t\t\t] === controlledBlocks\r\n\t\t\t) {\r\n\t\t\t\tpendingChangesRef.current.outgoing = [];\r\n\t\t\t}\r\n\t\t} else if ( getBlocks( clientId ) !== controlledBlocks ) {\r\n\t\t\t// Reset changing value in all other cases than the sync described\r\n\t\t\t// above. Since this can be reached in an update following an out-\r\n\t\t\t// bound sync, unset the outbound value to avoid considering it in\r\n\t\t\t// subsequent renders.\r\n\t\t\tpendingChangesRef.current.outgoing = [];\r\n\t\t\tsetControlledBlocks();\r\n\r\n\t\t\tif ( controlledSelection ) {\r\n\t\t\t\tresetSelection(\r\n\t\t\t\t\tcontrolledSelection.selectionStart,\r\n\t\t\t\t\tcontrolledSelection.selectionEnd,\r\n\t\t\t\t\tcontrolledSelection.initialPosition\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}, [ controlledBlocks, clientId ] );\r\n\r\n\tconst isMountedRef = useRef( false );\r\n\r\n\tuseEffect( () => {\r\n\t\t// On mount, controlled blocks are already set in the effect above.\r\n\t\tif ( ! isMountedRef.current ) {\r\n\t\t\tisMountedRef.current = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// When the block becomes uncontrolled, it means its inner state has been reset\r\n\t\t// we need to take the blocks again from the external value property.\r\n\t\tif ( ! isControlled ) {\r\n\t\t\tpendingChangesRef.current.outgoing = [];\r\n\t\t\tsetControlledBlocks();\r\n\t\t}\r\n\t}, [ isControlled ] );\r\n\r\n\tuseEffect( () => {\r\n\t\tconst {\r\n\t\t\tgetSelectedBlocksInitialCaretPosition,\r\n\t\t\tisLastBlockChangePersistent,\r\n\t\t\t__unstableIsLastBlockChangeIgnored,\r\n\t\t\tareInnerBlocksControlled,\r\n\t\t} = registry.select( blockEditorStore );\r\n\r\n\t\tlet blocks = getBlocks( clientId );\r\n\t\tlet isPersistent = isLastBlockChangePersistent();\r\n\t\tlet previousAreBlocksDifferent = false;\r\n\r\n\t\tsubscribedRef.current = true;\r\n\t\tconst unsubscribe = registry.subscribe( () => {\r\n\t\t\t// Sometimes, when changing block lists, lingering subscriptions\r\n\t\t\t// might trigger before they are cleaned up. If the block for which\r\n\t\t\t// the subscription runs is no longer in the store, this would clear\r\n\t\t\t// its parent entity's block list. To avoid this, we bail out if\r\n\t\t\t// the subscription is triggering for a block (`clientId !== null`)\r\n\t\t\t// and its block name can't be found because it's not on the list.\r\n\t\t\t// (`getBlockName( clientId ) === null`).\r\n\t\t\tif ( clientId !== null && getBlockName( clientId ) === null ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// When RESET_BLOCKS on parent blocks get called, the controlled blocks\r\n\t\t\t// can reset to uncontrolled, in these situations, it means we need to populate\r\n\t\t\t// the blocks again from the external blocks (the value property here)\r\n\t\t\t// and we should stop triggering onChange\r\n\t\t\tconst isStillControlled =\r\n\t\t\t\t! clientId || areInnerBlocksControlled( clientId );\r\n\t\t\tif ( ! isStillControlled ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst newIsPersistent = isLastBlockChangePersistent();\r\n\t\t\tconst newBlocks = getBlocks( clientId );\r\n\t\t\tconst areBlocksDifferent = newBlocks !== blocks;\r\n\t\t\tblocks = newBlocks;\r\n\t\t\tif (\r\n\t\t\t\tareBlocksDifferent &&\r\n\t\t\t\t( pendingChangesRef.current.incoming ||\r\n\t\t\t\t\t__unstableIsLastBlockChangeIgnored() )\r\n\t\t\t) {\r\n\t\t\t\tpendingChangesRef.current.incoming = null;\r\n\t\t\t\tisPersistent = newIsPersistent;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Since we often dispatch an action to mark the previous action as\r\n\t\t\t// persistent, we need to make sure that the blocks changed on the\r\n\t\t\t// previous action before committing the change.\r\n\t\t\tconst didPersistenceChange =\r\n\t\t\t\tpreviousAreBlocksDifferent &&\r\n\t\t\t\t! areBlocksDifferent &&\r\n\t\t\t\tnewIsPersistent &&\r\n\t\t\t\t! isPersistent;\r\n\r\n\t\t\tif ( areBlocksDifferent || didPersistenceChange ) {\r\n\t\t\t\tisPersistent = newIsPersistent;\r\n\t\t\t\t// We know that onChange/onInput will update controlledBlocks.\r\n\t\t\t\t// We need to be aware that it was caused by an outgoing change\r\n\t\t\t\t// so that we do not treat it as an incoming change later on,\r\n\t\t\t\t// which would cause a block reset.\r\n\t\t\t\tpendingChangesRef.current.outgoing.push( blocks );\r\n\r\n\t\t\t\t// Inform the controlling entity that changes have been made to\r\n\t\t\t\t// the block-editor store they should be aware about.\r\n\t\t\t\tconst updateParent = isPersistent\r\n\t\t\t\t\t? onChangeRef.current\r\n\t\t\t\t\t: onInputRef.current;\r\n\t\t\t\tupdateParent( blocks, {\r\n\t\t\t\t\tselection: {\r\n\t\t\t\t\t\tselectionStart: getSelectionStart(),\r\n\t\t\t\t\t\tselectionEnd: getSelectionEnd(),\r\n\t\t\t\t\t\tinitialPosition:\r\n\t\t\t\t\t\t\tgetSelectedBlocksInitialCaretPosition(),\r\n\t\t\t\t\t},\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t\tpreviousAreBlocksDifferent = areBlocksDifferent;\r\n\t\t}, blockEditorStore );\r\n\r\n\t\treturn () => {\r\n\t\t\tsubscribedRef.current = false;\r\n\t\t\tunsubscribe();\r\n\t\t};\r\n\t}, [ registry, clientId ] );\r\n\r\n\tuseEffect( () => {\r\n\t\treturn () => {\r\n\t\t\tunsetControlledBlocks();\r\n\t\t};\r\n\t}, [] );\r\n}\r\n"],"mappings":"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","ignoreList":[]}