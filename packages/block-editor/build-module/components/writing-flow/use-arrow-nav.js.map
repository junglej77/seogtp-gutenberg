{"version":3,"names":["computeCaretRect","focus","isHorizontalEdge","isVerticalEdge","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","isRTL","UP","DOWN","LEFT","RIGHT","useDispatch","useSelect","useRefEffect","getBlockClientId","isInSameBlock","store","blockEditorStore","getSelectionRoot","isNavigationCandidate","element","keyCode","hasModifier","isVertical","tagName","elementType","getAttribute","verticalInputTypes","includes","simpleInputTypes","getClosestTabbable","target","isReverse","containerElement","onlyVertical","focusableNodes","focusable","find","reverse","slice","indexOf","targetRect","getBoundingClientRect","isTabCandidate","node","closest","children","length","firstElementChild","tabbable","isTabbableIndex","isContentEditable","contentEditable","nodeRect","left","right","useArrowNav","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getSettings","hasMultiSelection","__unstableIsFullySelected","selectBlock","verticalRect","onMouseDown","isClosestTabbableABlock","closestTabbable","onKeyDown","event","defaultPrevented","shiftKey","ctrlKey","altKey","metaKey","isUp","isDown","isLeft","isRight","isHorizontal","isNav","isNavEdge","ownerDocument","defaultView","preventDefault","activeElement","isReverseDir","keepCaretInsideBlock","undefined","getSelection","isCollapsed","addEventListener","removeEventListener"],"sources":["@wordpress/block-editor/src/components/writing-flow/use-arrow-nav.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport {\r\n\tcomputeCaretRect,\r\n\tfocus,\r\n\tisHorizontalEdge,\r\n\tisVerticalEdge,\r\n\tplaceCaretAtHorizontalEdge,\r\n\tplaceCaretAtVerticalEdge,\r\n\tisRTL,\r\n} from '@wordpress/dom';\r\nimport { UP, DOWN, LEFT, RIGHT } from '@wordpress/keycodes';\r\nimport { useDispatch, useSelect } from '@wordpress/data';\r\nimport { useRefEffect } from '@wordpress/compose';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport { getBlockClientId, isInSameBlock } from '../../utils/dom';\r\nimport { store as blockEditorStore } from '../../store';\r\nimport { getSelectionRoot } from './utils';\r\n\r\n/**\r\n * Returns true if the element should consider edge navigation upon a keyboard\r\n * event of the given directional key code, or false otherwise.\r\n *\r\n * @param {Element} element     HTML element to test.\r\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\r\n * @param {boolean} hasModifier Whether a modifier is pressed.\r\n *\r\n * @return {boolean} Whether element should consider edge navigation.\r\n */\r\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\r\n\tconst isVertical = keyCode === UP || keyCode === DOWN;\r\n\tconst { tagName } = element;\r\n\tconst elementType = element.getAttribute( 'type' );\r\n\r\n\t// Native inputs should not navigate vertically, unless they are simple types that don't need up/down arrow keys.\r\n\tif ( isVertical && ! hasModifier ) {\r\n\t\tif ( tagName === 'INPUT' ) {\r\n\t\t\tconst verticalInputTypes = [\r\n\t\t\t\t'date',\r\n\t\t\t\t'datetime-local',\r\n\t\t\t\t'month',\r\n\t\t\t\t'number',\r\n\t\t\t\t'range',\r\n\t\t\t\t'time',\r\n\t\t\t\t'week',\r\n\t\t\t];\r\n\t\t\treturn ! verticalInputTypes.includes( elementType );\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Native inputs should not navigate horizontally, unless they are simple types that don't need left/right arrow keys.\r\n\tif ( tagName === 'INPUT' ) {\r\n\t\tconst simpleInputTypes = [\r\n\t\t\t'button',\r\n\t\t\t'checkbox',\r\n\t\t\t'number',\r\n\t\t\t'color',\r\n\t\t\t'file',\r\n\t\t\t'image',\r\n\t\t\t'radio',\r\n\t\t\t'reset',\r\n\t\t\t'submit',\r\n\t\t];\r\n\t\treturn simpleInputTypes.includes( elementType );\r\n\t}\r\n\r\n\t// Native textareas should not navigate horizontally.\r\n\treturn tagName !== 'TEXTAREA';\r\n}\r\n\r\n/**\r\n * Returns the optimal tab target from the given focused element in the desired\r\n * direction. A preference is made toward text fields, falling back to the block\r\n * focus stop if no other candidates exist for the block.\r\n *\r\n * @param {Element} target           Currently focused text field.\r\n * @param {boolean} isReverse        True if considering as the first field.\r\n * @param {Element} containerElement Element containing all blocks.\r\n * @param {boolean} onlyVertical     Whether to only consider tabbable elements\r\n *                                   that are visually above or under the\r\n *                                   target.\r\n *\r\n * @return {?Element} Optimal tab target, if one exists.\r\n */\r\nexport function getClosestTabbable(\r\n\ttarget,\r\n\tisReverse,\r\n\tcontainerElement,\r\n\tonlyVertical\r\n) {\r\n\t// Since the current focus target is not guaranteed to be a text field, find\r\n\t// all focusables. Tabbability is considered later.\r\n\tlet focusableNodes = focus.focusable.find( containerElement );\r\n\r\n\tif ( isReverse ) {\r\n\t\tfocusableNodes.reverse();\r\n\t}\r\n\r\n\t// Consider as candidates those focusables after the current target. It's\r\n\t// assumed this can only be reached if the target is focusable (on its\r\n\t// keydown event), so no need to verify it exists in the set.\r\n\tfocusableNodes = focusableNodes.slice(\r\n\t\tfocusableNodes.indexOf( target ) + 1\r\n\t);\r\n\r\n\tlet targetRect;\r\n\r\n\tif ( onlyVertical ) {\r\n\t\ttargetRect = target.getBoundingClientRect();\r\n\t}\r\n\r\n\tfunction isTabCandidate( node ) {\r\n\t\tif ( node.closest( '[inert]' ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Skip if there's only one child that is content editable (and thus a\r\n\t\t// better candidate).\r\n\t\tif (\r\n\t\t\tnode.children.length === 1 &&\r\n\t\t\tisInSameBlock( node, node.firstElementChild ) &&\r\n\t\t\tnode.firstElementChild.getAttribute( 'contenteditable' ) === 'true'\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Not a candidate if the node is not tabbable.\r\n\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Skip focusable elements such as links within content editable nodes.\r\n\t\tif ( node.isContentEditable && node.contentEditable !== 'true' ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif ( onlyVertical ) {\r\n\t\t\tconst nodeRect = node.getBoundingClientRect();\r\n\r\n\t\t\tif (\r\n\t\t\t\tnodeRect.left >= targetRect.right ||\r\n\t\t\t\tnodeRect.right <= targetRect.left\r\n\t\t\t) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn focusableNodes.find( isTabCandidate );\r\n}\r\n\r\nexport default function useArrowNav() {\r\n\tconst {\r\n\t\tgetMultiSelectedBlocksStartClientId,\r\n\t\tgetMultiSelectedBlocksEndClientId,\r\n\t\tgetSettings,\r\n\t\thasMultiSelection,\r\n\t\t__unstableIsFullySelected,\r\n\t} = useSelect( blockEditorStore );\r\n\tconst { selectBlock } = useDispatch( blockEditorStore );\r\n\treturn useRefEffect( ( node ) => {\r\n\t\t// Here a DOMRect is stored while moving the caret vertically so\r\n\t\t// vertical position of the start position can be restored. This is to\r\n\t\t// recreate browser behaviour across blocks.\r\n\t\tlet verticalRect;\r\n\r\n\t\tfunction onMouseDown() {\r\n\t\t\tverticalRect = null;\r\n\t\t}\r\n\r\n\t\tfunction isClosestTabbableABlock( target, isReverse ) {\r\n\t\t\tconst closestTabbable = getClosestTabbable(\r\n\t\t\t\ttarget,\r\n\t\t\t\tisReverse,\r\n\t\t\t\tnode\r\n\t\t\t);\r\n\t\t\treturn closestTabbable && getBlockClientId( closestTabbable );\r\n\t\t}\r\n\r\n\t\tfunction onKeyDown( event ) {\r\n\t\t\t// Abort if navigation has already been handled (e.g. RichText\r\n\t\t\t// inline boundaries).\r\n\t\t\tif ( event.defaultPrevented ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst { keyCode, shiftKey, ctrlKey, altKey, metaKey } = event;\r\n\t\t\tconst isUp = keyCode === UP;\r\n\t\t\tconst isDown = keyCode === DOWN;\r\n\t\t\tconst isLeft = keyCode === LEFT;\r\n\t\t\tconst isRight = keyCode === RIGHT;\r\n\t\t\tconst isReverse = isUp || isLeft;\r\n\t\t\tconst isHorizontal = isLeft || isRight;\r\n\t\t\tconst isVertical = isUp || isDown;\r\n\t\t\tconst isNav = isHorizontal || isVertical;\r\n\t\t\tconst hasModifier = shiftKey || ctrlKey || altKey || metaKey;\r\n\t\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\r\n\t\t\tconst { ownerDocument } = node;\r\n\t\t\tconst { defaultView } = ownerDocument;\r\n\r\n\t\t\tif ( ! isNav ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// If there is a multi-selection, the arrow keys should collapse the\r\n\t\t\t// selection to the start or end of the selection.\r\n\t\t\tif ( hasMultiSelection() ) {\r\n\t\t\t\tif ( shiftKey ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Only handle if we have a full selection (not a native partial\r\n\t\t\t\t// selection).\r\n\t\t\t\tif ( ! __unstableIsFullySelected() ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tevent.preventDefault();\r\n\r\n\t\t\t\tif ( isReverse ) {\r\n\t\t\t\t\tselectBlock( getMultiSelectedBlocksStartClientId() );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tselectBlock( getMultiSelectedBlocksEndClientId(), -1 );\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst target =\r\n\t\t\t\townerDocument.activeElement === node\r\n\t\t\t\t\t? getSelectionRoot( ownerDocument )\r\n\t\t\t\t\t: event.target;\r\n\r\n\t\t\t// Abort if our current target is not a candidate for navigation\r\n\t\t\t// (e.g. preserve native input behaviors).\r\n\t\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// When presing any key other than up or down, the initial vertical\r\n\t\t\t// position must ALWAYS be reset. The vertical position is saved so\r\n\t\t\t// it can be restored as well as possible on sebsequent vertical\r\n\t\t\t// arrow key presses. It may not always be possible to restore the\r\n\t\t\t// exact same position (such as at an empty line), so it wouldn't be\r\n\t\t\t// good to compute the position right before any vertical arrow key\r\n\t\t\t// press.\r\n\t\t\tif ( ! isVertical ) {\r\n\t\t\t\tverticalRect = null;\r\n\t\t\t} else if ( ! verticalRect ) {\r\n\t\t\t\tverticalRect = computeCaretRect( defaultView );\r\n\t\t\t}\r\n\r\n\t\t\t// In the case of RTL scripts, right means previous and left means\r\n\t\t\t// next, which is the exact reverse of LTR.\r\n\t\t\tconst isReverseDir = isRTL( target ) ? ! isReverse : isReverse;\r\n\t\t\tconst { keepCaretInsideBlock } = getSettings();\r\n\r\n\t\t\tif ( shiftKey ) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tisClosestTabbableABlock( target, isReverse ) &&\r\n\t\t\t\t\tisNavEdge( target, isReverse )\r\n\t\t\t\t) {\r\n\t\t\t\t\tnode.contentEditable = true;\r\n\t\t\t\t\t// Firefox doesn't automatically move focus.\r\n\t\t\t\t\tnode.focus();\r\n\t\t\t\t}\r\n\t\t\t} else if (\r\n\t\t\t\tisVertical &&\r\n\t\t\t\tisVerticalEdge( target, isReverse ) &&\r\n\t\t\t\t// When Alt is pressed, only intercept if the caret is also at\r\n\t\t\t\t// the horizontal edge.\r\n\t\t\t\t( altKey ? isHorizontalEdge( target, isReverseDir ) : true ) &&\r\n\t\t\t\t! keepCaretInsideBlock\r\n\t\t\t) {\r\n\t\t\t\tnode.contentEditable = false;\r\n\t\t\t\tconst closestTabbable = getClosestTabbable(\r\n\t\t\t\t\ttarget,\r\n\t\t\t\t\tisReverse,\r\n\t\t\t\t\tnode,\r\n\t\t\t\t\ttrue\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif ( closestTabbable ) {\r\n\t\t\t\t\tplaceCaretAtVerticalEdge(\r\n\t\t\t\t\t\tclosestTabbable,\r\n\t\t\t\t\t\t// When Alt is pressed, place the caret at the furthest\r\n\t\t\t\t\t\t// horizontal edge and the furthest vertical edge.\r\n\t\t\t\t\t\taltKey ? ! isReverse : isReverse,\r\n\t\t\t\t\t\taltKey ? undefined : verticalRect\r\n\t\t\t\t\t);\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t} else if (\r\n\t\t\t\tisHorizontal &&\r\n\t\t\t\tdefaultView.getSelection().isCollapsed &&\r\n\t\t\t\tisHorizontalEdge( target, isReverseDir ) &&\r\n\t\t\t\t! keepCaretInsideBlock\r\n\t\t\t) {\r\n\t\t\t\tnode.contentEditable = false;\r\n\t\t\t\tconst closestTabbable = getClosestTabbable(\r\n\t\t\t\t\ttarget,\r\n\t\t\t\t\tisReverseDir,\r\n\t\t\t\t\tnode\r\n\t\t\t\t);\r\n\t\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverse );\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnode.addEventListener( 'mousedown', onMouseDown );\r\n\t\tnode.addEventListener( 'keydown', onKeyDown );\r\n\t\treturn () => {\r\n\t\t\tnode.removeEventListener( 'mousedown', onMouseDown );\r\n\t\t\tnode.removeEventListener( 'keydown', onKeyDown );\r\n\t\t};\r\n\t}, [] );\r\n}\r\n"],"mappings":"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","ignoreList":[]}