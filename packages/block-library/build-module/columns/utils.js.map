{"version":3,"names":["toWidthPrecision","value","unitlessValue","parseFloat","Number","isFinite","toFixed","undefined","getEffectiveColumnWidth","block","totalBlockCount","width","attributes","getTotalColumnsWidth","blocks","length","reduce","sum","getColumnWidths","accumulator","Object","assign","clientId","getRedistributedColumnWidths","availableWidth","totalWidth","fromEntries","entries","map","newWidth","hasExplicitPercentColumnWidths","every","blockWidth","endsWith","getMappedColumnWidths","widths","getWidths","withParsing","innerColumn","innerColumnWidth","getWidthWithUnit","unit","isPercentageUnit","Math","min"],"sources":["@wordpress/block-library/src/columns/utils.js"],"sourcesContent":["/**\r\n * Returns a column width attribute value rounded to standard precision.\r\n * Returns `undefined` if the value is not a valid finite number.\r\n *\r\n * @param {?number} value Raw value.\r\n *\r\n * @return {number} Value rounded to standard precision.\r\n */\r\nexport const toWidthPrecision = ( value ) => {\r\n\tconst unitlessValue = parseFloat( value );\r\n\treturn Number.isFinite( unitlessValue )\r\n\t\t? parseFloat( unitlessValue.toFixed( 2 ) )\r\n\t\t: undefined;\r\n};\r\n/**\r\n * Returns an effective width for a given block. An effective width is equal to\r\n * its attribute value if set, or a computed value assuming equal distribution.\r\n *\r\n * @param {WPBlock} block           Block object.\r\n * @param {number}  totalBlockCount Total number of blocks in Columns.\r\n *\r\n * @return {number} Effective column width.\r\n */\r\nexport function getEffectiveColumnWidth( block, totalBlockCount ) {\r\n\tconst { width = 100 / totalBlockCount } = block.attributes;\r\n\treturn toWidthPrecision( width );\r\n}\r\n\r\n/**\r\n * Returns the total width occupied by the given set of column blocks.\r\n *\r\n * @param {WPBlock[]} blocks          Block objects.\r\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\r\n *                                    Defaults to number of blocks passed.\r\n *\r\n * @return {number} Total width occupied by blocks.\r\n */\r\nexport function getTotalColumnsWidth(\r\n\tblocks,\r\n\ttotalBlockCount = blocks.length\r\n) {\r\n\treturn blocks.reduce(\r\n\t\t( sum, block ) =>\r\n\t\t\tsum + getEffectiveColumnWidth( block, totalBlockCount ),\r\n\t\t0\r\n\t);\r\n}\r\n\r\n/**\r\n * Returns an object of `clientId` → `width` of effective column widths.\r\n *\r\n * @param {WPBlock[]} blocks          Block objects.\r\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\r\n *                                    Defaults to number of blocks passed.\r\n *\r\n * @return {Object<string,number>} Column widths.\r\n */\r\nexport function getColumnWidths( blocks, totalBlockCount = blocks.length ) {\r\n\treturn blocks.reduce( ( accumulator, block ) => {\r\n\t\tconst width = getEffectiveColumnWidth( block, totalBlockCount );\r\n\t\treturn Object.assign( accumulator, { [ block.clientId ]: width } );\r\n\t}, {} );\r\n}\r\n\r\n/**\r\n * Returns an object of `clientId` → `width` of column widths as redistributed\r\n * proportional to their current widths, constrained or expanded to fit within\r\n * the given available width.\r\n *\r\n * @param {WPBlock[]} blocks          Block objects.\r\n * @param {number}    availableWidth  Maximum width to fit within.\r\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\r\n *                                    Defaults to number of blocks passed.\r\n *\r\n * @return {Object<string,number>} Redistributed column widths.\r\n */\r\nexport function getRedistributedColumnWidths(\r\n\tblocks,\r\n\tavailableWidth,\r\n\ttotalBlockCount = blocks.length\r\n) {\r\n\tconst totalWidth = getTotalColumnsWidth( blocks, totalBlockCount );\r\n\r\n\treturn Object.fromEntries(\r\n\t\tObject.entries( getColumnWidths( blocks, totalBlockCount ) ).map(\r\n\t\t\t( [ clientId, width ] ) => {\r\n\t\t\t\tconst newWidth = ( availableWidth * width ) / totalWidth;\r\n\t\t\t\treturn [ clientId, toWidthPrecision( newWidth ) ];\r\n\t\t\t}\r\n\t\t)\r\n\t);\r\n}\r\n\r\n/**\r\n * Returns true if column blocks within the provided set are assigned with\r\n * explicit widths, or false otherwise.\r\n *\r\n * @param {WPBlock[]} blocks Block objects.\r\n *\r\n * @return {boolean} Whether columns have explicit widths.\r\n */\r\nexport function hasExplicitPercentColumnWidths( blocks ) {\r\n\treturn blocks.every( ( block ) => {\r\n\t\tconst blockWidth = block.attributes.width;\r\n\t\treturn Number.isFinite(\r\n\t\t\tblockWidth?.endsWith?.( '%' )\r\n\t\t\t\t? parseFloat( blockWidth )\r\n\t\t\t\t: blockWidth\r\n\t\t);\r\n\t} );\r\n}\r\n\r\n/**\r\n * Returns a copy of the given set of blocks with new widths assigned from the\r\n * provided object of redistributed column widths.\r\n *\r\n * @param {WPBlock[]}             blocks Block objects.\r\n * @param {Object<string,number>} widths Redistributed column widths.\r\n *\r\n * @return {WPBlock[]} blocks Mapped block objects.\r\n */\r\nexport function getMappedColumnWidths( blocks, widths ) {\r\n\treturn blocks.map( ( block ) => ( {\r\n\t\t...block,\r\n\t\tattributes: {\r\n\t\t\t...block.attributes,\r\n\t\t\twidth: `${ widths[ block.clientId ] }%`,\r\n\t\t},\r\n\t} ) );\r\n}\r\n\r\n/**\r\n * Returns an array with columns widths values, parsed or no depends on `withParsing` flag.\r\n *\r\n * @param {WPBlock[]} blocks      Block objects.\r\n * @param {?boolean}  withParsing Whether value has to be parsed.\r\n *\r\n * @return {Array<number,string>} Column widths.\r\n */\r\nexport function getWidths( blocks, withParsing = true ) {\r\n\treturn blocks.map( ( innerColumn ) => {\r\n\t\tconst innerColumnWidth =\r\n\t\t\tinnerColumn.attributes.width || 100 / blocks.length;\r\n\r\n\t\treturn withParsing ? parseFloat( innerColumnWidth ) : innerColumnWidth;\r\n\t} );\r\n}\r\n\r\n/**\r\n * Returns a column width with unit.\r\n *\r\n * @param {string} width Column width.\r\n * @param {string} unit  Column width unit.\r\n *\r\n * @return {string} Column width with unit.\r\n */\r\nexport function getWidthWithUnit( width, unit ) {\r\n\twidth = 0 > parseFloat( width ) ? '0' : width;\r\n\r\n\tif ( isPercentageUnit( unit ) ) {\r\n\t\twidth = Math.min( width, 100 );\r\n\t}\r\n\r\n\treturn `${ width }${ unit }`;\r\n}\r\n\r\n/**\r\n * Returns a boolean whether passed unit is percentage\r\n *\r\n * @param {string} unit Column width unit.\r\n *\r\n * @return {boolean} \tWhether unit is '%'.\r\n */\r\nexport function isPercentageUnit( unit ) {\r\n\treturn unit === '%';\r\n}\r\n"],"mappings":"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","ignoreList":[]}