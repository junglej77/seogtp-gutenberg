{"version":3,"names":["useRegistry","cachedParsers","WeakMap","useParsePatternDependencies","registry","has","deps","Map","set","parsePatternDependencies","bind","get","name","blocks","queue","length","block","shift","innerBlock","_block$innerBlocks","innerBlocks","unshift","registerDependency","attributes","slug","a","b","Set","add","hasCycle","TypeError","visitedNodes","currentPath","_deps$get","dependencies","dependency","delete"],"sources":["@wordpress/block-library/src/pattern/recursion-detector.js"],"sourcesContent":["/**\r\n * THIS MODULE IS INTENTIONALLY KEPT WITHIN THE PATTERN BLOCK'S SOURCE.\r\n *\r\n * This is because this approach for preventing infinite loops due to\r\n * recursively rendering blocks is specific to the way that the `core/pattern`\r\n * block behaves in the editor. Any other block types that deal with recursion\r\n * SHOULD USE THE STANDARD METHOD for avoiding loops:\r\n *\r\n * @see https://github.com/WordPress/gutenberg/pull/31455\r\n * @see packages/block-editor/src/components/recursion-provider/README.md\r\n */\r\n\r\n/**\r\n * WordPress dependencies\r\n */\r\nimport { useRegistry } from '@wordpress/data';\r\n\r\n/**\r\n * Naming is hard.\r\n *\r\n * @see useParsePatternDependencies\r\n *\r\n * @type {WeakMap<Object, Function>}\r\n */\r\nconst cachedParsers = new WeakMap();\r\n\r\n/**\r\n * Hook used by PatternEdit to parse block patterns. It returns a function that\r\n * takes a pattern and returns nothing but throws an error if the pattern is\r\n * recursive.\r\n *\r\n * @example\r\n * ```js\r\n * const parsePatternDependencies = useParsePatternDependencies();\r\n * parsePatternDependencies( selectedPattern );\r\n * ```\r\n *\r\n * @see parsePatternDependencies\r\n *\r\n * @return {Function} A function to parse block patterns.\r\n */\r\nexport function useParsePatternDependencies() {\r\n\tconst registry = useRegistry();\r\n\r\n\t// Instead of caching maps, go straight to the point and cache bound\r\n\t// functions. Each of those functions is bound to a different Map that will\r\n\t// keep track of patterns in the context of the given registry.\r\n\tif ( ! cachedParsers.has( registry ) ) {\r\n\t\tconst deps = new Map();\r\n\t\tcachedParsers.set(\r\n\t\t\tregistry,\r\n\t\t\tparsePatternDependencies.bind( null, deps )\r\n\t\t);\r\n\t}\r\n\treturn cachedParsers.get( registry );\r\n}\r\n\r\n/**\r\n * Parse a given pattern and traverse its contents to detect any subsequent\r\n * patterns on which it may depend. Such occurrences will be added to an\r\n * internal dependency graph. If a circular dependency is detected, an\r\n * error will be thrown.\r\n *\r\n * EXPORTED FOR TESTING PURPOSES ONLY.\r\n *\r\n * @param {Map<string, Set<string>>} deps           Map of pattern dependencies.\r\n * @param {Object}                   pattern        Pattern.\r\n * @param {string}                   pattern.name   Pattern name.\r\n * @param {Array}                    pattern.blocks Pattern's block list.\r\n *\r\n * @throws {Error} If a circular dependency is detected.\r\n */\r\nexport function parsePatternDependencies( deps, { name, blocks } ) {\r\n\tconst queue = [ ...blocks ];\r\n\twhile ( queue.length ) {\r\n\t\tconst block = queue.shift();\r\n\t\tfor ( const innerBlock of block.innerBlocks ?? [] ) {\r\n\t\t\tqueue.unshift( innerBlock );\r\n\t\t}\r\n\t\tif ( block.name === 'core/pattern' ) {\r\n\t\t\tregisterDependency( deps, name, block.attributes.slug );\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Declare that pattern `a` depends on pattern `b`. If a circular\r\n * dependency is detected, an error will be thrown.\r\n *\r\n * EXPORTED FOR TESTING PURPOSES ONLY.\r\n *\r\n * @param {Map<string, Set<string>>} deps Map of pattern dependencies.\r\n * @param {string}                   a    Slug for pattern A.\r\n * @param {string}                   b    Slug for pattern B.\r\n *\r\n * @throws {Error} If a circular dependency is detected.\r\n */\r\nexport function registerDependency( deps, a, b ) {\r\n\tif ( ! deps.has( a ) ) {\r\n\t\tdeps.set( a, new Set() );\r\n\t}\r\n\tdeps.get( a ).add( b );\r\n\tif ( hasCycle( deps, a ) ) {\r\n\t\tthrow new TypeError(\r\n\t\t\t`Pattern ${ a } has a circular dependency and cannot be rendered.`\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Determine if a given pattern has circular dependencies on other patterns.\r\n * This will be determined by running a depth-first search on the current state\r\n * of the graph represented by `patternDependencies`.\r\n *\r\n * @param {Map<string, Set<string>>} deps           Map of pattern dependencies.\r\n * @param {string}                   slug           Pattern slug.\r\n * @param {Set<string>}              [visitedNodes] Set to track visited nodes in the graph.\r\n * @param {Set<string>}              [currentPath]  Set to track and backtrack graph paths.\r\n * @return {boolean} Whether any cycle was found.\r\n */\r\nfunction hasCycle(\r\n\tdeps,\r\n\tslug,\r\n\tvisitedNodes = new Set(),\r\n\tcurrentPath = new Set()\r\n) {\r\n\tvisitedNodes.add( slug );\r\n\tcurrentPath.add( slug );\r\n\r\n\tconst dependencies = deps.get( slug ) ?? new Set();\r\n\r\n\tfor ( const dependency of dependencies ) {\r\n\t\tif ( ! visitedNodes.has( dependency ) ) {\r\n\t\t\tif ( hasCycle( deps, dependency, visitedNodes, currentPath ) ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else if ( currentPath.has( dependency ) ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t// Remove the current node from the current path when backtracking\r\n\tcurrentPath.delete( slug );\r\n\treturn false;\r\n}\r\n"],"mappings":"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","ignoreList":[]}