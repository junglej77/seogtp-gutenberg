{"version":3,"names":["linearToNestedHeadingList","headingList","nestedHeadingList","forEach","heading","key","content","level","endOfSlice","length","i","push","children","slice"],"sources":["@wordpress/block-library/src/table-of-contents/utils.ts"],"sourcesContent":["export interface HeadingData {\r\n\t/** The plain text content of the heading. */\r\n\tcontent: string;\r\n\t/** The heading level. */\r\n\tlevel: number;\r\n\t/** Link to the heading. */\r\n\tlink: string;\r\n}\r\n\r\nexport interface NestedHeadingData {\r\n\t/** The heading content, level, and link. */\r\n\theading: HeadingData;\r\n\t/** The sub-headings of this heading, if any. */\r\n\tchildren: NestedHeadingData[] | null;\r\n}\r\n\r\n/**\r\n * Takes a flat list of heading parameters and nests them based on each header's\r\n * immediate parent's level.\r\n *\r\n * @param headingList The flat list of headings to nest.\r\n *\r\n * @return The nested list of headings.\r\n */\r\nexport function linearToNestedHeadingList(\r\n\theadingList: HeadingData[]\r\n): NestedHeadingData[] {\r\n\tconst nestedHeadingList: NestedHeadingData[] = [];\r\n\r\n\theadingList.forEach( ( heading, key ) => {\r\n\t\tif ( heading.content === '' ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Make sure we are only working with the same level as the first iteration in our set.\r\n\t\tif ( heading.level === headingList[ 0 ].level ) {\r\n\t\t\t// Check that the next iteration will return a value.\r\n\t\t\t// If it does and the next level is greater than the current level,\r\n\t\t\t// the next iteration becomes a child of the current iteration.\r\n\t\t\tif ( headingList[ key + 1 ]?.level > heading.level ) {\r\n\t\t\t\t// We must calculate the last index before the next iteration that\r\n\t\t\t\t// has the same level (siblings). We then use this index to slice\r\n\t\t\t\t// the array for use in recursion. This prevents duplicate nodes.\r\n\t\t\t\tlet endOfSlice = headingList.length;\r\n\t\t\t\tfor ( let i = key + 1; i < headingList.length; i++ ) {\r\n\t\t\t\t\tif ( headingList[ i ].level === heading.level ) {\r\n\t\t\t\t\t\tendOfSlice = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We found a child node: Push a new node onto the return array\r\n\t\t\t\t// with children.\r\n\t\t\t\tnestedHeadingList.push( {\r\n\t\t\t\t\theading,\r\n\t\t\t\t\tchildren: linearToNestedHeadingList(\r\n\t\t\t\t\t\theadingList.slice( key + 1, endOfSlice )\r\n\t\t\t\t\t),\r\n\t\t\t\t} );\r\n\t\t\t} else {\r\n\t\t\t\t// No child node: Push a new node onto the return array.\r\n\t\t\t\tnestedHeadingList.push( {\r\n\t\t\t\t\theading,\r\n\t\t\t\t\tchildren: null,\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\r\n\treturn nestedHeadingList;\r\n}\r\n"],"mappings":"AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,yBAAyBA,CACxCC,WAA0B,EACJ;EACtB,MAAMC,iBAAsC,GAAG,EAAE;EAEjDD,WAAW,CAACE,OAAO,CAAE,CAAEC,OAAO,EAAEC,GAAG,KAAM;IACxC,IAAKD,OAAO,CAACE,OAAO,KAAK,EAAE,EAAG;MAC7B;IACD;;IAEA;IACA,IAAKF,OAAO,CAACG,KAAK,KAAKN,WAAW,CAAE,CAAC,CAAE,CAACM,KAAK,EAAG;MAC/C;MACA;MACA;MACA,IAAKN,WAAW,CAAEI,GAAG,GAAG,CAAC,CAAE,EAAEE,KAAK,GAAGH,OAAO,CAACG,KAAK,EAAG;QACpD;QACA;QACA;QACA,IAAIC,UAAU,GAAGP,WAAW,CAACQ,MAAM;QACnC,KAAM,IAAIC,CAAC,GAAGL,GAAG,GAAG,CAAC,EAAEK,CAAC,GAAGT,WAAW,CAACQ,MAAM,EAAEC,CAAC,EAAE,EAAG;UACpD,IAAKT,WAAW,CAAES,CAAC,CAAE,CAACH,KAAK,KAAKH,OAAO,CAACG,KAAK,EAAG;YAC/CC,UAAU,GAAGE,CAAC;YACd;UACD;QACD;;QAEA;QACA;QACAR,iBAAiB,CAACS,IAAI,CAAE;UACvBP,OAAO;UACPQ,QAAQ,EAAEZ,yBAAyB,CAClCC,WAAW,CAACY,KAAK,CAAER,GAAG,GAAG,CAAC,EAAEG,UAAW,CACxC;QACD,CAAE,CAAC;MACJ,CAAC,MAAM;QACN;QACAN,iBAAiB,CAACS,IAAI,CAAE;UACvBP,OAAO;UACPQ,QAAQ,EAAE;QACX,CAAE,CAAC;MACJ;IACD;EACD,CAAE,CAAC;EAEH,OAAOV,iBAAiB;AACzB","ignoreList":[]}