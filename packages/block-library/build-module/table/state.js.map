{"version":3,"names":["INHERITED_COLUMN_ATTRIBUTES","createTable","rowCount","columnCount","body","Array","from","length","map","cells","content","tag","getFirstRow","state","isEmptyTableSection","head","foot","getCellAttribute","cellLocation","attributeName","sectionName","rowIndex","columnIndex","updateSelectedCell","selection","updateCell","tableSections","Object","fromEntries","entries","filter","key","includes","selectionSectionName","selectionRowIndex","section","row","cellAttributes","isCellSelected","type","insertRow","firstRow","cellCount","undefined","slice","_","index","_firstRow$cells$index","firstCellInColumn","inheritedAttributes","deleteRow","insertColumn","isEmptyRow","deleteColumn","cell","toggleSection","_state$body$0$cells$l","every"],"sources":["@wordpress/block-library/src/table/state.js"],"sourcesContent":["const INHERITED_COLUMN_ATTRIBUTES = [ 'align' ];\r\n\r\n/**\r\n * Creates a table state.\r\n *\r\n * @param {Object} options\r\n * @param {number} options.rowCount    Row count for the table to create.\r\n * @param {number} options.columnCount Column count for the table to create.\r\n *\r\n * @return {Object} New table state.\r\n */\r\nexport function createTable( { rowCount, columnCount } ) {\r\n\treturn {\r\n\t\tbody: Array.from( { length: rowCount } ).map( () => ( {\r\n\t\t\tcells: Array.from( { length: columnCount } ).map( () => ( {\r\n\t\t\t\tcontent: '',\r\n\t\t\t\ttag: 'td',\r\n\t\t\t} ) ),\r\n\t\t} ) ),\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns the first row in the table.\r\n *\r\n * @param {Object} state Current table state.\r\n *\r\n * @return {Object | undefined} The first table row.\r\n */\r\nexport function getFirstRow( state ) {\r\n\tif ( ! isEmptyTableSection( state.head ) ) {\r\n\t\treturn state.head[ 0 ];\r\n\t}\r\n\tif ( ! isEmptyTableSection( state.body ) ) {\r\n\t\treturn state.body[ 0 ];\r\n\t}\r\n\tif ( ! isEmptyTableSection( state.foot ) ) {\r\n\t\treturn state.foot[ 0 ];\r\n\t}\r\n}\r\n\r\n/**\r\n * Gets an attribute for a cell.\r\n *\r\n * @param {Object} state         Current table state.\r\n * @param {Object} cellLocation  The location of the cell\r\n * @param {string} attributeName The name of the attribute to get the value of.\r\n *\r\n * @return {*} The attribute value.\r\n */\r\nexport function getCellAttribute( state, cellLocation, attributeName ) {\r\n\tconst { sectionName, rowIndex, columnIndex } = cellLocation;\r\n\treturn state[ sectionName ]?.[ rowIndex ]?.cells?.[ columnIndex ]?.[\r\n\t\tattributeName\r\n\t];\r\n}\r\n\r\n/**\r\n * Returns updated cell attributes after applying the `updateCell` function to the selection.\r\n *\r\n * @param {Object}   state      The block attributes.\r\n * @param {Object}   selection  The selection of cells to update.\r\n * @param {Function} updateCell A function to update the selected cell attributes.\r\n *\r\n * @return {Object} New table state including the updated cells.\r\n */\r\nexport function updateSelectedCell( state, selection, updateCell ) {\r\n\tif ( ! selection ) {\r\n\t\treturn state;\r\n\t}\r\n\r\n\tconst tableSections = Object.fromEntries(\r\n\t\tObject.entries( state ).filter( ( [ key ] ) =>\r\n\t\t\t[ 'head', 'body', 'foot' ].includes( key )\r\n\t\t)\r\n\t);\r\n\tconst { sectionName: selectionSectionName, rowIndex: selectionRowIndex } =\r\n\t\tselection;\r\n\r\n\treturn Object.fromEntries(\r\n\t\tObject.entries( tableSections ).map( ( [ sectionName, section ] ) => {\r\n\t\t\tif (\r\n\t\t\t\tselectionSectionName &&\r\n\t\t\t\tselectionSectionName !== sectionName\r\n\t\t\t) {\r\n\t\t\t\treturn [ sectionName, section ];\r\n\t\t\t}\r\n\r\n\t\t\treturn [\r\n\t\t\t\tsectionName,\r\n\t\t\t\tsection.map( ( row, rowIndex ) => {\r\n\t\t\t\t\tif ( selectionRowIndex && selectionRowIndex !== rowIndex ) {\r\n\t\t\t\t\t\treturn row;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcells: row.cells.map(\r\n\t\t\t\t\t\t\t( cellAttributes, columnIndex ) => {\r\n\t\t\t\t\t\t\t\tconst cellLocation = {\r\n\t\t\t\t\t\t\t\t\tsectionName,\r\n\t\t\t\t\t\t\t\t\tcolumnIndex,\r\n\t\t\t\t\t\t\t\t\trowIndex,\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t! isCellSelected( cellLocation, selection )\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\treturn cellAttributes;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treturn updateCell( cellAttributes );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t};\r\n\t\t\t\t} ),\r\n\t\t\t];\r\n\t\t} )\r\n\t);\r\n}\r\n\r\n/**\r\n * Returns whether the cell at `cellLocation` is included in the selection `selection`.\r\n *\r\n * @param {Object} cellLocation An object containing cell location properties.\r\n * @param {Object} selection    An object containing selection properties.\r\n *\r\n * @return {boolean} True if the cell is selected, false otherwise.\r\n */\r\nexport function isCellSelected( cellLocation, selection ) {\r\n\tif ( ! cellLocation || ! selection ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tswitch ( selection.type ) {\r\n\t\tcase 'column':\r\n\t\t\treturn (\r\n\t\t\t\tselection.type === 'column' &&\r\n\t\t\t\tcellLocation.columnIndex === selection.columnIndex\r\n\t\t\t);\r\n\t\tcase 'cell':\r\n\t\t\treturn (\r\n\t\t\t\tselection.type === 'cell' &&\r\n\t\t\t\tcellLocation.sectionName === selection.sectionName &&\r\n\t\t\t\tcellLocation.columnIndex === selection.columnIndex &&\r\n\t\t\t\tcellLocation.rowIndex === selection.rowIndex\r\n\t\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Inserts a row in the table state.\r\n *\r\n * @param {Object} state               Current table state.\r\n * @param {Object} options\r\n * @param {string} options.sectionName Section in which to insert the row.\r\n * @param {number} options.rowIndex    Row index at which to insert the row.\r\n * @param {number} options.columnCount Column count for the table to create.\r\n *\r\n * @return {Object} New table state.\r\n */\r\nexport function insertRow( state, { sectionName, rowIndex, columnCount } ) {\r\n\tconst firstRow = getFirstRow( state );\r\n\tconst cellCount =\r\n\t\tcolumnCount === undefined ? firstRow?.cells?.length : columnCount;\r\n\r\n\t// Bail early if the function cannot determine how many cells to add.\r\n\tif ( ! cellCount ) {\r\n\t\treturn state;\r\n\t}\r\n\r\n\treturn {\r\n\t\t[ sectionName ]: [\r\n\t\t\t...state[ sectionName ].slice( 0, rowIndex ),\r\n\t\t\t{\r\n\t\t\t\tcells: Array.from( { length: cellCount } ).map(\r\n\t\t\t\t\t( _, index ) => {\r\n\t\t\t\t\t\tconst firstCellInColumn =\r\n\t\t\t\t\t\t\tfirstRow?.cells?.[ index ] ?? {};\r\n\r\n\t\t\t\t\t\tconst inheritedAttributes = Object.fromEntries(\r\n\t\t\t\t\t\t\tObject.entries( firstCellInColumn ).filter(\r\n\t\t\t\t\t\t\t\t( [ key ] ) =>\r\n\t\t\t\t\t\t\t\t\tINHERITED_COLUMN_ATTRIBUTES.includes( key )\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t...inheritedAttributes,\r\n\t\t\t\t\t\t\tcontent: '',\r\n\t\t\t\t\t\t\ttag: sectionName === 'head' ? 'th' : 'td',\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t),\r\n\t\t\t},\r\n\t\t\t...state[ sectionName ].slice( rowIndex ),\r\n\t\t],\r\n\t};\r\n}\r\n\r\n/**\r\n * Deletes a row from the table state.\r\n *\r\n * @param {Object} state               Current table state.\r\n * @param {Object} options\r\n * @param {string} options.sectionName Section in which to delete the row.\r\n * @param {number} options.rowIndex    Row index to delete.\r\n *\r\n * @return {Object} New table state.\r\n */\r\nexport function deleteRow( state, { sectionName, rowIndex } ) {\r\n\treturn {\r\n\t\t[ sectionName ]: state[ sectionName ].filter(\r\n\t\t\t( row, index ) => index !== rowIndex\r\n\t\t),\r\n\t};\r\n}\r\n\r\n/**\r\n * Inserts a column in the table state.\r\n *\r\n * @param {Object} state               Current table state.\r\n * @param {Object} options\r\n * @param {number} options.columnIndex Column index at which to insert the column.\r\n *\r\n * @return {Object} New table state.\r\n */\r\nexport function insertColumn( state, { columnIndex } ) {\r\n\tconst tableSections = Object.fromEntries(\r\n\t\tObject.entries( state ).filter( ( [ key ] ) =>\r\n\t\t\t[ 'head', 'body', 'foot' ].includes( key )\r\n\t\t)\r\n\t);\r\n\r\n\treturn Object.fromEntries(\r\n\t\tObject.entries( tableSections ).map( ( [ sectionName, section ] ) => {\r\n\t\t\t// Bail early if the table section is empty.\r\n\t\t\tif ( isEmptyTableSection( section ) ) {\r\n\t\t\t\treturn [ sectionName, section ];\r\n\t\t\t}\r\n\r\n\t\t\treturn [\r\n\t\t\t\tsectionName,\r\n\t\t\t\tsection.map( ( row ) => {\r\n\t\t\t\t\t// Bail early if the row is empty or it's an attempt to insert past\r\n\t\t\t\t\t// the last possible index of the array.\r\n\t\t\t\t\tif ( isEmptyRow( row ) || row.cells.length < columnIndex ) {\r\n\t\t\t\t\t\treturn row;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcells: [\r\n\t\t\t\t\t\t\t...row.cells.slice( 0, columnIndex ),\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcontent: '',\r\n\t\t\t\t\t\t\t\ttag: sectionName === 'head' ? 'th' : 'td',\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t...row.cells.slice( columnIndex ),\r\n\t\t\t\t\t\t],\r\n\t\t\t\t\t};\r\n\t\t\t\t} ),\r\n\t\t\t];\r\n\t\t} )\r\n\t);\r\n}\r\n\r\n/**\r\n * Deletes a column from the table state.\r\n *\r\n * @param {Object} state               Current table state.\r\n * @param {Object} options\r\n * @param {number} options.columnIndex Column index to delete.\r\n *\r\n * @return {Object} New table state.\r\n */\r\nexport function deleteColumn( state, { columnIndex } ) {\r\n\tconst tableSections = Object.fromEntries(\r\n\t\tObject.entries( state ).filter( ( [ key ] ) =>\r\n\t\t\t[ 'head', 'body', 'foot' ].includes( key )\r\n\t\t)\r\n\t);\r\n\r\n\treturn Object.fromEntries(\r\n\t\tObject.entries( tableSections ).map( ( [ sectionName, section ] ) => {\r\n\t\t\t// Bail early if the table section is empty.\r\n\t\t\tif ( isEmptyTableSection( section ) ) {\r\n\t\t\t\treturn [ sectionName, section ];\r\n\t\t\t}\r\n\r\n\t\t\treturn [\r\n\t\t\t\tsectionName,\r\n\t\t\t\tsection\r\n\t\t\t\t\t.map( ( row ) => ( {\r\n\t\t\t\t\t\tcells:\r\n\t\t\t\t\t\t\trow.cells.length >= columnIndex\r\n\t\t\t\t\t\t\t\t? row.cells.filter(\r\n\t\t\t\t\t\t\t\t\t\t( cell, index ) => index !== columnIndex\r\n\t\t\t\t\t\t\t\t  )\r\n\t\t\t\t\t\t\t\t: row.cells,\r\n\t\t\t\t\t} ) )\r\n\t\t\t\t\t.filter( ( row ) => row.cells.length ),\r\n\t\t\t];\r\n\t\t} )\r\n\t);\r\n}\r\n\r\n/**\r\n * Toggles the existence of a section.\r\n *\r\n * @param {Object} state       Current table state.\r\n * @param {string} sectionName Name of the section to toggle.\r\n *\r\n * @return {Object} New table state.\r\n */\r\nexport function toggleSection( state, sectionName ) {\r\n\t// Section exists, replace it with an empty row to remove it.\r\n\tif ( ! isEmptyTableSection( state[ sectionName ] ) ) {\r\n\t\treturn { [ sectionName ]: [] };\r\n\t}\r\n\r\n\t// Get the length of the first row of the body to use when creating the header.\r\n\tconst columnCount = state.body?.[ 0 ]?.cells?.length ?? 1;\r\n\r\n\t// Section doesn't exist, insert an empty row to create the section.\r\n\treturn insertRow( state, { sectionName, rowIndex: 0, columnCount } );\r\n}\r\n\r\n/**\r\n * Determines whether a table section is empty.\r\n *\r\n * @param {Object} section Table section state.\r\n *\r\n * @return {boolean} True if the table section is empty, false otherwise.\r\n */\r\nexport function isEmptyTableSection( section ) {\r\n\treturn ! section || ! section.length || section.every( isEmptyRow );\r\n}\r\n\r\n/**\r\n * Determines whether a table row is empty.\r\n *\r\n * @param {Object} row Table row state.\r\n *\r\n * @return {boolean} True if the table section is empty, false otherwise.\r\n */\r\nexport function isEmptyRow( row ) {\r\n\treturn ! ( row.cells && row.cells.length );\r\n}\r\n"],"mappings":"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","ignoreList":[]}