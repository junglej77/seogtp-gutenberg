{"version":3,"names":["getBlockType","getTransformedMetadata","metadata","newBlockName","bindingsCallback","supports","BLOCK_BINDINGS_SUPPORTED_BLOCKS","transformSupportedProps","includes","push","renaming","length","newMetadata","Object","entries","reduce","obj","prop","value","keys","undefined"],"sources":["@wordpress/block-library/src/utils/get-transformed-metadata.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { getBlockType } from '@wordpress/blocks';\r\n\r\n/**\r\n * Transform the metadata attribute with only the values and bindings specified by each transform.\r\n * Returns `undefined` if the input metadata is falsy.\r\n *\r\n * @param {Object}   metadata         Original metadata attribute from the block that is being transformed.\r\n * @param {Object}   newBlockName     Name of the final block after the transformation.\r\n * @param {Function} bindingsCallback Optional callback to transform the `bindings` property object.\r\n * @return {Object|undefined} New metadata object only with the relevant properties.\r\n */\r\nexport function getTransformedMetadata(\r\n\tmetadata,\r\n\tnewBlockName,\r\n\tbindingsCallback\r\n) {\r\n\tif ( ! metadata ) {\r\n\t\treturn;\r\n\t}\r\n\tconst { supports } = getBlockType( newBlockName );\r\n\t// Fixed until an opt-in mechanism is implemented.\r\n\tconst BLOCK_BINDINGS_SUPPORTED_BLOCKS = [\r\n\t\t'core/paragraph',\r\n\t\t'core/heading',\r\n\t\t'core/image',\r\n\t\t'core/button',\r\n\t];\r\n\t// The metadata properties that should be preserved after the transform.\r\n\tconst transformSupportedProps = [];\r\n\t// If it support bindings, and there is a transform bindings callback, add the `id` and `bindings` properties.\r\n\tif (\r\n\t\tBLOCK_BINDINGS_SUPPORTED_BLOCKS.includes( newBlockName ) &&\r\n\t\tbindingsCallback\r\n\t) {\r\n\t\ttransformSupportedProps.push( 'id', 'bindings' );\r\n\t}\r\n\t// If it support block naming (true by default), add the `name` property.\r\n\tif ( supports.renaming !== false ) {\r\n\t\ttransformSupportedProps.push( 'name' );\r\n\t}\r\n\r\n\t// Return early if no supported properties.\r\n\tif ( ! transformSupportedProps.length ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst newMetadata = Object.entries( metadata ).reduce(\r\n\t\t( obj, [ prop, value ] ) => {\r\n\t\t\t// If prop is not supported, don't add it to the new metadata object.\r\n\t\t\tif ( ! transformSupportedProps.includes( prop ) ) {\r\n\t\t\t\treturn obj;\r\n\t\t\t}\r\n\t\t\tobj[ prop ] =\r\n\t\t\t\tprop === 'bindings' ? bindingsCallback( value ) : value;\r\n\t\t\treturn obj;\r\n\t\t},\r\n\t\t{}\r\n\t);\r\n\r\n\t// Return undefined if object is empty.\r\n\treturn Object.keys( newMetadata ).length ? newMetadata : undefined;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,mBAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sBAAsBA,CACrCC,QAAQ,EACRC,YAAY,EACZC,gBAAgB,EACf;EACD,IAAK,CAAEF,QAAQ,EAAG;IACjB;EACD;EACA,MAAM;IAAEG;EAAS,CAAC,GAAGL,YAAY,CAAEG,YAAa,CAAC;EACjD;EACA,MAAMG,+BAA+B,GAAG,CACvC,gBAAgB,EAChB,cAAc,EACd,YAAY,EACZ,aAAa,CACb;EACD;EACA,MAAMC,uBAAuB,GAAG,EAAE;EAClC;EACA,IACCD,+BAA+B,CAACE,QAAQ,CAAEL,YAAa,CAAC,IACxDC,gBAAgB,EACf;IACDG,uBAAuB,CAACE,IAAI,CAAE,IAAI,EAAE,UAAW,CAAC;EACjD;EACA;EACA,IAAKJ,QAAQ,CAACK,QAAQ,KAAK,KAAK,EAAG;IAClCH,uBAAuB,CAACE,IAAI,CAAE,MAAO,CAAC;EACvC;;EAEA;EACA,IAAK,CAAEF,uBAAuB,CAACI,MAAM,EAAG;IACvC;EACD;EAEA,MAAMC,WAAW,GAAGC,MAAM,CAACC,OAAO,CAAEZ,QAAS,CAAC,CAACa,MAAM,CACpD,CAAEC,GAAG,EAAE,CAAEC,IAAI,EAAEC,KAAK,CAAE,KAAM;IAC3B;IACA,IAAK,CAAEX,uBAAuB,CAACC,QAAQ,CAAES,IAAK,CAAC,EAAG;MACjD,OAAOD,GAAG;IACX;IACAA,GAAG,CAAEC,IAAI,CAAE,GACVA,IAAI,KAAK,UAAU,GAAGb,gBAAgB,CAAEc,KAAM,CAAC,GAAGA,KAAK;IACxD,OAAOF,GAAG;EACX,CAAC,EACD,CAAC,CACF,CAAC;;EAED;EACA,OAAOH,MAAM,CAACM,IAAI,CAAEP,WAAY,CAAC,CAACD,MAAM,GAAGC,WAAW,GAAGQ,SAAS;AACnE","ignoreList":[]}