{"version":3,"names":["v4","uuid","createHooks","applyFilters","getBlockType","getBlockTypes","getGroupingBlockName","normalizeBlockType","__experimentalSanitizeBlockAttributes","createBlock","name","attributes","innerBlocks","sanitizedAttributes","clientId","isValid","createBlocksFromInnerBlocksTemplate","innerBlocksOrTemplate","map","innerBlock","innerBlockTemplate","Array","isArray","__experimentalCloneSanitizedBlock","block","mergeAttributes","newInnerBlocks","cloneBlock","isPossibleTransformForSource","transform","direction","blocks","length","isMultiBlock","firstBlockName","isValidForMultiBlocks","isWildcardBlockTransform","every","isBlockType","type","sourceBlock","hasMatchingName","indexOf","isContainerGroupBlock","blockName","maybeCheckTransformIsMatch","getBlockTypesForPossibleFromTransforms","allBlockTypes","blockTypesWithPossibleFromTransforms","filter","blockType","fromTransforms","getBlockTransforms","findTransform","getBlockTypesForPossibleToTransforms","transformsTo","possibleTransforms","blockNames","transformation","flat","t","includes","getPossibleBlockTransformations","blockTypesForFromTransforms","blockTypesForToTransforms","Set","transforms","predicate","hooks","i","candidate","addFilter","toString","result","priority","blockTypeOrName","undefined","usingMobileTransformations","supportedMobileTransforms","filteredTransforms","transformBlockName","isMatch","switchToBlockType","blocksArray","firstBlock","sourceName","transformationsFrom","transformationsTo","transformationResults","__experimentalConvert","currentBlock","some","hasSwitchedBlock","ret","index","results","getBlockFromExample","example","_example$innerBlocks","originalName","originalContent","originalUndelimitedContent"],"sources":["@wordpress/blocks/src/api/factory.js"],"sourcesContent":["/**\r\n * External dependencies\r\n */\r\nimport { v4 as uuid } from 'uuid';\r\n\r\n/**\r\n * WordPress dependencies\r\n */\r\nimport { createHooks, applyFilters } from '@wordpress/hooks';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport {\r\n\tgetBlockType,\r\n\tgetBlockTypes,\r\n\tgetGroupingBlockName,\r\n} from './registration';\r\nimport {\r\n\tnormalizeBlockType,\r\n\t__experimentalSanitizeBlockAttributes,\r\n} from './utils';\r\n\r\n/**\r\n * Returns a block object given its type and attributes.\r\n *\r\n * @param {string} name        Block name.\r\n * @param {Object} attributes  Block attributes.\r\n * @param {?Array} innerBlocks Nested blocks.\r\n *\r\n * @return {Object} Block object.\r\n */\r\nexport function createBlock( name, attributes = {}, innerBlocks = [] ) {\r\n\tconst sanitizedAttributes = __experimentalSanitizeBlockAttributes(\r\n\t\tname,\r\n\t\tattributes\r\n\t);\r\n\r\n\tconst clientId = uuid();\r\n\r\n\t// Blocks are stored with a unique ID, the assigned type name, the block\r\n\t// attributes, and their inner blocks.\r\n\treturn {\r\n\t\tclientId,\r\n\t\tname,\r\n\t\tisValid: true,\r\n\t\tattributes: sanitizedAttributes,\r\n\t\tinnerBlocks,\r\n\t};\r\n}\r\n\r\n/**\r\n * Given an array of InnerBlocks templates or Block Objects,\r\n * returns an array of created Blocks from them.\r\n * It handles the case of having InnerBlocks as Blocks by\r\n * converting them to the proper format to continue recursively.\r\n *\r\n * @param {Array} innerBlocksOrTemplate Nested blocks or InnerBlocks templates.\r\n *\r\n * @return {Object[]} Array of Block objects.\r\n */\r\nexport function createBlocksFromInnerBlocksTemplate(\r\n\tinnerBlocksOrTemplate = []\r\n) {\r\n\treturn innerBlocksOrTemplate.map( ( innerBlock ) => {\r\n\t\tconst innerBlockTemplate = Array.isArray( innerBlock )\r\n\t\t\t? innerBlock\r\n\t\t\t: [\r\n\t\t\t\t\tinnerBlock.name,\r\n\t\t\t\t\tinnerBlock.attributes,\r\n\t\t\t\t\tinnerBlock.innerBlocks,\r\n\t\t\t  ];\r\n\t\tconst [ name, attributes, innerBlocks = [] ] = innerBlockTemplate;\r\n\t\treturn createBlock(\r\n\t\t\tname,\r\n\t\t\tattributes,\r\n\t\t\tcreateBlocksFromInnerBlocksTemplate( innerBlocks )\r\n\t\t);\r\n\t} );\r\n}\r\n\r\n/**\r\n * Given a block object, returns a copy of the block object while sanitizing its attributes,\r\n * optionally merging new attributes and/or replacing its inner blocks.\r\n *\r\n * @param {Object} block           Block instance.\r\n * @param {Object} mergeAttributes Block attributes.\r\n * @param {?Array} newInnerBlocks  Nested blocks.\r\n *\r\n * @return {Object} A cloned block.\r\n */\r\nexport function __experimentalCloneSanitizedBlock(\r\n\tblock,\r\n\tmergeAttributes = {},\r\n\tnewInnerBlocks\r\n) {\r\n\tconst clientId = uuid();\r\n\r\n\tconst sanitizedAttributes = __experimentalSanitizeBlockAttributes(\r\n\t\tblock.name,\r\n\t\t{\r\n\t\t\t...block.attributes,\r\n\t\t\t...mergeAttributes,\r\n\t\t}\r\n\t);\r\n\r\n\treturn {\r\n\t\t...block,\r\n\t\tclientId,\r\n\t\tattributes: sanitizedAttributes,\r\n\t\tinnerBlocks:\r\n\t\t\tnewInnerBlocks ||\r\n\t\t\tblock.innerBlocks.map( ( innerBlock ) =>\r\n\t\t\t\t__experimentalCloneSanitizedBlock( innerBlock )\r\n\t\t\t),\r\n\t};\r\n}\r\n\r\n/**\r\n * Given a block object, returns a copy of the block object,\r\n * optionally merging new attributes and/or replacing its inner blocks.\r\n *\r\n * @param {Object} block           Block instance.\r\n * @param {Object} mergeAttributes Block attributes.\r\n * @param {?Array} newInnerBlocks  Nested blocks.\r\n *\r\n * @return {Object} A cloned block.\r\n */\r\nexport function cloneBlock( block, mergeAttributes = {}, newInnerBlocks ) {\r\n\tconst clientId = uuid();\r\n\r\n\treturn {\r\n\t\t...block,\r\n\t\tclientId,\r\n\t\tattributes: {\r\n\t\t\t...block.attributes,\r\n\t\t\t...mergeAttributes,\r\n\t\t},\r\n\t\tinnerBlocks:\r\n\t\t\tnewInnerBlocks ||\r\n\t\t\tblock.innerBlocks.map( ( innerBlock ) => cloneBlock( innerBlock ) ),\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns a boolean indicating whether a transform is possible based on\r\n * various bits of context.\r\n *\r\n * @param {Object} transform The transform object to validate.\r\n * @param {string} direction Is this a 'from' or 'to' transform.\r\n * @param {Array}  blocks    The blocks to transform from.\r\n *\r\n * @return {boolean} Is the transform possible?\r\n */\r\nconst isPossibleTransformForSource = ( transform, direction, blocks ) => {\r\n\tif ( ! blocks.length ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// If multiple blocks are selected, only multi block transforms\r\n\t// or wildcard transforms are allowed.\r\n\tconst isMultiBlock = blocks.length > 1;\r\n\tconst firstBlockName = blocks[ 0 ].name;\r\n\tconst isValidForMultiBlocks =\r\n\t\tisWildcardBlockTransform( transform ) ||\r\n\t\t! isMultiBlock ||\r\n\t\ttransform.isMultiBlock;\r\n\tif ( ! isValidForMultiBlocks ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Check non-wildcard transforms to ensure that transform is valid\r\n\t// for a block selection of multiple blocks of different types.\r\n\tif (\r\n\t\t! isWildcardBlockTransform( transform ) &&\r\n\t\t! blocks.every( ( block ) => block.name === firstBlockName )\r\n\t) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Only consider 'block' type transforms as valid.\r\n\tconst isBlockType = transform.type === 'block';\r\n\tif ( ! isBlockType ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Check if the transform's block name matches the source block (or is a wildcard)\r\n\t// only if this is a transform 'from'.\r\n\tconst sourceBlock = blocks[ 0 ];\r\n\tconst hasMatchingName =\r\n\t\tdirection !== 'from' ||\r\n\t\ttransform.blocks.indexOf( sourceBlock.name ) !== -1 ||\r\n\t\tisWildcardBlockTransform( transform );\r\n\tif ( ! hasMatchingName ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Don't allow single Grouping blocks to be transformed into\r\n\t// a Grouping block.\r\n\tif (\r\n\t\t! isMultiBlock &&\r\n\t\tdirection === 'from' &&\r\n\t\tisContainerGroupBlock( sourceBlock.name ) &&\r\n\t\tisContainerGroupBlock( transform.blockName )\r\n\t) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// If the transform has a `isMatch` function specified, check that it returns true.\r\n\tif ( ! maybeCheckTransformIsMatch( transform, blocks ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\n/**\r\n * Returns block types that the 'blocks' can be transformed into, based on\r\n * 'from' transforms on other blocks.\r\n *\r\n * @param {Array} blocks The blocks to transform from.\r\n *\r\n * @return {Array} Block types that the blocks can be transformed into.\r\n */\r\nconst getBlockTypesForPossibleFromTransforms = ( blocks ) => {\r\n\tif ( ! blocks.length ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tconst allBlockTypes = getBlockTypes();\r\n\r\n\t// filter all blocks to find those with a 'from' transform.\r\n\tconst blockTypesWithPossibleFromTransforms = allBlockTypes.filter(\r\n\t\t( blockType ) => {\r\n\t\t\tconst fromTransforms = getBlockTransforms( 'from', blockType.name );\r\n\t\t\treturn !! findTransform( fromTransforms, ( transform ) => {\r\n\t\t\t\treturn isPossibleTransformForSource(\r\n\t\t\t\t\ttransform,\r\n\t\t\t\t\t'from',\r\n\t\t\t\t\tblocks\r\n\t\t\t\t);\r\n\t\t\t} );\r\n\t\t}\r\n\t);\r\n\r\n\treturn blockTypesWithPossibleFromTransforms;\r\n};\r\n\r\n/**\r\n * Returns block types that the 'blocks' can be transformed into, based on\r\n * the source block's own 'to' transforms.\r\n *\r\n * @param {Array} blocks The blocks to transform from.\r\n *\r\n * @return {Array} Block types that the source can be transformed into.\r\n */\r\nconst getBlockTypesForPossibleToTransforms = ( blocks ) => {\r\n\tif ( ! blocks.length ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tconst sourceBlock = blocks[ 0 ];\r\n\tconst blockType = getBlockType( sourceBlock.name );\r\n\tconst transformsTo = blockType\r\n\t\t? getBlockTransforms( 'to', blockType.name )\r\n\t\t: [];\r\n\r\n\t// filter all 'to' transforms to find those that are possible.\r\n\tconst possibleTransforms = transformsTo.filter( ( transform ) => {\r\n\t\treturn (\r\n\t\t\ttransform && isPossibleTransformForSource( transform, 'to', blocks )\r\n\t\t);\r\n\t} );\r\n\r\n\t// Build a list of block names using the possible 'to' transforms.\r\n\tconst blockNames = possibleTransforms\r\n\t\t.map( ( transformation ) => transformation.blocks )\r\n\t\t.flat();\r\n\r\n\t// Map block names to block types.\r\n\treturn blockNames.map( getBlockType );\r\n};\r\n\r\n/**\r\n * Determines whether transform is a \"block\" type\r\n * and if so whether it is a \"wildcard\" transform\r\n * ie: targets \"any\" block type\r\n *\r\n * @param {Object} t the Block transform object\r\n *\r\n * @return {boolean} whether transform is a wildcard transform\r\n */\r\nexport const isWildcardBlockTransform = ( t ) =>\r\n\tt &&\r\n\tt.type === 'block' &&\r\n\tArray.isArray( t.blocks ) &&\r\n\tt.blocks.includes( '*' );\r\n\r\n/**\r\n * Determines whether the given Block is the core Block which\r\n * acts as a container Block for other Blocks as part of the\r\n * Grouping mechanics\r\n *\r\n * @param {string} name the name of the Block to test against\r\n *\r\n * @return {boolean} whether or not the Block is the container Block type\r\n */\r\nexport const isContainerGroupBlock = ( name ) =>\r\n\tname === getGroupingBlockName();\r\n\r\n/**\r\n * Returns an array of block types that the set of blocks received as argument\r\n * can be transformed into.\r\n *\r\n * @param {Array} blocks Blocks array.\r\n *\r\n * @return {Array} Block types that the blocks argument can be transformed to.\r\n */\r\nexport function getPossibleBlockTransformations( blocks ) {\r\n\tif ( ! blocks.length ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tconst blockTypesForFromTransforms =\r\n\t\tgetBlockTypesForPossibleFromTransforms( blocks );\r\n\tconst blockTypesForToTransforms =\r\n\t\tgetBlockTypesForPossibleToTransforms( blocks );\r\n\r\n\treturn [\r\n\t\t...new Set( [\r\n\t\t\t...blockTypesForFromTransforms,\r\n\t\t\t...blockTypesForToTransforms,\r\n\t\t] ),\r\n\t];\r\n}\r\n\r\n/**\r\n * Given an array of transforms, returns the highest-priority transform where\r\n * the predicate function returns a truthy value. A higher-priority transform\r\n * is one with a lower priority value (i.e. first in priority order). Returns\r\n * null if the transforms set is empty or the predicate function returns a\r\n * falsey value for all entries.\r\n *\r\n * @param {Object[]} transforms Transforms to search.\r\n * @param {Function} predicate  Function returning true on matching transform.\r\n *\r\n * @return {?Object} Highest-priority transform candidate.\r\n */\r\nexport function findTransform( transforms, predicate ) {\r\n\t// The hooks library already has built-in mechanisms for managing priority\r\n\t// queue, so leverage via locally-defined instance.\r\n\tconst hooks = createHooks();\r\n\r\n\tfor ( let i = 0; i < transforms.length; i++ ) {\r\n\t\tconst candidate = transforms[ i ];\r\n\t\tif ( predicate( candidate ) ) {\r\n\t\t\thooks.addFilter(\r\n\t\t\t\t'transform',\r\n\t\t\t\t'transform/' + i.toString(),\r\n\t\t\t\t( result ) => ( result ? result : candidate ),\r\n\t\t\t\tcandidate.priority\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Filter name is arbitrarily chosen but consistent with above aggregation.\r\n\treturn hooks.applyFilters( 'transform', null );\r\n}\r\n\r\n/**\r\n * Returns normal block transforms for a given transform direction, optionally\r\n * for a specific block by name, or an empty array if there are no transforms.\r\n * If no block name is provided, returns transforms for all blocks. A normal\r\n * transform object includes `blockName` as a property.\r\n *\r\n * @param {string}        direction       Transform direction (\"to\", \"from\").\r\n * @param {string|Object} blockTypeOrName Block type or name.\r\n *\r\n * @return {Array} Block transforms for direction.\r\n */\r\nexport function getBlockTransforms( direction, blockTypeOrName ) {\r\n\t// When retrieving transforms for all block types, recurse into self.\r\n\tif ( blockTypeOrName === undefined ) {\r\n\t\treturn getBlockTypes()\r\n\t\t\t.map( ( { name } ) => getBlockTransforms( direction, name ) )\r\n\t\t\t.flat();\r\n\t}\r\n\r\n\t// Validate that block type exists and has array of direction.\r\n\tconst blockType = normalizeBlockType( blockTypeOrName );\r\n\tconst { name: blockName, transforms } = blockType || {};\r\n\tif ( ! transforms || ! Array.isArray( transforms[ direction ] ) ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tconst usingMobileTransformations =\r\n\t\ttransforms.supportedMobileTransforms &&\r\n\t\tArray.isArray( transforms.supportedMobileTransforms );\r\n\tconst filteredTransforms = usingMobileTransformations\r\n\t\t? transforms[ direction ].filter( ( t ) => {\r\n\t\t\t\tif ( t.type === 'raw' ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( t.type === 'prefix' ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! t.blocks || ! t.blocks.length ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isWildcardBlockTransform( t ) ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn t.blocks.every( ( transformBlockName ) =>\r\n\t\t\t\t\ttransforms.supportedMobileTransforms.includes(\r\n\t\t\t\t\t\ttransformBlockName\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t  } )\r\n\t\t: transforms[ direction ];\r\n\r\n\t// Map transforms to normal form.\r\n\treturn filteredTransforms.map( ( transform ) => ( {\r\n\t\t...transform,\r\n\t\tblockName,\r\n\t\tusingMobileTransformations,\r\n\t} ) );\r\n}\r\n\r\n/**\r\n * Checks that a given transforms isMatch method passes for given source blocks.\r\n *\r\n * @param {Object} transform A transform object.\r\n * @param {Array}  blocks    Blocks array.\r\n *\r\n * @return {boolean} True if given blocks are a match for the transform.\r\n */\r\nfunction maybeCheckTransformIsMatch( transform, blocks ) {\r\n\tif ( typeof transform.isMatch !== 'function' ) {\r\n\t\treturn true;\r\n\t}\r\n\tconst sourceBlock = blocks[ 0 ];\r\n\tconst attributes = transform.isMultiBlock\r\n\t\t? blocks.map( ( block ) => block.attributes )\r\n\t\t: sourceBlock.attributes;\r\n\tconst block = transform.isMultiBlock ? blocks : sourceBlock;\r\n\r\n\treturn transform.isMatch( attributes, block );\r\n}\r\n\r\n/**\r\n * Switch one or more blocks into one or more blocks of the new block type.\r\n *\r\n * @param {Array|Object} blocks Blocks array or block object.\r\n * @param {string}       name   Block name.\r\n *\r\n * @return {?Array} Array of blocks or null.\r\n */\r\nexport function switchToBlockType( blocks, name ) {\r\n\tconst blocksArray = Array.isArray( blocks ) ? blocks : [ blocks ];\r\n\tconst isMultiBlock = blocksArray.length > 1;\r\n\tconst firstBlock = blocksArray[ 0 ];\r\n\tconst sourceName = firstBlock.name;\r\n\r\n\t// Find the right transformation by giving priority to the \"to\"\r\n\t// transformation.\r\n\tconst transformationsFrom = getBlockTransforms( 'from', name );\r\n\tconst transformationsTo = getBlockTransforms( 'to', sourceName );\r\n\r\n\tconst transformation =\r\n\t\tfindTransform(\r\n\t\t\ttransformationsTo,\r\n\t\t\t( t ) =>\r\n\t\t\t\tt.type === 'block' &&\r\n\t\t\t\t( isWildcardBlockTransform( t ) ||\r\n\t\t\t\t\tt.blocks.indexOf( name ) !== -1 ) &&\r\n\t\t\t\t( ! isMultiBlock || t.isMultiBlock ) &&\r\n\t\t\t\tmaybeCheckTransformIsMatch( t, blocksArray )\r\n\t\t) ||\r\n\t\tfindTransform(\r\n\t\t\ttransformationsFrom,\r\n\t\t\t( t ) =>\r\n\t\t\t\tt.type === 'block' &&\r\n\t\t\t\t( isWildcardBlockTransform( t ) ||\r\n\t\t\t\t\tt.blocks.indexOf( sourceName ) !== -1 ) &&\r\n\t\t\t\t( ! isMultiBlock || t.isMultiBlock ) &&\r\n\t\t\t\tmaybeCheckTransformIsMatch( t, blocksArray )\r\n\t\t);\r\n\r\n\t// Stop if there is no valid transformation.\r\n\tif ( ! transformation ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet transformationResults;\r\n\r\n\tif ( transformation.isMultiBlock ) {\r\n\t\tif ( '__experimentalConvert' in transformation ) {\r\n\t\t\ttransformationResults =\r\n\t\t\t\ttransformation.__experimentalConvert( blocksArray );\r\n\t\t} else {\r\n\t\t\ttransformationResults = transformation.transform(\r\n\t\t\t\tblocksArray.map( ( currentBlock ) => currentBlock.attributes ),\r\n\t\t\t\tblocksArray.map( ( currentBlock ) => currentBlock.innerBlocks )\r\n\t\t\t);\r\n\t\t}\r\n\t} else if ( '__experimentalConvert' in transformation ) {\r\n\t\ttransformationResults =\r\n\t\t\ttransformation.__experimentalConvert( firstBlock );\r\n\t} else {\r\n\t\ttransformationResults = transformation.transform(\r\n\t\t\tfirstBlock.attributes,\r\n\t\t\tfirstBlock.innerBlocks\r\n\t\t);\r\n\t}\r\n\r\n\t// Ensure that the transformation function returned an object or an array\r\n\t// of objects.\r\n\tif (\r\n\t\ttransformationResults === null ||\r\n\t\ttypeof transformationResults !== 'object'\r\n\t) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// If the transformation function returned a single object, we want to work\r\n\t// with an array instead.\r\n\ttransformationResults = Array.isArray( transformationResults )\r\n\t\t? transformationResults\r\n\t\t: [ transformationResults ];\r\n\r\n\t// Ensure that every block object returned by the transformation has a\r\n\t// valid block type.\r\n\tif (\r\n\t\ttransformationResults.some(\r\n\t\t\t( result ) => ! getBlockType( result.name )\r\n\t\t)\r\n\t) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst hasSwitchedBlock = transformationResults.some(\r\n\t\t( result ) => result.name === name\r\n\t);\r\n\r\n\t// Ensure that at least one block object returned by the transformation has\r\n\t// the expected \"destination\" block type.\r\n\tif ( ! hasSwitchedBlock ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst ret = transformationResults.map( ( result, index, results ) => {\r\n\t\t/**\r\n\t\t * Filters an individual transform result from block transformation.\r\n\t\t * All of the original blocks are passed, since transformations are\r\n\t\t * many-to-many, not one-to-one.\r\n\t\t *\r\n\t\t * @param {Object}   transformedBlock The transformed block.\r\n\t\t * @param {Object[]} blocks           Original blocks transformed.\r\n\t\t * @param {Object[]} index            Index of the transformed block on the array of results.\r\n\t\t * @param {Object[]} results          An array all the blocks that resulted from the transformation.\r\n\t\t */\r\n\t\treturn applyFilters(\r\n\t\t\t'blocks.switchToBlockType.transformedBlock',\r\n\t\t\tresult,\r\n\t\t\tblocks,\r\n\t\t\tindex,\r\n\t\t\tresults\r\n\t\t);\r\n\t} );\r\n\r\n\treturn ret;\r\n}\r\n\r\n/**\r\n * Create a block object from the example API.\r\n *\r\n * @param {string} name\r\n * @param {Object} example\r\n *\r\n * @return {Object} block.\r\n */\r\nexport const getBlockFromExample = ( name, example ) => {\r\n\ttry {\r\n\t\treturn createBlock(\r\n\t\t\tname,\r\n\t\t\texample.attributes,\r\n\t\t\t( example.innerBlocks ?? [] ).map( ( innerBlock ) =>\r\n\t\t\t\tgetBlockFromExample( innerBlock.name, innerBlock )\r\n\t\t\t)\r\n\t\t);\r\n\t} catch {\r\n\t\treturn createBlock( 'core/missing', {\r\n\t\t\toriginalName: name,\r\n\t\t\toriginalContent: '',\r\n\t\t\toriginalUndelimitedContent: '',\r\n\t\t} );\r\n\t}\r\n};\r\n"],"mappings":"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","ignoreList":[]}