{"version":3,"names":["isPhrasingContent","getPhrasingContentSchema","hasBlockSupport","getRawTransforms","getBlockContentSchemaFromTransforms","transforms","context","phrasingContentSchema","schemaArgs","isPaste","schemas","map","isMatch","blockName","schema","hasAnchorSupport","Object","fromEntries","entries","key","value","attributes","undefined","mergeTagNameSchemaProperties","objValue","srcValue","args","mergeTagNameSchemas","a","b","mergeSchemas","reduce","getBlockContentSchema","isPlain","HTML","test","deepFilterNodeList","nodeList","filters","doc","Array","from","forEach","node","childNodes","item","contains","deepFilterHTML","document","implementation","createHTMLDocument","body","innerHTML","getSibling","which","sibling","parentNode"],"sources":["@wordpress/blocks/src/api/raw-handling/utils.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { isPhrasingContent, getPhrasingContentSchema } from '@wordpress/dom';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport { hasBlockSupport } from '..';\r\nimport { getRawTransforms } from './get-raw-transforms';\r\n\r\nexport function getBlockContentSchemaFromTransforms( transforms, context ) {\r\n\tconst phrasingContentSchema = getPhrasingContentSchema( context );\r\n\tconst schemaArgs = { phrasingContentSchema, isPaste: context === 'paste' };\r\n\tconst schemas = transforms.map( ( { isMatch, blockName, schema } ) => {\r\n\t\tconst hasAnchorSupport = hasBlockSupport( blockName, 'anchor' );\r\n\r\n\t\tschema = typeof schema === 'function' ? schema( schemaArgs ) : schema;\r\n\r\n\t\t// If the block does not has anchor support and the transform does not\r\n\t\t// provides an isMatch we can return the schema right away.\r\n\t\tif ( ! hasAnchorSupport && ! isMatch ) {\r\n\t\t\treturn schema;\r\n\t\t}\r\n\r\n\t\tif ( ! schema ) {\r\n\t\t\treturn {};\r\n\t\t}\r\n\r\n\t\treturn Object.fromEntries(\r\n\t\t\tObject.entries( schema ).map( ( [ key, value ] ) => {\r\n\t\t\t\tlet attributes = value.attributes || [];\r\n\t\t\t\t// If the block supports the \"anchor\" functionality, it needs to keep its ID attribute.\r\n\t\t\t\tif ( hasAnchorSupport ) {\r\n\t\t\t\t\tattributes = [ ...attributes, 'id' ];\r\n\t\t\t\t}\r\n\t\t\t\treturn [\r\n\t\t\t\t\tkey,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t...value,\r\n\t\t\t\t\t\tattributes,\r\n\t\t\t\t\t\tisMatch: isMatch ? isMatch : undefined,\r\n\t\t\t\t\t},\r\n\t\t\t\t];\r\n\t\t\t} )\r\n\t\t);\r\n\t} );\r\n\r\n\tfunction mergeTagNameSchemaProperties( objValue, srcValue, key ) {\r\n\t\tswitch ( key ) {\r\n\t\t\tcase 'children': {\r\n\t\t\t\tif ( objValue === '*' || srcValue === '*' ) {\r\n\t\t\t\t\treturn '*';\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { ...objValue, ...srcValue };\r\n\t\t\t}\r\n\t\t\tcase 'attributes':\r\n\t\t\tcase 'require': {\r\n\t\t\t\treturn [ ...( objValue || [] ), ...( srcValue || [] ) ];\r\n\t\t\t}\r\n\t\t\tcase 'isMatch': {\r\n\t\t\t\t// If one of the values being merge is undefined (matches everything),\r\n\t\t\t\t// the result of the merge will be undefined.\r\n\t\t\t\tif ( ! objValue || ! srcValue ) {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\t\t\t\t// When merging two isMatch functions, the result is a new function\r\n\t\t\t\t// that returns if one of the source functions returns true.\r\n\t\t\t\treturn ( ...args ) => {\r\n\t\t\t\t\treturn objValue( ...args ) || srcValue( ...args );\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// A tagName schema is an object with children, attributes, require, and\r\n\t// isMatch properties.\r\n\tfunction mergeTagNameSchemas( a, b ) {\r\n\t\tfor ( const key in b ) {\r\n\t\t\ta[ key ] = a[ key ]\r\n\t\t\t\t? mergeTagNameSchemaProperties( a[ key ], b[ key ], key )\r\n\t\t\t\t: { ...b[ key ] };\r\n\t\t}\r\n\t\treturn a;\r\n\t}\r\n\r\n\t// A schema is an object with tagName schemas by tag name.\r\n\tfunction mergeSchemas( a, b ) {\r\n\t\tfor ( const key in b ) {\r\n\t\t\ta[ key ] = a[ key ]\r\n\t\t\t\t? mergeTagNameSchemas( a[ key ], b[ key ] )\r\n\t\t\t\t: { ...b[ key ] };\r\n\t\t}\r\n\t\treturn a;\r\n\t}\r\n\r\n\treturn schemas.reduce( mergeSchemas, {} );\r\n}\r\n\r\n/**\r\n * Gets the block content schema, which is extracted and merged from all\r\n * registered blocks with raw transfroms.\r\n *\r\n * @param {string} context Set to \"paste\" when in paste context, where the\r\n *                         schema is more strict.\r\n *\r\n * @return {Object} A complete block content schema.\r\n */\r\nexport function getBlockContentSchema( context ) {\r\n\treturn getBlockContentSchemaFromTransforms( getRawTransforms(), context );\r\n}\r\n\r\n/**\r\n * Checks whether HTML can be considered plain text. That is, it does not contain\r\n * any elements that are not line breaks.\r\n *\r\n * @param {string} HTML The HTML to check.\r\n *\r\n * @return {boolean} Whether the HTML can be considered plain text.\r\n */\r\nexport function isPlain( HTML ) {\r\n\treturn ! /<(?!br[ />])/i.test( HTML );\r\n}\r\n\r\n/**\r\n * Given node filters, deeply filters and mutates a NodeList.\r\n *\r\n * @param {NodeList} nodeList The nodeList to filter.\r\n * @param {Array}    filters  An array of functions that can mutate with the provided node.\r\n * @param {Document} doc      The document of the nodeList.\r\n * @param {Object}   schema   The schema to use.\r\n */\r\nexport function deepFilterNodeList( nodeList, filters, doc, schema ) {\r\n\tArray.from( nodeList ).forEach( ( node ) => {\r\n\t\tdeepFilterNodeList( node.childNodes, filters, doc, schema );\r\n\r\n\t\tfilters.forEach( ( item ) => {\r\n\t\t\t// Make sure the node is still attached to the document.\r\n\t\t\tif ( ! doc.contains( node ) ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\titem( node, doc, schema );\r\n\t\t} );\r\n\t} );\r\n}\r\n\r\n/**\r\n * Given node filters, deeply filters HTML tags.\r\n * Filters from the deepest nodes to the top.\r\n *\r\n * @param {string} HTML    The HTML to filter.\r\n * @param {Array}  filters An array of functions that can mutate with the provided node.\r\n * @param {Object} schema  The schema to use.\r\n *\r\n * @return {string} The filtered HTML.\r\n */\r\nexport function deepFilterHTML( HTML, filters = [], schema ) {\r\n\tconst doc = document.implementation.createHTMLDocument( '' );\r\n\r\n\tdoc.body.innerHTML = HTML;\r\n\r\n\tdeepFilterNodeList( doc.body.childNodes, filters, doc, schema );\r\n\r\n\treturn doc.body.innerHTML;\r\n}\r\n\r\n/**\r\n * Gets a sibling within text-level context.\r\n *\r\n * @param {Element} node  The subject node.\r\n * @param {string}  which \"next\" or \"previous\".\r\n */\r\nexport function getSibling( node, which ) {\r\n\tconst sibling = node[ `${ which }Sibling` ];\r\n\r\n\tif ( sibling && isPhrasingContent( sibling ) ) {\r\n\t\treturn sibling;\r\n\t}\r\n\r\n\tconst { parentNode } = node;\r\n\r\n\tif ( ! parentNode || ! isPhrasingContent( parentNode ) ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\treturn getSibling( parentNode, which );\r\n}\r\n"],"mappings":"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","ignoreList":[]}