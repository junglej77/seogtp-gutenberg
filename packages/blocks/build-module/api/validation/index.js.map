{"version":3,"names":["Tokenizer","fastDeepEqual","deprecated","decodeEntities","createLogger","createQueuedLogger","getSaveContent","getFreeformContentHandlerName","getUnregisteredTypeHandlerName","normalizeBlockType","identity","x","REGEXP_WHITESPACE","REGEXP_ONLY_WHITESPACE","REGEXP_STYLE_URL_TYPE","BOOLEAN_ATTRIBUTES","ENUMERATED_ATTRIBUTES","MEANINGFUL_ATTRIBUTES","TEXT_NORMALIZATIONS","getTextWithCollapsedWhitespace","REGEXP_NAMED_CHARACTER_REFERENCE","REGEXP_DECIMAL_CHARACTER_REFERENCE","REGEXP_HEXADECIMAL_CHARACTER_REFERENCE","isValidCharacterReference","text","test","DecodeEntityParser","parse","entity","getTextPiecesSplitOnWhitespace","trim","split","join","getMeaningfulAttributePairs","token","attributes","filter","pair","key","value","indexOf","includes","isEquivalentTextTokens","actual","expected","logger","actualChars","chars","expectedChars","i","length","normalize","warning","getNormalizedLength","parseFloat","getNormalizedStyleValue","textPieces","normalizedPieces","map","result","replace","getStyleProperties","pairs","style","valueParts","Object","fromEntries","isEqualAttributesOfName","class","actualPieces","expectedPieces","actualDiff","c","expectedDiff","attribute","isEqualTagAttributePairs","expectedAttributes","toLowerCase","name","actualValue","nameLower","hasOwnProperty","expectedValue","isEqualAttributes","isEqualTokensOfType","StartTag","tagName","Chars","Comment","getNextNonWhitespaceToken","tokens","shift","type","getHTMLTokens","html","tokenize","e","isClosedByToken","currentToken","nextToken","selfClosing","isEquivalentHTML","actualTokens","expectedTokens","actualToken","expectedToken","isEqualTokens","validateBlock","block","blockTypeOrName","isFallbackBlock","blockType","generatedBlockContent","error","toString","getItems","isValid","originalContent","isValidBlockContent","originalBlockContent","since","plugin","alternative","innerBlocks"],"sources":["@wordpress/blocks/src/api/validation/index.js"],"sourcesContent":["/**\r\n * External dependencies\r\n */\r\nimport { Tokenizer } from 'simple-html-tokenizer';\r\nimport fastDeepEqual from 'fast-deep-equal/es6';\r\n\r\n/**\r\n * WordPress dependencies\r\n */\r\nimport deprecated from '@wordpress/deprecated';\r\nimport { decodeEntities } from '@wordpress/html-entities';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport { createLogger, createQueuedLogger } from './logger';\r\nimport { getSaveContent } from '../serializer';\r\nimport {\r\n\tgetFreeformContentHandlerName,\r\n\tgetUnregisteredTypeHandlerName,\r\n} from '../registration';\r\nimport { normalizeBlockType } from '../utils';\r\n\r\n/** @typedef {import('../parser').WPBlock} WPBlock */\r\n/** @typedef {import('../registration').WPBlockType} WPBlockType */\r\n/** @typedef {import('./logger').LoggerItem} LoggerItem */\r\n\r\nconst identity = ( x ) => x;\r\n\r\n/**\r\n * Globally matches any consecutive whitespace\r\n *\r\n * @type {RegExp}\r\n */\r\nconst REGEXP_WHITESPACE = /[\\t\\n\\r\\v\\f ]+/g;\r\n\r\n/**\r\n * Matches a string containing only whitespace\r\n *\r\n * @type {RegExp}\r\n */\r\nconst REGEXP_ONLY_WHITESPACE = /^[\\t\\n\\r\\v\\f ]*$/;\r\n\r\n/**\r\n * Matches a CSS URL type value\r\n *\r\n * @type {RegExp}\r\n */\r\nconst REGEXP_STYLE_URL_TYPE = /^url\\s*\\(['\"\\s]*(.*?)['\"\\s]*\\)$/;\r\n\r\n/**\r\n * Boolean attributes are attributes whose presence as being assigned is\r\n * meaningful, even if only empty.\r\n *\r\n * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\r\n * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3\r\n *\r\n * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )\r\n *     .filter( ( tr ) => tr.lastChild.textContent.indexOf( 'Boolean attribute' ) !== -1 )\r\n *     .reduce( ( result, tr ) => Object.assign( result, {\r\n *         [ tr.firstChild.textContent.trim() ]: true\r\n *     } ), {} ) ).sort();\r\n *\r\n * @type {Array}\r\n */\r\nconst BOOLEAN_ATTRIBUTES = [\r\n\t'allowfullscreen',\r\n\t'allowpaymentrequest',\r\n\t'allowusermedia',\r\n\t'async',\r\n\t'autofocus',\r\n\t'autoplay',\r\n\t'checked',\r\n\t'controls',\r\n\t'default',\r\n\t'defer',\r\n\t'disabled',\r\n\t'download',\r\n\t'formnovalidate',\r\n\t'hidden',\r\n\t'ismap',\r\n\t'itemscope',\r\n\t'loop',\r\n\t'multiple',\r\n\t'muted',\r\n\t'nomodule',\r\n\t'novalidate',\r\n\t'open',\r\n\t'playsinline',\r\n\t'readonly',\r\n\t'required',\r\n\t'reversed',\r\n\t'selected',\r\n\t'typemustmatch',\r\n];\r\n\r\n/**\r\n * Enumerated attributes are attributes which must be of a specific value form.\r\n * Like boolean attributes, these are meaningful if specified, even if not of a\r\n * valid enumerated value.\r\n *\r\n * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#enumerated-attribute\r\n * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3\r\n *\r\n * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )\r\n *     .filter( ( tr ) => /^(\"(.+?)\";?\\s*)+/.test( tr.lastChild.textContent.trim() ) )\r\n *     .reduce( ( result, tr ) => Object.assign( result, {\r\n *         [ tr.firstChild.textContent.trim() ]: true\r\n *     } ), {} ) ).sort();\r\n *\r\n * @type {Array}\r\n */\r\nconst ENUMERATED_ATTRIBUTES = [\r\n\t'autocapitalize',\r\n\t'autocomplete',\r\n\t'charset',\r\n\t'contenteditable',\r\n\t'crossorigin',\r\n\t'decoding',\r\n\t'dir',\r\n\t'draggable',\r\n\t'enctype',\r\n\t'formenctype',\r\n\t'formmethod',\r\n\t'http-equiv',\r\n\t'inputmode',\r\n\t'kind',\r\n\t'method',\r\n\t'preload',\r\n\t'scope',\r\n\t'shape',\r\n\t'spellcheck',\r\n\t'translate',\r\n\t'type',\r\n\t'wrap',\r\n];\r\n\r\n/**\r\n * Meaningful attributes are those who cannot be safely ignored when omitted in\r\n * one HTML markup string and not another.\r\n *\r\n * @type {Array}\r\n */\r\nconst MEANINGFUL_ATTRIBUTES = [\r\n\t...BOOLEAN_ATTRIBUTES,\r\n\t...ENUMERATED_ATTRIBUTES,\r\n];\r\n\r\n/**\r\n * Array of functions which receive a text string on which to apply normalizing\r\n * behavior for consideration in text token equivalence, carefully ordered from\r\n * least-to-most expensive operations.\r\n *\r\n * @type {Array}\r\n */\r\nconst TEXT_NORMALIZATIONS = [ identity, getTextWithCollapsedWhitespace ];\r\n\r\n/**\r\n * Regular expression matching a named character reference. In lieu of bundling\r\n * a full set of references, the pattern covers the minimal necessary to test\r\n * positively against the full set.\r\n *\r\n * \"The ampersand must be followed by one of the names given in the named\r\n * character references section, using the same case.\"\r\n *\r\n * Tested aginst \"12.5 Named character references\":\r\n *\r\n * ```\r\n * const references = Array.from( document.querySelectorAll(\r\n *     '#named-character-references-table tr[id^=entity-] td:first-child'\r\n * ) ).map( ( code ) => code.textContent )\r\n * references.every( ( reference ) => /^[\\da-z]+$/i.test( reference ) )\r\n * ```\r\n *\r\n * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references\r\n * @see https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references\r\n *\r\n * @type {RegExp}\r\n */\r\nconst REGEXP_NAMED_CHARACTER_REFERENCE = /^[\\da-z]+$/i;\r\n\r\n/**\r\n * Regular expression matching a decimal character reference.\r\n *\r\n * \"The ampersand must be followed by a U+0023 NUMBER SIGN character (#),\r\n * followed by one or more ASCII digits, representing a base-ten integer\"\r\n *\r\n * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references\r\n *\r\n * @type {RegExp}\r\n */\r\nconst REGEXP_DECIMAL_CHARACTER_REFERENCE = /^#\\d+$/;\r\n\r\n/**\r\n * Regular expression matching a hexadecimal character reference.\r\n *\r\n * \"The ampersand must be followed by a U+0023 NUMBER SIGN character (#), which\r\n * must be followed by either a U+0078 LATIN SMALL LETTER X character (x) or a\r\n * U+0058 LATIN CAPITAL LETTER X character (X), which must then be followed by\r\n * one or more ASCII hex digits, representing a hexadecimal integer\"\r\n *\r\n * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references\r\n *\r\n * @type {RegExp}\r\n */\r\nconst REGEXP_HEXADECIMAL_CHARACTER_REFERENCE = /^#x[\\da-f]+$/i;\r\n\r\n/**\r\n * Returns true if the given string is a valid character reference segment, or\r\n * false otherwise. The text should be stripped of `&` and `;` demarcations.\r\n *\r\n * @param {string} text Text to test.\r\n *\r\n * @return {boolean} Whether text is valid character reference.\r\n */\r\nexport function isValidCharacterReference( text ) {\r\n\treturn (\r\n\t\tREGEXP_NAMED_CHARACTER_REFERENCE.test( text ) ||\r\n\t\tREGEXP_DECIMAL_CHARACTER_REFERENCE.test( text ) ||\r\n\t\tREGEXP_HEXADECIMAL_CHARACTER_REFERENCE.test( text )\r\n\t);\r\n}\r\n\r\n/**\r\n * Subsitute EntityParser class for `simple-html-tokenizer` which uses the\r\n * implementation of `decodeEntities` from `html-entities`, in order to avoid\r\n * bundling a massive named character reference.\r\n *\r\n * @see https://github.com/tildeio/simple-html-tokenizer/tree/HEAD/src/entity-parser.ts\r\n */\r\nexport class DecodeEntityParser {\r\n\t/**\r\n\t * Returns a substitute string for an entity string sequence between `&`\r\n\t * and `;`, or undefined if no substitution should occur.\r\n\t *\r\n\t * @param {string} entity Entity fragment discovered in HTML.\r\n\t *\r\n\t * @return {string | undefined} Entity substitute value.\r\n\t */\r\n\tparse( entity ) {\r\n\t\tif ( isValidCharacterReference( entity ) ) {\r\n\t\t\treturn decodeEntities( '&' + entity + ';' );\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Given a specified string, returns an array of strings split by consecutive\r\n * whitespace, ignoring leading or trailing whitespace.\r\n *\r\n * @param {string} text Original text.\r\n *\r\n * @return {string[]} Text pieces split on whitespace.\r\n */\r\nexport function getTextPiecesSplitOnWhitespace( text ) {\r\n\treturn text.trim().split( REGEXP_WHITESPACE );\r\n}\r\n\r\n/**\r\n * Given a specified string, returns a new trimmed string where all consecutive\r\n * whitespace is collapsed to a single space.\r\n *\r\n * @param {string} text Original text.\r\n *\r\n * @return {string} Trimmed text with consecutive whitespace collapsed.\r\n */\r\nexport function getTextWithCollapsedWhitespace( text ) {\r\n\t// This is an overly simplified whitespace comparison. The specification is\r\n\t// more prescriptive of whitespace behavior in inline and block contexts.\r\n\t//\r\n\t// See: https://medium.com/@patrickbrosset/when-does-white-space-matter-in-html-b90e8a7cdd33\r\n\treturn getTextPiecesSplitOnWhitespace( text ).join( ' ' );\r\n}\r\n\r\n/**\r\n * Returns attribute pairs of the given StartTag token, including only pairs\r\n * where the value is non-empty or the attribute is a boolean attribute, an\r\n * enumerated attribute, or a custom data- attribute.\r\n *\r\n * @see MEANINGFUL_ATTRIBUTES\r\n *\r\n * @param {Object} token StartTag token.\r\n *\r\n * @return {Array[]} Attribute pairs.\r\n */\r\nexport function getMeaningfulAttributePairs( token ) {\r\n\treturn token.attributes.filter( ( pair ) => {\r\n\t\tconst [ key, value ] = pair;\r\n\t\treturn (\r\n\t\t\tvalue ||\r\n\t\t\tkey.indexOf( 'data-' ) === 0 ||\r\n\t\t\tMEANINGFUL_ATTRIBUTES.includes( key )\r\n\t\t);\r\n\t} );\r\n}\r\n\r\n/**\r\n * Returns true if two text tokens (with `chars` property) are equivalent, or\r\n * false otherwise.\r\n *\r\n * @param {Object} actual   Actual token.\r\n * @param {Object} expected Expected token.\r\n * @param {Object} logger   Validation logger object.\r\n *\r\n * @return {boolean} Whether two text tokens are equivalent.\r\n */\r\nexport function isEquivalentTextTokens(\r\n\tactual,\r\n\texpected,\r\n\tlogger = createLogger()\r\n) {\r\n\t// This function is intentionally written as syntactically \"ugly\" as a hot\r\n\t// path optimization. Text is progressively normalized in order from least-\r\n\t// to-most operationally expensive, until the earliest point at which text\r\n\t// can be confidently inferred as being equal.\r\n\tlet actualChars = actual.chars;\r\n\tlet expectedChars = expected.chars;\r\n\r\n\tfor ( let i = 0; i < TEXT_NORMALIZATIONS.length; i++ ) {\r\n\t\tconst normalize = TEXT_NORMALIZATIONS[ i ];\r\n\r\n\t\tactualChars = normalize( actualChars );\r\n\t\texpectedChars = normalize( expectedChars );\r\n\r\n\t\tif ( actualChars === expectedChars ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tlogger.warning(\r\n\t\t'Expected text `%s`, saw `%s`.',\r\n\t\texpected.chars,\r\n\t\tactual.chars\r\n\t);\r\n\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Given a CSS length value, returns a normalized CSS length value for strict equality\r\n * comparison.\r\n *\r\n * @param {string} value CSS length value.\r\n *\r\n * @return {string} Normalized CSS length value.\r\n */\r\nexport function getNormalizedLength( value ) {\r\n\tif ( 0 === parseFloat( value ) ) {\r\n\t\treturn '0';\r\n\t}\r\n\t// Normalize strings with floats to always include a leading zero.\r\n\tif ( value.indexOf( '.' ) === 0 ) {\r\n\t\treturn '0' + value;\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Given a style value, returns a normalized style value for strict equality\r\n * comparison.\r\n *\r\n * @param {string} value Style value.\r\n *\r\n * @return {string} Normalized style value.\r\n */\r\nexport function getNormalizedStyleValue( value ) {\r\n\tconst textPieces = getTextPiecesSplitOnWhitespace( value );\r\n\tconst normalizedPieces = textPieces.map( getNormalizedLength );\r\n\tconst result = normalizedPieces.join( ' ' );\r\n\r\n\treturn (\r\n\t\tresult\r\n\t\t\t// Normalize URL type to omit whitespace or quotes.\r\n\t\t\t.replace( REGEXP_STYLE_URL_TYPE, 'url($1)' )\r\n\t);\r\n}\r\n\r\n/**\r\n * Given a style attribute string, returns an object of style properties.\r\n *\r\n * @param {string} text Style attribute.\r\n *\r\n * @return {Object} Style properties.\r\n */\r\nexport function getStyleProperties( text ) {\r\n\tconst pairs = text\r\n\t\t// Trim ending semicolon (avoid including in split)\r\n\t\t.replace( /;?\\s*$/, '' )\r\n\t\t// Split on property assignment.\r\n\t\t.split( ';' )\r\n\t\t// For each property assignment...\r\n\t\t.map( ( style ) => {\r\n\t\t\t// ...split further into key-value pairs.\r\n\t\t\tconst [ key, ...valueParts ] = style.split( ':' );\r\n\t\t\tconst value = valueParts.join( ':' );\r\n\r\n\t\t\treturn [ key.trim(), getNormalizedStyleValue( value.trim() ) ];\r\n\t\t} );\r\n\r\n\treturn Object.fromEntries( pairs );\r\n}\r\n\r\n/**\r\n * Attribute-specific equality handlers\r\n *\r\n * @type {Object}\r\n */\r\nexport const isEqualAttributesOfName = {\r\n\tclass: ( actual, expected ) => {\r\n\t\t// Class matches if members are the same, even if out of order or\r\n\t\t// superfluous whitespace between.\r\n\t\tconst [ actualPieces, expectedPieces ] = [ actual, expected ].map(\r\n\t\t\tgetTextPiecesSplitOnWhitespace\r\n\t\t);\r\n\t\tconst actualDiff = actualPieces.filter(\r\n\t\t\t( c ) => ! expectedPieces.includes( c )\r\n\t\t);\r\n\t\tconst expectedDiff = expectedPieces.filter(\r\n\t\t\t( c ) => ! actualPieces.includes( c )\r\n\t\t);\r\n\r\n\t\treturn actualDiff.length === 0 && expectedDiff.length === 0;\r\n\t},\r\n\tstyle: ( actual, expected ) => {\r\n\t\treturn fastDeepEqual(\r\n\t\t\t...[ actual, expected ].map( getStyleProperties )\r\n\t\t);\r\n\t},\r\n\t// For each boolean attribute, mere presence of attribute in both is enough\r\n\t// to assume equivalence.\r\n\t...Object.fromEntries(\r\n\t\tBOOLEAN_ATTRIBUTES.map( ( attribute ) => [ attribute, () => true ] )\r\n\t),\r\n};\r\n\r\n/**\r\n * Given two sets of attribute tuples, returns true if the attribute sets are\r\n * equivalent.\r\n *\r\n * @param {Array[]} actual   Actual attributes tuples.\r\n * @param {Array[]} expected Expected attributes tuples.\r\n * @param {Object}  logger   Validation logger object.\r\n *\r\n * @return {boolean} Whether attributes are equivalent.\r\n */\r\nexport function isEqualTagAttributePairs(\r\n\tactual,\r\n\texpected,\r\n\tlogger = createLogger()\r\n) {\r\n\t// Attributes is tokenized as tuples. Their lengths should match. This also\r\n\t// avoids us needing to check both attributes sets, since if A has any keys\r\n\t// which do not exist in B, we know the sets to be different.\r\n\tif ( actual.length !== expected.length ) {\r\n\t\tlogger.warning(\r\n\t\t\t'Expected attributes %o, instead saw %o.',\r\n\t\t\texpected,\r\n\t\t\tactual\r\n\t\t);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Attributes are not guaranteed to occur in the same order. For validating\r\n\t// actual attributes, first convert the set of expected attribute values to\r\n\t// an object, for lookup by key.\r\n\tconst expectedAttributes = {};\r\n\tfor ( let i = 0; i < expected.length; i++ ) {\r\n\t\texpectedAttributes[ expected[ i ][ 0 ].toLowerCase() ] =\r\n\t\t\texpected[ i ][ 1 ];\r\n\t}\r\n\r\n\tfor ( let i = 0; i < actual.length; i++ ) {\r\n\t\tconst [ name, actualValue ] = actual[ i ];\r\n\t\tconst nameLower = name.toLowerCase();\r\n\r\n\t\t// As noted above, if missing member in B, assume different.\r\n\t\tif ( ! expectedAttributes.hasOwnProperty( nameLower ) ) {\r\n\t\t\tlogger.warning( 'Encountered unexpected attribute `%s`.', name );\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst expectedValue = expectedAttributes[ nameLower ];\r\n\t\tconst isEqualAttributes = isEqualAttributesOfName[ nameLower ];\r\n\r\n\t\tif ( isEqualAttributes ) {\r\n\t\t\t// Defer custom attribute equality handling.\r\n\t\t\tif ( ! isEqualAttributes( actualValue, expectedValue ) ) {\r\n\t\t\t\tlogger.warning(\r\n\t\t\t\t\t'Expected attribute `%s` of value `%s`, saw `%s`.',\r\n\t\t\t\t\tname,\r\n\t\t\t\t\texpectedValue,\r\n\t\t\t\t\tactualValue\r\n\t\t\t\t);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if ( actualValue !== expectedValue ) {\r\n\t\t\t// Otherwise strict inequality should bail.\r\n\t\t\tlogger.warning(\r\n\t\t\t\t'Expected attribute `%s` of value `%s`, saw `%s`.',\r\n\t\t\t\tname,\r\n\t\t\t\texpectedValue,\r\n\t\t\t\tactualValue\r\n\t\t\t);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Token-type-specific equality handlers\r\n *\r\n * @type {Object}\r\n */\r\nexport const isEqualTokensOfType = {\r\n\tStartTag: ( actual, expected, logger = createLogger() ) => {\r\n\t\tif (\r\n\t\t\tactual.tagName !== expected.tagName &&\r\n\t\t\t// Optimization: Use short-circuit evaluation to defer case-\r\n\t\t\t// insensitive check on the assumption that the majority case will\r\n\t\t\t// have exactly equal tag names.\r\n\t\t\tactual.tagName.toLowerCase() !== expected.tagName.toLowerCase()\r\n\t\t) {\r\n\t\t\tlogger.warning(\r\n\t\t\t\t'Expected tag name `%s`, instead saw `%s`.',\r\n\t\t\t\texpected.tagName,\r\n\t\t\t\tactual.tagName\r\n\t\t\t);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn isEqualTagAttributePairs(\r\n\t\t\t...[ actual, expected ].map( getMeaningfulAttributePairs ),\r\n\t\t\tlogger\r\n\t\t);\r\n\t},\r\n\tChars: isEquivalentTextTokens,\r\n\tComment: isEquivalentTextTokens,\r\n};\r\n\r\n/**\r\n * Given an array of tokens, returns the first token which is not purely\r\n * whitespace.\r\n *\r\n * Mutates the tokens array.\r\n *\r\n * @param {Object[]} tokens Set of tokens to search.\r\n *\r\n * @return {Object | undefined} Next non-whitespace token.\r\n */\r\nexport function getNextNonWhitespaceToken( tokens ) {\r\n\tlet token;\r\n\twhile ( ( token = tokens.shift() ) ) {\r\n\t\tif ( token.type !== 'Chars' ) {\r\n\t\t\treturn token;\r\n\t\t}\r\n\r\n\t\tif ( ! REGEXP_ONLY_WHITESPACE.test( token.chars ) ) {\r\n\t\t\treturn token;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Tokenize an HTML string, gracefully handling any errors thrown during\r\n * underlying tokenization.\r\n *\r\n * @param {string} html   HTML string to tokenize.\r\n * @param {Object} logger Validation logger object.\r\n *\r\n * @return {Object[]|null} Array of valid tokenized HTML elements, or null on error\r\n */\r\nfunction getHTMLTokens( html, logger = createLogger() ) {\r\n\ttry {\r\n\t\treturn new Tokenizer( new DecodeEntityParser() ).tokenize( html );\r\n\t} catch ( e ) {\r\n\t\tlogger.warning( 'Malformed HTML detected: %s', html );\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * Returns true if the next HTML token closes the current token.\r\n *\r\n * @param {Object}           currentToken Current token to compare with.\r\n * @param {Object|undefined} nextToken    Next token to compare against.\r\n *\r\n * @return {boolean} true if `nextToken` closes `currentToken`, false otherwise\r\n */\r\nexport function isClosedByToken( currentToken, nextToken ) {\r\n\t// Ensure this is a self closed token.\r\n\tif ( ! currentToken.selfClosing ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Check token names and determine if nextToken is the closing tag for currentToken.\r\n\tif (\r\n\t\tnextToken &&\r\n\t\tnextToken.tagName === currentToken.tagName &&\r\n\t\tnextToken.type === 'EndTag'\r\n\t) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Returns true if the given HTML strings are effectively equivalent, or\r\n * false otherwise. Invalid HTML is not considered equivalent, even if the\r\n * strings directly match.\r\n *\r\n * @param {string} actual   Actual HTML string.\r\n * @param {string} expected Expected HTML string.\r\n * @param {Object} logger   Validation logger object.\r\n *\r\n * @return {boolean} Whether HTML strings are equivalent.\r\n */\r\nexport function isEquivalentHTML( actual, expected, logger = createLogger() ) {\r\n\t// Short-circuit if markup is identical.\r\n\tif ( actual === expected ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Tokenize input content and reserialized save content.\r\n\tconst [ actualTokens, expectedTokens ] = [ actual, expected ].map(\r\n\t\t( html ) => getHTMLTokens( html, logger )\r\n\t);\r\n\r\n\t// If either is malformed then stop comparing - the strings are not equivalent.\r\n\tif ( ! actualTokens || ! expectedTokens ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tlet actualToken, expectedToken;\r\n\twhile ( ( actualToken = getNextNonWhitespaceToken( actualTokens ) ) ) {\r\n\t\texpectedToken = getNextNonWhitespaceToken( expectedTokens );\r\n\r\n\t\t// Inequal if exhausted all expected tokens.\r\n\t\tif ( ! expectedToken ) {\r\n\t\t\tlogger.warning(\r\n\t\t\t\t'Expected end of content, instead saw %o.',\r\n\t\t\t\tactualToken\r\n\t\t\t);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Inequal if next non-whitespace token of each set are not same type.\r\n\t\tif ( actualToken.type !== expectedToken.type ) {\r\n\t\t\tlogger.warning(\r\n\t\t\t\t'Expected token of type `%s` (%o), instead saw `%s` (%o).',\r\n\t\t\t\texpectedToken.type,\r\n\t\t\t\texpectedToken,\r\n\t\t\t\tactualToken.type,\r\n\t\t\t\tactualToken\r\n\t\t\t);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Defer custom token type equality handling, otherwise continue and\r\n\t\t// assume as equal.\r\n\t\tconst isEqualTokens = isEqualTokensOfType[ actualToken.type ];\r\n\t\tif (\r\n\t\t\tisEqualTokens &&\r\n\t\t\t! isEqualTokens( actualToken, expectedToken, logger )\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Peek at the next tokens (actual and expected) to see if they close\r\n\t\t// a self-closing tag.\r\n\t\tif ( isClosedByToken( actualToken, expectedTokens[ 0 ] ) ) {\r\n\t\t\t// Consume the next expected token that closes the current actual\r\n\t\t\t// self-closing token.\r\n\t\t\tgetNextNonWhitespaceToken( expectedTokens );\r\n\t\t} else if ( isClosedByToken( expectedToken, actualTokens[ 0 ] ) ) {\r\n\t\t\t// Consume the next actual token that closes the current expected\r\n\t\t\t// self-closing token.\r\n\t\t\tgetNextNonWhitespaceToken( actualTokens );\r\n\t\t}\r\n\t}\r\n\r\n\tif ( ( expectedToken = getNextNonWhitespaceToken( expectedTokens ) ) ) {\r\n\t\t// If any non-whitespace tokens remain in expected token set, this\r\n\t\t// indicates inequality.\r\n\t\tlogger.warning(\r\n\t\t\t'Expected %o, instead saw end of content.',\r\n\t\t\texpectedToken\r\n\t\t);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Returns an object with `isValid` property set to `true` if the parsed block\r\n * is valid given the input content. A block is considered valid if, when serialized\r\n * with assumed attributes, the content matches the original value. If block is\r\n * invalid, this function returns all validations issues as well.\r\n *\r\n * @param {string|Object} blockTypeOrName      Block type.\r\n * @param {Object}        attributes           Parsed block attributes.\r\n * @param {string}        originalBlockContent Original block content.\r\n * @param {Object}        logger               Validation logger object.\r\n *\r\n * @return {Object} Whether block is valid and contains validation messages.\r\n */\r\n\r\n/**\r\n * Returns an object with `isValid` property set to `true` if the parsed block\r\n * is valid given the input content. A block is considered valid if, when serialized\r\n * with assumed attributes, the content matches the original value. If block is\r\n * invalid, this function returns all validations issues as well.\r\n *\r\n * @param {WPBlock}            block                          block object.\r\n * @param {WPBlockType|string} [blockTypeOrName = block.name] Block type or name, inferred from block if not given.\r\n *\r\n * @return {[boolean,Array<LoggerItem>]} validation results.\r\n */\r\nexport function validateBlock( block, blockTypeOrName = block.name ) {\r\n\tconst isFallbackBlock =\r\n\t\tblock.name === getFreeformContentHandlerName() ||\r\n\t\tblock.name === getUnregisteredTypeHandlerName();\r\n\r\n\t// Shortcut to avoid costly validation.\r\n\tif ( isFallbackBlock ) {\r\n\t\treturn [ true, [] ];\r\n\t}\r\n\r\n\tconst logger = createQueuedLogger();\r\n\tconst blockType = normalizeBlockType( blockTypeOrName );\r\n\tlet generatedBlockContent;\r\n\ttry {\r\n\t\tgeneratedBlockContent = getSaveContent( blockType, block.attributes );\r\n\t} catch ( error ) {\r\n\t\tlogger.error(\r\n\t\t\t'Block validation failed because an error occurred while generating block content:\\n\\n%s',\r\n\t\t\terror.toString()\r\n\t\t);\r\n\r\n\t\treturn [ false, logger.getItems() ];\r\n\t}\r\n\r\n\tconst isValid = isEquivalentHTML(\r\n\t\tblock.originalContent,\r\n\t\tgeneratedBlockContent,\r\n\t\tlogger\r\n\t);\r\n\r\n\tif ( ! isValid ) {\r\n\t\tlogger.error(\r\n\t\t\t'Block validation failed for `%s` (%o).\\n\\nContent generated by `save` function:\\n\\n%s\\n\\nContent retrieved from post body:\\n\\n%s',\r\n\t\t\tblockType.name,\r\n\t\t\tblockType,\r\n\t\t\tgeneratedBlockContent,\r\n\t\t\tblock.originalContent\r\n\t\t);\r\n\t}\r\n\r\n\treturn [ isValid, logger.getItems() ];\r\n}\r\n\r\n/**\r\n * Returns true if the parsed block is valid given the input content. A block\r\n * is considered valid if, when serialized with assumed attributes, the content\r\n * matches the original value.\r\n *\r\n * Logs to console in development environments when invalid.\r\n *\r\n * @deprecated Use validateBlock instead to avoid data loss.\r\n *\r\n * @param {string|Object} blockTypeOrName      Block type.\r\n * @param {Object}        attributes           Parsed block attributes.\r\n * @param {string}        originalBlockContent Original block content.\r\n *\r\n * @return {boolean} Whether block is valid.\r\n */\r\nexport function isValidBlockContent(\r\n\tblockTypeOrName,\r\n\tattributes,\r\n\toriginalBlockContent\r\n) {\r\n\tdeprecated( 'isValidBlockContent introduces opportunity for data loss', {\r\n\t\tsince: '12.6',\r\n\t\tplugin: 'Gutenberg',\r\n\t\talternative: 'validateBlock',\r\n\t} );\r\n\r\n\tconst blockType = normalizeBlockType( blockTypeOrName );\r\n\tconst block = {\r\n\t\tname: blockType.name,\r\n\t\tattributes,\r\n\t\tinnerBlocks: [],\r\n\t\toriginalContent: originalBlockContent,\r\n\t};\r\n\tconst [ isValid ] = validateBlock( block, blockType );\r\n\r\n\treturn isValid;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,uBAAuB;AACjD,OAAOC,aAAa,MAAM,qBAAqB;;AAE/C;AACA;AACA;AACA,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,SAASC,cAAc,QAAQ,0BAA0B;;AAEzD;AACA;AACA;AACA,SAASC,YAAY,EAAEC,kBAAkB,QAAQ,UAAU;AAC3D,SAASC,cAAc,QAAQ,eAAe;AAC9C,SACCC,6BAA6B,EAC7BC,8BAA8B,QACxB,iBAAiB;AACxB,SAASC,kBAAkB,QAAQ,UAAU;;AAE7C;AACA;AACA;;AAEA,MAAMC,QAAQ,GAAKC,CAAC,IAAMA,CAAC;;AAE3B;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,GAAG,iBAAiB;;AAE3C;AACA;AACA;AACA;AACA;AACA,MAAMC,sBAAsB,GAAG,kBAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,iCAAiC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAG,CAC1B,iBAAiB,EACjB,qBAAqB,EACrB,gBAAgB,EAChB,OAAO,EACP,WAAW,EACX,UAAU,EACV,SAAS,EACT,UAAU,EACV,SAAS,EACT,OAAO,EACP,UAAU,EACV,UAAU,EACV,gBAAgB,EAChB,QAAQ,EACR,OAAO,EACP,WAAW,EACX,MAAM,EACN,UAAU,EACV,OAAO,EACP,UAAU,EACV,YAAY,EACZ,MAAM,EACN,aAAa,EACb,UAAU,EACV,UAAU,EACV,UAAU,EACV,UAAU,EACV,eAAe,CACf;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,CAC7B,gBAAgB,EAChB,cAAc,EACd,SAAS,EACT,iBAAiB,EACjB,aAAa,EACb,UAAU,EACV,KAAK,EACL,WAAW,EACX,SAAS,EACT,aAAa,EACb,YAAY,EACZ,YAAY,EACZ,WAAW,EACX,MAAM,EACN,QAAQ,EACR,SAAS,EACT,OAAO,EACP,OAAO,EACP,YAAY,EACZ,WAAW,EACX,MAAM,EACN,MAAM,CACN;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,CAC7B,GAAGF,kBAAkB,EACrB,GAAGC,qBAAqB,CACxB;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,mBAAmB,GAAG,CAAER,QAAQ,EAAES,8BAA8B,CAAE;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gCAAgC,GAAG,aAAa;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kCAAkC,GAAG,QAAQ;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,sCAAsC,GAAG,eAAe;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyBA,CAAEC,IAAI,EAAG;EACjD,OACCJ,gCAAgC,CAACK,IAAI,CAAED,IAAK,CAAC,IAC7CH,kCAAkC,CAACI,IAAI,CAAED,IAAK,CAAC,IAC/CF,sCAAsC,CAACG,IAAI,CAAED,IAAK,CAAC;AAErD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,kBAAkB,CAAC;EAC/B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,KAAKA,CAAEC,MAAM,EAAG;IACf,IAAKL,yBAAyB,CAAEK,MAAO,CAAC,EAAG;MAC1C,OAAOzB,cAAc,CAAE,GAAG,GAAGyB,MAAM,GAAG,GAAI,CAAC;IAC5C;EACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,8BAA8BA,CAAEL,IAAI,EAAG;EACtD,OAAOA,IAAI,CAACM,IAAI,CAAC,CAAC,CAACC,KAAK,CAAEnB,iBAAkB,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA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","ignoreList":[]}