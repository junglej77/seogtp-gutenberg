{"version":3,"names":[],"sources":["@wordpress/components/src/autocomplete/types.ts"],"sourcesContent":["/**\r\n * External dependencies\r\n */\r\nimport type { ReactElement } from 'react';\r\n\r\n/**\r\n * WordPress dependencies\r\n */\r\nimport type { RichTextValue } from '@wordpress/rich-text';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport type { useAutocomplete } from '.';\r\n\r\n// Insert the `value` into the text.\r\nexport type InsertOption = {\r\n\taction: 'insert-at-caret';\r\n\tvalue: React.ReactNode;\r\n};\r\n\r\n// Replace the current block with the block specified in the `value` property\r\nexport type ReplaceOption = { action: 'replace'; value: RichTextValue };\r\n\r\nexport type OptionCompletion = React.ReactNode | InsertOption | ReplaceOption;\r\n\r\ntype OptionLabel = string | ReactElement | Array< string | ReactElement >;\r\nexport type KeyedOption = {\r\n\tkey: string;\r\n\tvalue: any;\r\n\tlabel: OptionLabel;\r\n\tkeywords: Array< string >;\r\n\tisDisabled: boolean;\r\n};\r\n\r\nexport type WPCompleter< TCompleterOption = any > = {\r\n\t/**\r\n\t * The name of the completer. Useful for identifying a specific completer to\r\n\t * be overridden via extensibility hooks.\r\n\t */\r\n\tname: string;\r\n\t/**\r\n\t * The string prefix that should trigger the completer. For example,\r\n\t * Gutenberg's block completer is triggered when the '/' character is\r\n\t * entered.\r\n\t */\r\n\ttriggerPrefix: string;\r\n\t/**\r\n\t * The raw options for completion. May be an array, a function that returns\r\n\t * an array, or a function that returns a promise for an array.\r\n\t * Options may be of any type or shape. The completer declares how those\r\n\t * options are rendered and what their completions should be when selected.\r\n\t */\r\n\toptions:\r\n\t\t| ( (\r\n\t\t\t\tquery: string\r\n\t\t  ) =>\r\n\t\t\t\t| PromiseLike< readonly TCompleterOption[] >\r\n\t\t\t\t| readonly TCompleterOption[] )\r\n\t\t| readonly TCompleterOption[];\r\n\t/**\r\n\t * A function that returns the keywords for the specified option.\r\n\t */\r\n\tgetOptionKeywords?: ( option: TCompleterOption ) => Array< string >;\r\n\t/**\r\n\t * A function that returns whether or not the specified option is disabled.\r\n\t * Disabled options cannot be selected.\r\n\t */\r\n\tisOptionDisabled?: ( option: TCompleterOption ) => boolean;\r\n\t/**\r\n\t * A function that returns the label for a given option. A label may be a\r\n\t * string or a mixed array of strings, elements, and components.\r\n\t */\r\n\tgetOptionLabel: ( option: TCompleterOption ) => OptionLabel;\r\n\t/**\r\n\t * A function that takes a Range before and a Range after the autocomplete\r\n\t * trigger and query text and returns a boolean indicating whether the\r\n\t * completer should be considered for that context.\r\n\t */\r\n\tallowContext?: ( before: string, after: string ) => boolean;\r\n\t/**\r\n\t * A function that takes an option and returns how the option should\r\n\t * be completed. By default, the result is a value to be inserted in the\r\n\t * text.\r\n\t * However, a completer may explicitly declare how a completion should be\r\n\t * treated by returning an object with `action` and `value` properties. The\r\n\t * `action` declares what should be done with the `value`.\r\n\t */\r\n\tgetOptionCompletion?: (\r\n\t\toption: TCompleterOption,\r\n\t\tquery: string\r\n\t) => OptionCompletion;\r\n\t/**\r\n\t * A function that returns an array of items to be displayed in the\r\n\t * Autocomplete UI. These items have uniform shape and have been filtered by\r\n\t * `AutocompleterUIProps.filterValue`.\r\n\t */\r\n\tuseItems?: ( filterValue: string ) => readonly [ Array< KeyedOption > ];\r\n\t/**\r\n\t * Whether or not changes to the `filterValue` should be debounced.\r\n\t */\r\n\tisDebounced?: boolean;\r\n\t/**\r\n\t * A CSS class name to be applied to the completion menu.\r\n\t */\r\n\tclassName?: string;\r\n};\r\n\r\ntype ContentRef = React.RefObject< HTMLElement >;\r\n\r\nexport type AutocompleterUIProps = {\r\n\t/**\r\n\t * The value to filter the options by.\r\n\t */\r\n\tfilterValue: string;\r\n\t/**\r\n\t * An id unique to each instance of the component, used in the IDs of the\r\n\t * buttons generated for individual options.\r\n\t */\r\n\tinstanceId: number;\r\n\t/**\r\n\t * The id of to be applied to the listbox of options.\r\n\t */\r\n\tlistBoxId: string | undefined;\r\n\t/**\r\n\t * The class to apply to the wrapper element.\r\n\t */\r\n\tclassName?: string;\r\n\t/**\r\n\t * The index of the currently selected option.\r\n\t */\r\n\tselectedIndex: number;\r\n\t/**\r\n\t * A function to be called when the filterValue changes.\r\n\t */\r\n\tonChangeOptions: ( items: Array< KeyedOption > ) => void;\r\n\t/**\r\n\t * A function to be called when an option is selected.\r\n\t */\r\n\tonSelect: ( option: KeyedOption ) => void;\r\n\t/**\r\n\t * A function to be called when the completer is reset\r\n\t * (e.g. when the user hits the escape key).\r\n\t */\r\n\tonReset?: () => void;\r\n\t/**\r\n\t * A function that defines the behavior of the completer when it is reset\r\n\t */\r\n\treset: ( event: Event ) => void;\r\n\t// This is optional because it's still needed for mobile/native.\r\n\t/**\r\n\t * The rich text value object the autocompleter is being applied to.\r\n\t */\r\n\tvalue?: RichTextValue;\r\n\t/**\r\n\t * A ref containing the editable element that will serve as the anchor for\r\n\t * `Autocomplete`'s `Popover`.\r\n\t */\r\n\tcontentRef: ContentRef;\r\n};\r\n\r\nexport type CancelablePromise< T = void > = Promise< T > & {\r\n\tcanceled?: boolean;\r\n};\r\n\r\nexport type UseAutocompleteProps = {\r\n\t/**\r\n\t * The rich text value object the autocompleter is being applied to.\r\n\t */\r\n\trecord: RichTextValue & {\r\n\t\tstart: NonNullable< RichTextValue[ 'start' ] >;\r\n\t\tend: NonNullable< RichTextValue[ 'end' ] >;\r\n\t};\r\n\t/**\r\n\t * A function to be called when an option is selected to insert into the\r\n\t * existing text.\r\n\t */\r\n\tonChange: ( value: RichTextValue ) => void;\r\n\t/**\r\n\t * A function to be called when an option is selected to replace the\r\n\t * existing text.\r\n\t */\r\n\tonReplace: ( values: RichTextValue[] ) => void;\r\n\t/**\r\n\t * An array of all of the completers to apply to the current element.\r\n\t */\r\n\tcompleters: Array< WPCompleter >;\r\n\t/**\r\n\t * A ref containing the editable element that will serve as the anchor for\r\n\t * `Autocomplete`'s `Popover`.\r\n\t */\r\n\tcontentRef: ContentRef;\r\n};\r\n\r\nexport type AutocompleteProps = UseAutocompleteProps & {\r\n\t/**\r\n\t * A function that returns nodes to be rendered within the Autocomplete.\r\n\t */\r\n\tchildren: (\r\n\t\tprops: Omit< ReturnType< typeof useAutocomplete >, 'popover' >\r\n\t) => React.ReactNode;\r\n\t/**\r\n\t * Whether or not the Autocomplete component is selected, and if its\r\n\t * `Popover` should be displayed.\r\n\t */\r\n\tisSelected: boolean;\r\n};\r\n"],"mappings":"","ignoreList":[]}