{"version":3,"names":["deepmerge","fastDeepEqual","isPlainObject","createContext","useContext","useRef","useMemo","memo","warn","useUpdateEffect","jsx","_jsx","ComponentsContext","useComponentsContext","useContextSystemBridge","value","parentContext","valueRef","current","globalThis","SCRIPT_DEBUG","JSON","stringify","config","isMergeableObject","BaseContextSystemProvider","children","contextValue","Provider","ContextSystemProvider"],"sources":["@wordpress/components/src/context/context-system-provider.js"],"sourcesContent":["/**\r\n * External dependencies\r\n */\r\nimport deepmerge from 'deepmerge';\r\nimport fastDeepEqual from 'fast-deep-equal/es6';\r\nimport { isPlainObject } from 'is-plain-object';\r\n\r\n/**\r\n * WordPress dependencies\r\n */\r\nimport {\r\n\tcreateContext,\r\n\tuseContext,\r\n\tuseRef,\r\n\tuseMemo,\r\n\tmemo,\r\n} from '@wordpress/element';\r\nimport warn from '@wordpress/warning';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport { useUpdateEffect } from '../utils';\r\n\r\nexport const ComponentsContext = createContext(\r\n\t/** @type {Record<string, any>} */ ( {} )\r\n);\r\nexport const useComponentsContext = () => useContext( ComponentsContext );\r\n\r\n/**\r\n * Consolidates incoming ContextSystem values with a (potential) parent ContextSystem value.\r\n *\r\n * Note: This function will warn if it detects an un-memoized `value`\r\n *\r\n * @param {Object}              props\r\n * @param {Record<string, any>} props.value\r\n * @return {Record<string, any>} The consolidated value.\r\n */\r\nfunction useContextSystemBridge( { value } ) {\r\n\tconst parentContext = useComponentsContext();\r\n\r\n\tconst valueRef = useRef( value );\r\n\r\n\tuseUpdateEffect( () => {\r\n\t\tif (\r\n\t\t\t// Objects are equivalent.\r\n\t\t\tfastDeepEqual( valueRef.current, value ) &&\r\n\t\t\t// But not the same reference.\r\n\t\t\tvalueRef.current !== value\r\n\t\t) {\r\n\t\t\twarn( `Please memoize your context: ${ JSON.stringify( value ) }` );\r\n\t\t}\r\n\t}, [ value ] );\r\n\r\n\t// `parentContext` will always be memoized (i.e., the result of this hook itself)\r\n\t// or the default value from when the `ComponentsContext` was originally\r\n\t// initialized (which will never change, it's a static variable)\r\n\t// so this memoization will prevent `deepmerge()` from rerunning unless\r\n\t// the references to `value` change OR the `parentContext` has an actual material change\r\n\t// (because again, it's guaranteed to be memoized or a static reference to the empty object\r\n\t// so we know that the only changes for `parentContext` are material ones... i.e., why we\r\n\t// don't have to warn in the `useUpdateEffect` hook above for `parentContext` and we only\r\n\t// need to bother with the `value`). The `useUpdateEffect` above will ensure that we are\r\n\t// correctly warning when the `value` isn't being properly memoized. All of that to say\r\n\t// that this should be super safe to assume that `useMemo` will only run on actual\r\n\t// changes to the two dependencies, therefore saving us calls to `deepmerge()`!\r\n\tconst config = useMemo( () => {\r\n\t\t// Deep clone `parentContext` to avoid mutating it later.\r\n\t\treturn deepmerge( parentContext ?? {}, value ?? {}, {\r\n\t\t\tisMergeableObject: isPlainObject,\r\n\t\t} );\r\n\t}, [ parentContext, value ] );\r\n\r\n\treturn config;\r\n}\r\n\r\n/**\r\n * A Provider component that can modify props for connected components within\r\n * the Context system.\r\n *\r\n * @example\r\n * ```jsx\r\n * <ContextSystemProvider value={{ Button: { size: 'small' }}}>\r\n *   <Button>...</Button>\r\n * </ContextSystemProvider>\r\n * ```\r\n *\r\n * @template {Record<string, any>} T\r\n * @param {Object}                    options\r\n * @param {import('react').ReactNode} options.children Children to render.\r\n * @param {T}                         options.value    Props to render into connected components.\r\n * @return {JSX.Element} A Provider wrapped component.\r\n */\r\nconst BaseContextSystemProvider = ( { children, value } ) => {\r\n\tconst contextValue = useContextSystemBridge( { value } );\r\n\r\n\treturn (\r\n\t\t<ComponentsContext.Provider value={ contextValue }>\r\n\t\t\t{ children }\r\n\t\t</ComponentsContext.Provider>\r\n\t);\r\n};\r\n\r\nexport const ContextSystemProvider = memo( BaseContextSystemProvider );\r\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,WAAW;AACjC,OAAOC,aAAa,MAAM,qBAAqB;AAC/C,SAASC,aAAa,QAAQ,iBAAiB;;AAE/C;AACA;AACA;AACA,SACCC,aAAa,EACbC,UAAU,EACVC,MAAM,EACNC,OAAO,EACPC,IAAI,QACE,oBAAoB;AAC3B,OAAOC,IAAI,MAAM,oBAAoB;;AAErC;AACA;AACA;AACA,SAASC,eAAe,QAAQ,UAAU;AAAC,SAAAC,GAAA,IAAAC,IAAA;AAE3C,OAAO,MAAMC,iBAAiB,GAAGT,aAAa,EAC7C,kCAAqC,CAAC,CACvC,CAAC;AACD,OAAO,MAAMU,oBAAoB,GAAGA,CAAA,KAAMT,UAAU,CAAEQ,iBAAkB,CAAC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,sBAAsBA,CAAE;EAAEC;AAAM,CAAC,EAAG;EAC5C,MAAMC,aAAa,GAAGH,oBAAoB,CAAC,CAAC;EAE5C,MAAMI,QAAQ,GAAGZ,MAAM,CAAEU,KAAM,CAAC;EAEhCN,eAAe,CAAE,MAAM;IACtB;IACC;IACAR,aAAa,CAAEgB,QAAQ,CAACC,OAAO,EAAEH,KAAM,CAAC;IACxC;IACAE,QAAQ,CAACC,OAAO,KAAKH,KAAK,EACzB;MACDI,UAAA,CAAAC,YAAA,YAAAZ,IAAI,CAAG,gCAAgCa,IAAI,CAACC,SAAS,CAAEP,KAAM,CAAG,EAAE,CAAC;IACpE;EACD,CAAC,EAAE,CAAEA,KAAK,CAAG,CAAC;;EAEd;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMQ,MAAM,GAAGjB,OAAO,CAAE,MAAM;IAC7B;IACA,OAAON,SAAS,CAAEgB,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAI,CAAC,CAAC,EAAED,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,CAAC,CAAC,EAAE;MACnDS,iBAAiB,EAAEtB;IACpB,CAAE,CAAC;EACJ,CAAC,EAAE,CAAEc,aAAa,EAAED,KAAK,CAAG,CAAC;EAE7B,OAAOQ,MAAM;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,yBAAyB,GAAGA,CAAE;EAAEC,QAAQ;EAAEX;AAAM,CAAC,KAAM;EAC5D,MAAMY,YAAY,GAAGb,sBAAsB,CAAE;IAAEC;EAAM,CAAE,CAAC;EAExD,oBACCJ,IAAA,CAACC,iBAAiB,CAACgB,QAAQ;IAACb,KAAK,EAAGY,YAAc;IAAAD,QAAA,EAC/CA;EAAQ,CACiB,CAAC;AAE/B,CAAC;AAED,OAAO,MAAMG,qBAAqB,GAAGtB,IAAI,CAAEkB,yBAA0B,CAAC","ignoreList":[]}