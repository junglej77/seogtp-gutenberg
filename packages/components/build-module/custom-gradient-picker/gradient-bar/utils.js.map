{"version":3,"names":["MINIMUM_DISTANCE_BETWEEN_POINTS","clampPercent","value","Math","max","min","isOverlapping","initialIndex","newPosition","minDistance","initialPosition","position","minPosition","maxPosition","some","index","abs","addControlPoint","points","color","nextIndex","findIndex","point","newPoint","newPoints","slice","splice","removeControlPoint","filter","_point","pointIndex","updateControlPoint","newValue","updateControlPointPosition","updateControlPointColor","newColor","updateControlPointColorByPosition","getHorizontalRelativeGradientPosition","mouseXCoordinate","containerElement","x","width","getBoundingClientRect","absolutePositionValue","round"],"sources":["@wordpress/components/src/custom-gradient-picker/gradient-bar/utils.ts"],"sourcesContent":["/**\r\n * Internal dependencies\r\n */\r\nimport { MINIMUM_DISTANCE_BETWEEN_POINTS } from './constants';\r\nimport type { ControlPoint } from '../types';\r\n\r\n/**\r\n * Clamps a number between 0 and 100.\r\n *\r\n * @param value Value to clamp.\r\n *\r\n * @return Value clamped between 0 and 100.\r\n */\r\nexport function clampPercent( value: number ) {\r\n\treturn Math.max( 0, Math.min( 100, value ) );\r\n}\r\n\r\n/**\r\n * Check if a control point is overlapping with another.\r\n *\r\n * @param value        Array of control points.\r\n * @param initialIndex Index of the position to test.\r\n * @param newPosition  New position of the control point.\r\n * @param minDistance  Distance considered to be overlapping.\r\n *\r\n * @return True if the point is overlapping.\r\n */\r\nexport function isOverlapping(\r\n\tvalue: ControlPoint[],\r\n\tinitialIndex: number,\r\n\tnewPosition: number,\r\n\tminDistance: number = MINIMUM_DISTANCE_BETWEEN_POINTS\r\n) {\r\n\tconst initialPosition = value[ initialIndex ].position;\r\n\tconst minPosition = Math.min( initialPosition, newPosition );\r\n\tconst maxPosition = Math.max( initialPosition, newPosition );\r\n\r\n\treturn value.some( ( { position }, index ) => {\r\n\t\treturn (\r\n\t\t\tindex !== initialIndex &&\r\n\t\t\t( Math.abs( position - newPosition ) < minDistance ||\r\n\t\t\t\t( minPosition < position && position < maxPosition ) )\r\n\t\t);\r\n\t} );\r\n}\r\n\r\n/**\r\n * Adds a control point from an array and returns the new array.\r\n *\r\n * @param points   Array of control points.\r\n * @param position Position to insert the new point.\r\n * @param color    Color to update the control point at index.\r\n *\r\n * @return New array of control points.\r\n */\r\nexport function addControlPoint(\r\n\tpoints: ControlPoint[],\r\n\tposition: number,\r\n\tcolor: ControlPoint[ 'color' ]\r\n) {\r\n\tconst nextIndex = points.findIndex(\r\n\t\t( point ) => point.position > position\r\n\t);\r\n\tconst newPoint = { color, position };\r\n\tconst newPoints = points.slice();\r\n\tnewPoints.splice( nextIndex - 1, 0, newPoint );\r\n\treturn newPoints;\r\n}\r\n\r\n/**\r\n * Removes a control point from an array and returns the new array.\r\n *\r\n * @param points Array of control points.\r\n * @param index  Index to remove.\r\n *\r\n * @return New array of control points.\r\n */\r\nexport function removeControlPoint( points: ControlPoint[], index: number ) {\r\n\treturn points.filter( ( _point, pointIndex ) => {\r\n\t\treturn pointIndex !== index;\r\n\t} );\r\n}\r\n/**\r\n * Updates a control point from an array and returns the new array.\r\n *\r\n * @param points   Array of control points.\r\n * @param index    Index to update.\r\n * @param newPoint New control point to replace the index.\r\n *\r\n * @return New array of control points.\r\n */\r\nexport function updateControlPoint(\r\n\tpoints: ControlPoint[],\r\n\tindex: number,\r\n\tnewPoint: ControlPoint\r\n) {\r\n\tconst newValue = points.slice();\r\n\tnewValue[ index ] = newPoint;\r\n\treturn newValue;\r\n}\r\n\r\n/**\r\n * Updates the position of a control point from an array and returns the new array.\r\n *\r\n * @param points      Array of control points.\r\n * @param index       Index to update.\r\n * @param newPosition Position to move the control point at index.\r\n *\r\n * @return New array of control points.\r\n */\r\nexport function updateControlPointPosition(\r\n\tpoints: ControlPoint[],\r\n\tindex: number,\r\n\tnewPosition: ControlPoint[ 'position' ]\r\n) {\r\n\tif ( isOverlapping( points, index, newPosition ) ) {\r\n\t\treturn points;\r\n\t}\r\n\tconst newPoint = {\r\n\t\t...points[ index ],\r\n\t\tposition: newPosition,\r\n\t};\r\n\treturn updateControlPoint( points, index, newPoint );\r\n}\r\n\r\n/**\r\n * Updates the position of a control point from an array and returns the new array.\r\n *\r\n * @param points   Array of control points.\r\n * @param index    Index to update.\r\n * @param newColor Color to update the control point at index.\r\n *\r\n * @return New array of control points.\r\n */\r\nexport function updateControlPointColor(\r\n\tpoints: ControlPoint[],\r\n\tindex: number,\r\n\tnewColor: ControlPoint[ 'color' ]\r\n) {\r\n\tconst newPoint = {\r\n\t\t...points[ index ],\r\n\t\tcolor: newColor,\r\n\t};\r\n\treturn updateControlPoint( points, index, newPoint );\r\n}\r\n\r\n/**\r\n * Updates the position of a control point from an array and returns the new array.\r\n *\r\n * @param points   Array of control points.\r\n * @param position Position of the color stop.\r\n * @param newColor Color to update the control point at index.\r\n *\r\n * @return New array of control points.\r\n */\r\nexport function updateControlPointColorByPosition(\r\n\tpoints: ControlPoint[],\r\n\tposition: ControlPoint[ 'position' ],\r\n\tnewColor: ControlPoint[ 'color' ]\r\n) {\r\n\tconst index = points.findIndex( ( point ) => point.position === position );\r\n\treturn updateControlPointColor( points, index, newColor );\r\n}\r\n\r\n/**\r\n * Gets the horizontal coordinate when dragging a control point with the mouse.\r\n *\r\n * @param mouseXcoordinate Horizontal coordinate of the mouse position.\r\n * @param containerElement Container for the gradient picker.\r\n *\r\n * @return Whole number percentage from the left.\r\n */\r\nexport function getHorizontalRelativeGradientPosition(\r\n\tmouseXcoordinate: number,\r\n\tcontainerElement: HTMLDivElement\r\n): number;\r\nexport function getHorizontalRelativeGradientPosition(\r\n\tmouseXcoordinate: number,\r\n\tcontainerElement: null\r\n): undefined;\r\nexport function getHorizontalRelativeGradientPosition(\r\n\tmouseXCoordinate: number,\r\n\tcontainerElement: HTMLDivElement | null\r\n) {\r\n\tif ( ! containerElement ) {\r\n\t\treturn;\r\n\t}\r\n\tconst { x, width } = containerElement.getBoundingClientRect();\r\n\tconst absolutePositionValue = mouseXCoordinate - x;\r\n\treturn Math.round(\r\n\t\tclampPercent( ( absolutePositionValue * 100 ) / width )\r\n\t);\r\n}\r\n"],"mappings":"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","ignoreList":[]}