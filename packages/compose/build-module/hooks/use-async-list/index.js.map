{"version":3,"names":["flushSync","useEffect","useState","createQueue","getFirstItemsPresentInState","list","state","firstItems","i","length","item","includes","push","useAsyncList","config","step","current","setCurrent","concat","slice","asyncQueue","add","reset"],"sources":["@wordpress/compose/src/hooks/use-async-list/index.ts"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { flushSync, useEffect, useState } from '@wordpress/element';\r\nimport { createQueue } from '@wordpress/priority-queue';\r\n\r\ntype AsyncListConfig = {\r\n\tstep: number;\r\n};\r\n\r\n/**\r\n * Returns the first items from list that are present on state.\r\n *\r\n * @param list  New array.\r\n * @param state Current state.\r\n * @return First items present iin state.\r\n */\r\nfunction getFirstItemsPresentInState< T >( list: T[], state: T[] ): T[] {\r\n\tconst firstItems = [];\r\n\r\n\tfor ( let i = 0; i < list.length; i++ ) {\r\n\t\tconst item = list[ i ];\r\n\t\tif ( ! state.includes( item ) ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tfirstItems.push( item );\r\n\t}\r\n\r\n\treturn firstItems;\r\n}\r\n\r\n/**\r\n * React hook returns an array which items get asynchronously appended from a source array.\r\n * This behavior is useful if we want to render a list of items asynchronously for performance reasons.\r\n *\r\n * @param list   Source array.\r\n * @param config Configuration object.\r\n *\r\n * @return Async array.\r\n */\r\nfunction useAsyncList< T >(\r\n\tlist: T[],\r\n\tconfig: AsyncListConfig = { step: 1 }\r\n): T[] {\r\n\tconst { step = 1 } = config;\r\n\tconst [ current, setCurrent ] = useState< T[] >( [] );\r\n\r\n\tuseEffect( () => {\r\n\t\t// On reset, we keep the first items that were previously rendered.\r\n\t\tlet firstItems = getFirstItemsPresentInState( list, current );\r\n\t\tif ( firstItems.length < step ) {\r\n\t\t\tfirstItems = firstItems.concat(\r\n\t\t\t\tlist.slice( firstItems.length, step )\r\n\t\t\t);\r\n\t\t}\r\n\t\tsetCurrent( firstItems );\r\n\r\n\t\tconst asyncQueue = createQueue();\r\n\t\tfor ( let i = firstItems.length; i < list.length; i += step ) {\r\n\t\t\tasyncQueue.add( {}, () => {\r\n\t\t\t\tflushSync( () => {\r\n\t\t\t\t\tsetCurrent( ( state ) => [\r\n\t\t\t\t\t\t...state,\r\n\t\t\t\t\t\t...list.slice( i, i + step ),\r\n\t\t\t\t\t] );\r\n\t\t\t\t} );\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\treturn () => asyncQueue.reset();\r\n\t}, [ list ] );\r\n\r\n\treturn current;\r\n}\r\n\r\nexport default useAsyncList;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAS,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,oBAAoB;AACnE,SAASC,WAAW,QAAQ,2BAA2B;AAMvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAAOC,IAAS,EAAEC,KAAU,EAAQ;EACvE,MAAMC,UAAU,GAAG,EAAE;EAErB,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,MAAM,EAAED,CAAC,EAAE,EAAG;IACvC,MAAME,IAAI,GAAGL,IAAI,CAAEG,CAAC,CAAE;IACtB,IAAK,CAAEF,KAAK,CAACK,QAAQ,CAAED,IAAK,CAAC,EAAG;MAC/B;IACD;IAEAH,UAAU,CAACK,IAAI,CAAEF,IAAK,CAAC;EACxB;EAEA,OAAOH,UAAU;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,YAAYA,CACpBR,IAAS,EACTS,MAAuB,GAAG;EAAEC,IAAI,EAAE;AAAE,CAAC,EAC/B;EACN,MAAM;IAAEA,IAAI,GAAG;EAAE,CAAC,GAAGD,MAAM;EAC3B,MAAM,CAAEE,OAAO,EAAEC,UAAU,CAAE,GAAGf,QAAQ,CAAS,EAAG,CAAC;EAErDD,SAAS,CAAE,MAAM;IAChB;IACA,IAAIM,UAAU,GAAGH,2BAA2B,CAAEC,IAAI,EAAEW,OAAQ,CAAC;IAC7D,IAAKT,UAAU,CAACE,MAAM,GAAGM,IAAI,EAAG;MAC/BR,UAAU,GAAGA,UAAU,CAACW,MAAM,CAC7Bb,IAAI,CAACc,KAAK,CAAEZ,UAAU,CAACE,MAAM,EAAEM,IAAK,CACrC,CAAC;IACF;IACAE,UAAU,CAAEV,UAAW,CAAC;IAExB,MAAMa,UAAU,GAAGjB,WAAW,CAAC,CAAC;IAChC,KAAM,IAAIK,CAAC,GAAGD,UAAU,CAACE,MAAM,EAAED,CAAC,GAAGH,IAAI,CAACI,MAAM,EAAED,CAAC,IAAIO,IAAI,EAAG;MAC7DK,UAAU,CAACC,GAAG,CAAE,CAAC,CAAC,EAAE,MAAM;QACzBrB,SAAS,CAAE,MAAM;UAChBiB,UAAU,CAAIX,KAAK,IAAM,CACxB,GAAGA,KAAK,EACR,GAAGD,IAAI,CAACc,KAAK,CAAEX,CAAC,EAAEA,CAAC,GAAGO,IAAK,CAAC,CAC3B,CAAC;QACJ,CAAE,CAAC;MACJ,CAAE,CAAC;IACJ;IAEA,OAAO,MAAMK,UAAU,CAACE,KAAK,CAAC,CAAC;EAChC,CAAC,EAAE,CAAEjB,IAAI,CAAG,CAAC;EAEb,OAAOW,OAAO;AACf;AAEA,eAAeH,YAAY","ignoreList":[]}