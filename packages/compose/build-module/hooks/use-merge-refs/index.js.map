{"version":3,"names":["useRef","useCallback","useLayoutEffect","assignRef","ref","value","hasOwnProperty","current","useMergeRefs","refs","element","isAttachedRef","didElementChangeRef","previousRefsRef","currentRefsRef","forEach","index","previousRef","refsToAssign"],"sources":["@wordpress/compose/src/hooks/use-merge-refs/index.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { useRef, useCallback, useLayoutEffect } from '@wordpress/element';\r\n\r\n/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * @template T\r\n * @typedef {T extends import('react').Ref<infer R> ? R : never} TypeFromRef\r\n */\r\n/* eslint-enable jsdoc/valid-types */\r\n\r\n/**\r\n * @template T\r\n * @param {import('react').Ref<T>} ref\r\n * @param {T}                      value\r\n */\r\nfunction assignRef( ref, value ) {\r\n\tif ( typeof ref === 'function' ) {\r\n\t\tref( value );\r\n\t} else if ( ref && ref.hasOwnProperty( 'current' ) ) {\r\n\t\t/* eslint-disable jsdoc/no-undefined-types */\r\n\t\t/** @type {import('react').MutableRefObject<T>} */ ( ref ).current =\r\n\t\t\tvalue;\r\n\t\t/* eslint-enable jsdoc/no-undefined-types */\r\n\t}\r\n}\r\n\r\n/**\r\n * Merges refs into one ref callback.\r\n *\r\n * It also ensures that the merged ref callbacks are only called when they\r\n * change (as a result of a `useCallback` dependency update) OR when the ref\r\n * value changes, just as React does when passing a single ref callback to the\r\n * component.\r\n *\r\n * As expected, if you pass a new function on every render, the ref callback\r\n * will be called after every render.\r\n *\r\n * If you don't wish a ref callback to be called after every render, wrap it\r\n * with `useCallback( callback, dependencies )`. When a dependency changes, the\r\n * old ref callback will be called with `null` and the new ref callback will be\r\n * called with the same value.\r\n *\r\n * To make ref callbacks easier to use, you can also pass the result of\r\n * `useRefEffect`, which makes cleanup easier by allowing you to return a\r\n * cleanup function instead of handling `null`.\r\n *\r\n * It's also possible to _disable_ a ref (and its behaviour) by simply not\r\n * passing the ref.\r\n *\r\n * ```jsx\r\n * const ref = useRefEffect( ( node ) => {\r\n *   node.addEventListener( ... );\r\n *   return () => {\r\n *     node.removeEventListener( ... );\r\n *   };\r\n * }, [ ...dependencies ] );\r\n * const otherRef = useRef();\r\n * const mergedRefs useMergeRefs( [\r\n *   enabled && ref,\r\n *   otherRef,\r\n * ] );\r\n * return <div ref={ mergedRefs } />;\r\n * ```\r\n *\r\n * @template {import('react').Ref<any>} TRef\r\n * @param {Array<TRef>} refs The refs to be merged.\r\n *\r\n * @return {import('react').RefCallback<TypeFromRef<TRef>>} The merged ref callback.\r\n */\r\nexport default function useMergeRefs( refs ) {\r\n\tconst element = useRef();\r\n\tconst isAttachedRef = useRef( false );\r\n\tconst didElementChangeRef = useRef( false );\r\n\t/* eslint-disable jsdoc/no-undefined-types */\r\n\t/** @type {import('react').MutableRefObject<TRef[]>} */\r\n\t/* eslint-enable jsdoc/no-undefined-types */\r\n\tconst previousRefsRef = useRef( [] );\r\n\tconst currentRefsRef = useRef( refs );\r\n\r\n\t// Update on render before the ref callback is called, so the ref callback\r\n\t// always has access to the current refs.\r\n\tcurrentRefsRef.current = refs;\r\n\r\n\t// If any of the refs change, call the previous ref with `null` and the new\r\n\t// ref with the node, except when the element changes in the same cycle, in\r\n\t// which case the ref callbacks will already have been called.\r\n\tuseLayoutEffect( () => {\r\n\t\tif (\r\n\t\t\tdidElementChangeRef.current === false &&\r\n\t\t\tisAttachedRef.current === true\r\n\t\t) {\r\n\t\t\trefs.forEach( ( ref, index ) => {\r\n\t\t\t\tconst previousRef = previousRefsRef.current[ index ];\r\n\t\t\t\tif ( ref !== previousRef ) {\r\n\t\t\t\t\tassignRef( previousRef, null );\r\n\t\t\t\t\tassignRef( ref, element.current );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\tpreviousRefsRef.current = refs;\r\n\t}, refs );\r\n\r\n\t// No dependencies, must be reset after every render so ref callbacks are\r\n\t// correctly called after a ref change.\r\n\tuseLayoutEffect( () => {\r\n\t\tdidElementChangeRef.current = false;\r\n\t} );\r\n\r\n\t// There should be no dependencies so that `callback` is only called when\r\n\t// the node changes.\r\n\treturn useCallback( ( value ) => {\r\n\t\t// Update the element so it can be used when calling ref callbacks on a\r\n\t\t// dependency change.\r\n\t\tassignRef( element, value );\r\n\r\n\t\tdidElementChangeRef.current = true;\r\n\t\tisAttachedRef.current = value !== null;\r\n\r\n\t\t// When an element changes, the current ref callback should be called\r\n\t\t// with the new element and the previous one with `null`.\r\n\t\tconst refsToAssign = value\r\n\t\t\t? currentRefsRef.current\r\n\t\t\t: previousRefsRef.current;\r\n\r\n\t\t// Update the latest refs.\r\n\t\tfor ( const ref of refsToAssign ) {\r\n\t\t\tassignRef( ref, value );\r\n\t\t}\r\n\t}, [] );\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAM,EAAEC,WAAW,EAAEC,eAAe,QAAQ,oBAAoB;;AAEzE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAEC,GAAG,EAAEC,KAAK,EAAG;EAChC,IAAK,OAAOD,GAAG,KAAK,UAAU,EAAG;IAChCA,GAAG,CAAEC,KAAM,CAAC;EACb,CAAC,MAAM,IAAKD,GAAG,IAAIA,GAAG,CAACE,cAAc,CAAE,SAAU,CAAC,EAAG;IACpD;IACA,kDAAqDF,GAAG,CAAGG,OAAO,GACjEF,KAAK;IACN;EACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASG,YAAYA,CAAEC,IAAI,EAAG;EAC5C,MAAMC,OAAO,GAAGV,MAAM,CAAC,CAAC;EACxB,MAAMW,aAAa,GAAGX,MAAM,CAAE,KAAM,CAAC;EACrC,MAAMY,mBAAmB,GAAGZ,MAAM,CAAE,KAAM,CAAC;EAC3C;EACA;EACA;EACA,MAAMa,eAAe,GAAGb,MAAM,CAAE,EAAG,CAAC;EACpC,MAAMc,cAAc,GAAGd,MAAM,CAAES,IAAK,CAAC;;EAErC;EACA;EACAK,cAAc,CAACP,OAAO,GAAGE,IAAI;;EAE7B;EACA;EACA;EACAP,eAAe,CAAE,MAAM;IACtB,IACCU,mBAAmB,CAACL,OAAO,KAAK,KAAK,IACrCI,aAAa,CAACJ,OAAO,KAAK,IAAI,EAC7B;MACDE,IAAI,CAACM,OAAO,CAAE,CAAEX,GAAG,EAAEY,KAAK,KAAM;QAC/B,MAAMC,WAAW,GAAGJ,eAAe,CAACN,OAAO,CAAES,KAAK,CAAE;QACpD,IAAKZ,GAAG,KAAKa,WAAW,EAAG;UAC1Bd,SAAS,CAAEc,WAAW,EAAE,IAAK,CAAC;UAC9Bd,SAAS,CAAEC,GAAG,EAAEM,OAAO,CAACH,OAAQ,CAAC;QAClC;MACD,CAAE,CAAC;IACJ;IAEAM,eAAe,CAACN,OAAO,GAAGE,IAAI;EAC/B,CAAC,EAAEA,IAAK,CAAC;;EAET;EACA;EACAP,eAAe,CAAE,MAAM;IACtBU,mBAAmB,CAACL,OAAO,GAAG,KAAK;EACpC,CAAE,CAAC;;EAEH;EACA;EACA,OAAON,WAAW,CAAII,KAAK,IAAM;IAChC;IACA;IACAF,SAAS,CAAEO,OAAO,EAAEL,KAAM,CAAC;IAE3BO,mBAAmB,CAACL,OAAO,GAAG,IAAI;IAClCI,aAAa,CAACJ,OAAO,GAAGF,KAAK,KAAK,IAAI;;IAEtC;IACA;IACA,MAAMa,YAAY,GAAGb,KAAK,GACvBS,cAAc,CAACP,OAAO,GACtBM,eAAe,CAACN,OAAO;;IAE1B;IACA,KAAM,MAAMH,GAAG,IAAIc,YAAY,EAAG;MACjCf,SAAS,CAAEC,GAAG,EAAEC,KAAM,CAAC;IACxB;EACD,CAAC,EAAE,EAAG,CAAC;AACR","ignoreList":[]}