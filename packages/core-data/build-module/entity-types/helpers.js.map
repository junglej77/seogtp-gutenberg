{"version":3,"names":[],"sources":["@wordpress/core-data/src/entity-types/helpers.ts"],"sourcesContent":["/**\r\n * Internal dependencies\r\n */\r\nimport type { EntityRecord } from './index';\r\n\r\nexport interface AvatarUrls {\r\n\t/**\r\n\t * Avatar URL with image size of 24 pixels.\r\n\t */\r\n\t'24': string;\r\n\t/**\r\n\t * Avatar URL with image size of 48 pixels.\r\n\t */\r\n\t'48': string;\r\n\t/**\r\n\t * Avatar URL with image size of 96 pixels.\r\n\t */\r\n\t'96': string;\r\n}\r\n\r\nexport type MediaType = 'image' | 'file';\r\nexport type CommentingStatus = 'open' | 'closed';\r\nexport type PingStatus = 'open' | 'closed';\r\nexport type PostStatus = 'publish' | 'future' | 'draft' | 'pending' | 'private';\r\nexport type PostFormat =\r\n\t| 'standard'\r\n\t| 'aside'\r\n\t| 'chat'\r\n\t| 'gallery'\r\n\t| 'link'\r\n\t| 'image'\r\n\t| 'quote'\r\n\t| 'status'\r\n\t| 'video'\r\n\t| 'audio';\r\n\r\n/**\r\n * The REST API context parameter.\r\n */\r\nexport type Context = 'view' | 'edit' | 'embed';\r\n\r\n/**\r\n * ContextualField makes the field available only in the specified given contexts,\r\n * and ensure the field is absent from the object when in a different context.\r\n *\r\n * @example\r\n * ```ts\r\n * interface Post< C extends Context > {\r\n * \t…\r\n * \tmodified: ContextualField< string, 'edit' | 'view', C >;\r\n * \tpassword: ContextualField< string, 'edit', C >;\r\n * \t…\r\n * }\r\n *\r\n * const post: Post<'edit'> = …\r\n * // post.modified exists as a string\r\n * // post.password exists as a string\r\n *\r\n * const post: Post<'view'> = …\r\n * // post.modified still exists as a string\r\n * // post.password is missing, undefined, because we're not in the `edit` context.\r\n * ```\r\n */\r\nexport type ContextualField<\r\n\tFieldType,\r\n\tAvailableInContexts extends Context,\r\n\tC extends Context,\r\n> = AvailableInContexts extends C ? FieldType : never;\r\n\r\n/**\r\n * Removes all the properties of type never, even the deeply nested ones.\r\n *\r\n * @example\r\n * ```ts\r\n * type MyType = {\r\n *   foo: string;\r\n *   bar: never;\r\n *   nested: {\r\n *     foo: string;\r\n *     bar: never;\r\n *   }\r\n * }\r\n * const x = {} as OmitNevers<MyType>;\r\n * // x is of type { foo: string; nested: { foo: string; }}\r\n * // The `never` properties were removed entirely\r\n * ```\r\n */\r\nexport type OmitNevers<\r\n\tT,\r\n\tNevers = {\r\n\t\t[ K in keyof T ]: Exclude< T[ K ], undefined > extends never\r\n\t\t\t? never\r\n\t\t\t: T[ K ] extends Record< string, unknown >\r\n\t\t\t? OmitNevers< T[ K ] >\r\n\t\t\t: T[ K ];\r\n\t},\r\n> = Pick<\r\n\tNevers,\r\n\t{\r\n\t\t[ K in keyof Nevers ]: Nevers[ K ] extends never ? never : K;\r\n\t}[ keyof Nevers ]\r\n>;\r\n\r\n/**\r\n * A string that the server renders which often involves\r\n * modifications from the raw source string.\r\n *\r\n * For example, block HTML with the comment delimiters exists\r\n * in `post_content` but those comments are stripped out when\r\n * rendering to a page view. Similarly, plugins might modify\r\n * content or replace shortcodes.\r\n */\r\nexport interface RenderedText< C extends Context > {\r\n\t/**\r\n\t * The source string which will be rendered on page views.\r\n\t */\r\n\traw: ContextualField< string, 'edit', C >;\r\n\t/**\r\n\t * The output of the raw source after processing and filtering on the server.\r\n\t */\r\n\trendered: string;\r\n}\r\n\r\n/**\r\n * Updatable<EntityRecord> is a type describing Edited Entity Records. They are like\r\n * regular Entity Records, but they have all the local edits applied on top of the REST API data.\r\n *\r\n * This turns certain field from an object into a string.\r\n *\r\n * Entities like Post have fields that only be rendered on the server, like title, excerpt,\r\n * and content. The REST API exposes both the raw markup and the rendered version of those fields.\r\n * For example, in the block editor, content.rendered could used as a visual preview, and\r\n * content.raw could be used to populate the code editor.\r\n *\r\n * When updating these rendered fields, JavaScript is not be able to properly render arbitrary block\r\n * markup. Therefore, it stores only the raw markup without the rendered part. And since that's a string,\r\n * the entire field becomes a string.\r\n *\r\n * @example\r\n * ```ts\r\n * type Post< C extends Context > {\r\n *   title: RenderedText< C >;\r\n * }\r\n * const post = {} as Post;\r\n * // post.title is an object with raw and rendered properties\r\n *\r\n * const updatablePost = {} as Updatable< Post >;\r\n * // updatablePost.title is a string\r\n * ```\r\n */\r\nexport type Updatable< T extends EntityRecord< 'edit' > > = {\r\n\t[ K in keyof T ]: T[ K ] extends RenderedText< any > ? string : T[ K ];\r\n};\r\n"],"mappings":"","ignoreList":[]}