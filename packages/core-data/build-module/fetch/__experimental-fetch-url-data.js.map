{"version":3,"names":["apiFetch","addQueryArgs","prependHTTP","isURL","getProtocol","isValidProtocol","CACHE","Map","fetchUrlData","url","options","endpoint","args","Promise","reject","protocol","startsWith","test","has","get","path","then","res","set"],"sources":["@wordpress/core-data/src/fetch/__experimental-fetch-url-data.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport apiFetch from '@wordpress/api-fetch';\r\nimport {\r\n\taddQueryArgs,\r\n\tprependHTTP,\r\n\tisURL,\r\n\tgetProtocol,\r\n\tisValidProtocol,\r\n} from '@wordpress/url';\r\n\r\n/**\r\n * A simple in-memory cache for requests.\r\n * This avoids repeat HTTP requests which may be beneficial\r\n * for those wishing to preserve low-bandwidth.\r\n */\r\nconst CACHE = new Map();\r\n\r\n/**\r\n * @typedef WPRemoteUrlData\r\n *\r\n * @property {string} title contents of the remote URL's `<title>` tag.\r\n */\r\n\r\n/**\r\n * Fetches data about a remote URL.\r\n * eg: <title> tag, favicon...etc.\r\n *\r\n * @async\r\n * @param {string}  url     the URL to request details from.\r\n * @param {Object?} options any options to pass to the underlying fetch.\r\n * @example\r\n * ```js\r\n * import { __experimentalFetchUrlData as fetchUrlData } from '@wordpress/core-data';\r\n *\r\n * //...\r\n *\r\n * export function initialize( id, settings ) {\r\n *\r\n * settings.__experimentalFetchUrlData = (\r\n * url\r\n * ) => fetchUrlData( url );\r\n * ```\r\n * @return {Promise< WPRemoteUrlData[] >} Remote URL data.\r\n */\r\nconst fetchUrlData = async ( url, options = {} ) => {\r\n\tconst endpoint = '/wp-block-editor/v1/url-details';\r\n\r\n\tconst args = {\r\n\t\turl: prependHTTP( url ),\r\n\t};\r\n\r\n\tif ( ! isURL( url ) ) {\r\n\t\treturn Promise.reject( `${ url } is not a valid URL.` );\r\n\t}\r\n\r\n\t// Test for \"http\" based URL as it is possible for valid\r\n\t// yet unusable URLs such as `tel:123456` to be passed.\r\n\tconst protocol = getProtocol( url );\r\n\r\n\tif (\r\n\t\t! protocol ||\r\n\t\t! isValidProtocol( protocol ) ||\r\n\t\t! protocol.startsWith( 'http' ) ||\r\n\t\t! /^https?:\\/\\/[^\\/\\s]/i.test( url )\r\n\t) {\r\n\t\treturn Promise.reject(\r\n\t\t\t`${ url } does not have a valid protocol. URLs must be \"http\" based`\r\n\t\t);\r\n\t}\r\n\r\n\tif ( CACHE.has( url ) ) {\r\n\t\treturn CACHE.get( url );\r\n\t}\r\n\r\n\treturn apiFetch( {\r\n\t\tpath: addQueryArgs( endpoint, args ),\r\n\t\t...options,\r\n\t} ).then( ( res ) => {\r\n\t\tCACHE.set( url, res );\r\n\t\treturn res;\r\n\t} );\r\n};\r\n\r\nexport default fetchUrlData;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,sBAAsB;AAC3C,SACCC,YAAY,EACZC,WAAW,EACXC,KAAK,EACLC,WAAW,EACXC,eAAe,QACT,gBAAgB;;AAEvB;AACA;AACA;AACA;AACA;AACA,MAAMC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAG,MAAAA,CAAQC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAM;EACnD,MAAMC,QAAQ,GAAG,iCAAiC;EAElD,MAAMC,IAAI,GAAG;IACZH,GAAG,EAAEP,WAAW,CAAEO,GAAI;EACvB,CAAC;EAED,IAAK,CAAEN,KAAK,CAAEM,GAAI,CAAC,EAAG;IACrB,OAAOI,OAAO,CAACC,MAAM,CAAG,GAAGL,GAAK,sBAAsB,CAAC;EACxD;;EAEA;EACA;EACA,MAAMM,QAAQ,GAAGX,WAAW,CAAEK,GAAI,CAAC;EAEnC,IACC,CAAEM,QAAQ,IACV,CAAEV,eAAe,CAAEU,QAAS,CAAC,IAC7B,CAAEA,QAAQ,CAACC,UAAU,CAAE,MAAO,CAAC,IAC/B,CAAE,sBAAsB,CAACC,IAAI,CAAER,GAAI,CAAC,EACnC;IACD,OAAOI,OAAO,CAACC,MAAM,CACnB,GAAGL,GAAK,4DACV,CAAC;EACF;EAEA,IAAKH,KAAK,CAACY,GAAG,CAAET,GAAI,CAAC,EAAG;IACvB,OAAOH,KAAK,CAACa,GAAG,CAAEV,GAAI,CAAC;EACxB;EAEA,OAAOT,QAAQ,CAAE;IAChBoB,IAAI,EAAEnB,YAAY,CAAEU,QAAQ,EAAEC,IAAK,CAAC;IACpC,GAAGF;EACJ,CAAE,CAAC,CAACW,IAAI,CAAIC,GAAG,IAAM;IACpBhB,KAAK,CAACiB,GAAG,CAAEd,GAAG,EAAEa,GAAI,CAAC;IACrB,OAAOA,GAAG;EACX,CAAE,CAAC;AACJ,CAAC;AAED,eAAed,YAAY","ignoreList":[]}