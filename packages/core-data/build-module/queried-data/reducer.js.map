{"version":3,"names":["combineReducers","compose","conservativeMapItem","ifMatchingAction","replaceAction","onSubKey","DEFAULT_ENTITY_KEY","getQueryParts","getContextFromAction","action","query","queryParts","context","getMergedItemIds","itemIds","nextItemIds","page","perPage","_itemIds$length","receivedAllIds","nextItemIdsStartIndex","size","Math","max","length","mergedItemIds","Array","i","isInNextItemsRange","removeEntitiesById","entities","ids","Object","fromEntries","entries","filter","id","some","itemId","Number","isInteger","items","state","type","key","reduce","accumulator","value","map","contextState","itemIsComplete","isCompleteQuery","isArray","fields","result","item","receiveQueries","Boolean","meta","queries","removedItems","queryGroup","contextQueries","queryItems","queryId"],"sources":["@wordpress/core-data/src/queried-data/reducer.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { combineReducers } from '@wordpress/data';\r\nimport { compose } from '@wordpress/compose';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport {\r\n\tconservativeMapItem,\r\n\tifMatchingAction,\r\n\treplaceAction,\r\n\tonSubKey,\r\n} from '../utils';\r\nimport { DEFAULT_ENTITY_KEY } from '../entities';\r\nimport getQueryParts from './get-query-parts';\r\n\r\nfunction getContextFromAction( action ) {\r\n\tconst { query } = action;\r\n\tif ( ! query ) {\r\n\t\treturn 'default';\r\n\t}\r\n\r\n\tconst queryParts = getQueryParts( query );\r\n\treturn queryParts.context;\r\n}\r\n\r\n/**\r\n * Returns a merged array of item IDs, given details of the received paginated\r\n * items. The array is sparse-like with `undefined` entries where holes exist.\r\n *\r\n * @param {?Array<number>} itemIds     Original item IDs (default empty array).\r\n * @param {number[]}       nextItemIds Item IDs to merge.\r\n * @param {number}         page        Page of items merged.\r\n * @param {number}         perPage     Number of items per page.\r\n *\r\n * @return {number[]} Merged array of item IDs.\r\n */\r\nexport function getMergedItemIds( itemIds, nextItemIds, page, perPage ) {\r\n\tconst receivedAllIds = page === 1 && perPage === -1;\r\n\tif ( receivedAllIds ) {\r\n\t\treturn nextItemIds;\r\n\t}\r\n\tconst nextItemIdsStartIndex = ( page - 1 ) * perPage;\r\n\r\n\t// If later page has already been received, default to the larger known\r\n\t// size of the existing array, else calculate as extending the existing.\r\n\tconst size = Math.max(\r\n\t\titemIds?.length ?? 0,\r\n\t\tnextItemIdsStartIndex + nextItemIds.length\r\n\t);\r\n\r\n\t// Preallocate array since size is known.\r\n\tconst mergedItemIds = new Array( size );\r\n\r\n\tfor ( let i = 0; i < size; i++ ) {\r\n\t\t// Preserve existing item ID except for subset of range of next items.\r\n\t\t// We need to check against the possible maximum upper boundary because\r\n\t\t// a page could receive fewer than what was previously stored.\r\n\t\tconst isInNextItemsRange =\r\n\t\t\ti >= nextItemIdsStartIndex && i < nextItemIdsStartIndex + perPage;\r\n\t\tmergedItemIds[ i ] = isInNextItemsRange\r\n\t\t\t? nextItemIds[ i - nextItemIdsStartIndex ]\r\n\t\t\t: itemIds?.[ i ];\r\n\t}\r\n\r\n\treturn mergedItemIds;\r\n}\r\n\r\n/**\r\n * Helper function to filter out entities with certain IDs.\r\n * Entities are keyed by their ID.\r\n *\r\n * @param {Object} entities Entity objects, keyed by entity ID.\r\n * @param {Array}  ids      Entity IDs to filter out.\r\n *\r\n * @return {Object} Filtered entities.\r\n */\r\nfunction removeEntitiesById( entities, ids ) {\r\n\treturn Object.fromEntries(\r\n\t\tObject.entries( entities ).filter(\r\n\t\t\t( [ id ] ) =>\r\n\t\t\t\t! ids.some( ( itemId ) => {\r\n\t\t\t\t\tif ( Number.isInteger( itemId ) ) {\r\n\t\t\t\t\t\treturn itemId === +id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn itemId === id;\r\n\t\t\t\t} )\r\n\t\t)\r\n\t);\r\n}\r\n\r\n/**\r\n * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\r\n * where identifiers are common across all queries.\r\n *\r\n * @param {Object} state  Current state.\r\n * @param {Object} action Dispatched action.\r\n *\r\n * @return {Object} Next state.\r\n */\r\nexport function items( state = {}, action ) {\r\n\tswitch ( action.type ) {\r\n\t\tcase 'RECEIVE_ITEMS': {\r\n\t\t\tconst context = getContextFromAction( action );\r\n\t\t\tconst key = action.key || DEFAULT_ENTITY_KEY;\r\n\t\t\treturn {\r\n\t\t\t\t...state,\r\n\t\t\t\t[ context ]: {\r\n\t\t\t\t\t...state[ context ],\r\n\t\t\t\t\t...action.items.reduce( ( accumulator, value ) => {\r\n\t\t\t\t\t\tconst itemId = value?.[ key ];\r\n\r\n\t\t\t\t\t\taccumulator[ itemId ] = conservativeMapItem(\r\n\t\t\t\t\t\t\tstate?.[ context ]?.[ itemId ],\r\n\t\t\t\t\t\t\tvalue\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn accumulator;\r\n\t\t\t\t\t}, {} ),\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t}\r\n\t\tcase 'REMOVE_ITEMS':\r\n\t\t\treturn Object.fromEntries(\r\n\t\t\t\tObject.entries( state ).map( ( [ itemId, contextState ] ) => [\r\n\t\t\t\t\titemId,\r\n\t\t\t\t\tremoveEntitiesById( contextState, action.itemIds ),\r\n\t\t\t\t] )\r\n\t\t\t);\r\n\t}\r\n\treturn state;\r\n}\r\n\r\n/**\r\n * Reducer tracking item completeness, keyed by ID. A complete item is one for\r\n * which all fields are known. This is used in supporting `_fields` queries,\r\n * where not all properties associated with an entity are necessarily returned.\r\n * In such cases, completeness is used as an indication of whether it would be\r\n * safe to use queried data for a non-`_fields`-limited request.\r\n *\r\n * @param {Object<string,Object<string,boolean>>} state  Current state.\r\n * @param {Object}                                action Dispatched action.\r\n *\r\n * @return {Object<string,Object<string,boolean>>} Next state.\r\n */\r\nexport function itemIsComplete( state = {}, action ) {\r\n\tswitch ( action.type ) {\r\n\t\tcase 'RECEIVE_ITEMS': {\r\n\t\t\tconst context = getContextFromAction( action );\r\n\t\t\tconst { query, key = DEFAULT_ENTITY_KEY } = action;\r\n\r\n\t\t\t// An item is considered complete if it is received without an associated\r\n\t\t\t// fields query. Ideally, this would be implemented in such a way where the\r\n\t\t\t// complete aggregate of all fields would satisfy completeness. Since the\r\n\t\t\t// fields are not consistent across all entities, this would require\r\n\t\t\t// introspection on the REST schema for each entity to know which fields\r\n\t\t\t// compose a complete item for that entity.\r\n\t\t\tconst queryParts = query ? getQueryParts( query ) : {};\r\n\t\t\tconst isCompleteQuery =\r\n\t\t\t\t! query || ! Array.isArray( queryParts.fields );\r\n\r\n\t\t\treturn {\r\n\t\t\t\t...state,\r\n\t\t\t\t[ context ]: {\r\n\t\t\t\t\t...state[ context ],\r\n\t\t\t\t\t...action.items.reduce( ( result, item ) => {\r\n\t\t\t\t\t\tconst itemId = item?.[ key ];\r\n\r\n\t\t\t\t\t\t// Defer to completeness if already assigned. Technically the\r\n\t\t\t\t\t\t// data may be outdated if receiving items for a field subset.\r\n\t\t\t\t\t\tresult[ itemId ] =\r\n\t\t\t\t\t\t\tstate?.[ context ]?.[ itemId ] || isCompleteQuery;\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t}, {} ),\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t}\r\n\t\tcase 'REMOVE_ITEMS':\r\n\t\t\treturn Object.fromEntries(\r\n\t\t\t\tObject.entries( state ).map( ( [ itemId, contextState ] ) => [\r\n\t\t\t\t\titemId,\r\n\t\t\t\t\tremoveEntitiesById( contextState, action.itemIds ),\r\n\t\t\t\t] )\r\n\t\t\t);\r\n\t}\r\n\r\n\treturn state;\r\n}\r\n\r\n/**\r\n * Reducer tracking queries state, keyed by stable query key. Each reducer\r\n * query object includes `itemIds` and `requestingPageByPerPage`.\r\n *\r\n * @param {Object} state  Current state.\r\n * @param {Object} action Dispatched action.\r\n *\r\n * @return {Object} Next state.\r\n */\r\nconst receiveQueries = compose( [\r\n\t// Limit to matching action type so we don't attempt to replace action on\r\n\t// an unhandled action.\r\n\tifMatchingAction( ( action ) => 'query' in action ),\r\n\r\n\t// Inject query parts into action for use both in `onSubKey` and reducer.\r\n\treplaceAction( ( action ) => {\r\n\t\t// `ifMatchingAction` still passes on initialization, where state is\r\n\t\t// undefined and a query is not assigned. Avoid attempting to parse\r\n\t\t// parts. `onSubKey` will omit by lack of `stableKey`.\r\n\t\tif ( action.query ) {\r\n\t\t\treturn {\r\n\t\t\t\t...action,\r\n\t\t\t\t...getQueryParts( action.query ),\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn action;\r\n\t} ),\r\n\r\n\tonSubKey( 'context' ),\r\n\r\n\t// Queries shape is shared, but keyed by query `stableKey` part. Original\r\n\t// reducer tracks only a single query object.\r\n\tonSubKey( 'stableKey' ),\r\n] )( ( state = {}, action ) => {\r\n\tconst { type, page, perPage, key = DEFAULT_ENTITY_KEY } = action;\r\n\r\n\tif ( type !== 'RECEIVE_ITEMS' ) {\r\n\t\treturn state;\r\n\t}\r\n\r\n\treturn {\r\n\t\titemIds: getMergedItemIds(\r\n\t\t\tstate?.itemIds || [],\r\n\t\t\taction.items.map( ( item ) => item?.[ key ] ).filter( Boolean ),\r\n\t\t\tpage,\r\n\t\t\tperPage\r\n\t\t),\r\n\t\tmeta: action.meta,\r\n\t};\r\n} );\r\n\r\n/**\r\n * Reducer tracking queries state.\r\n *\r\n * @param {Object} state  Current state.\r\n * @param {Object} action Dispatched action.\r\n *\r\n * @return {Object} Next state.\r\n */\r\nconst queries = ( state = {}, action ) => {\r\n\tswitch ( action.type ) {\r\n\t\tcase 'RECEIVE_ITEMS':\r\n\t\t\treturn receiveQueries( state, action );\r\n\t\tcase 'REMOVE_ITEMS':\r\n\t\t\tconst removedItems = action.itemIds.reduce( ( result, itemId ) => {\r\n\t\t\t\tresult[ itemId ] = true;\r\n\t\t\t\treturn result;\r\n\t\t\t}, {} );\r\n\r\n\t\t\treturn Object.fromEntries(\r\n\t\t\t\tObject.entries( state ).map(\r\n\t\t\t\t\t( [ queryGroup, contextQueries ] ) => [\r\n\t\t\t\t\t\tqueryGroup,\r\n\t\t\t\t\t\tObject.fromEntries(\r\n\t\t\t\t\t\t\tObject.entries( contextQueries ).map(\r\n\t\t\t\t\t\t\t\t( [ query, queryItems ] ) => [\r\n\t\t\t\t\t\t\t\t\tquery,\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t...queryItems,\r\n\t\t\t\t\t\t\t\t\t\titemIds: queryItems.itemIds.filter(\r\n\t\t\t\t\t\t\t\t\t\t\t( queryId ) =>\r\n\t\t\t\t\t\t\t\t\t\t\t\t! removedItems[ queryId ]\r\n\t\t\t\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t]\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\tdefault:\r\n\t\t\treturn state;\r\n\t}\r\n};\r\n\r\nexport default combineReducers( {\r\n\titems,\r\n\titemIsComplete,\r\n\tqueries,\r\n} );\r\n"],"mappings":"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","ignoreList":[]}