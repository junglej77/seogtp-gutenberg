{"version":3,"names":["createQueue","useRef","useCallback","useMemo","useSyncExternalStore","useDebugValue","isShallowEqual","useRegistry","useAsyncMode","renderQueue","Store","registry","suspense","select","suspendSelect","queueContext","lastMapSelect","lastMapResult","lastMapResultValid","lastIsAsync","subscriber","didWarnUnstableReference","storeStatesOnMount","Map","getStoreState","name","_registry$stores$name","stores","store","getState","createSubscriber","activeStores","activeSubscriptions","Set","subscribe","listener","get","clear","onStoreChange","onChange","add","unsubs","subscribeStore","storeName","push","delete","unsub","values","cancel","updateStores","newStores","newStore","includes","subscription","mapSelect","isAsync","updateValue","listeningStores","current","mapResult","__unstableMarkListeningStores","process","env","NODE_ENV","secondMapResult","console","warn","set","getValue","useStaticSelect","useMappingSelect","deps","selector","result","useSelect","staticSelectMode","staticSelectModeRef","prevMode","nextMode","Error","useSuspenseSelect"],"sources":["D:/jungle/gutenberg/packages/data/src/components/use-select/index.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { createQueue } from '@wordpress/priority-queue';\r\nimport {\r\n\tuseRef,\r\n\tuseCallback,\r\n\tuseMemo,\r\n\tuseSyncExternalStore,\r\n\tuseDebugValue,\r\n} from '@wordpress/element';\r\nimport isShallowEqual from '@wordpress/is-shallow-equal';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport useRegistry from '../registry-provider/use-registry';\r\nimport useAsyncMode from '../async-mode-provider/use-async-mode';\r\n\r\nconst renderQueue = createQueue();\r\n\r\n/**\r\n * @typedef {import('../../types').StoreDescriptor<C>} StoreDescriptor\r\n * @template {import('../../types').AnyConfig} C\r\n */\r\n/**\r\n * @typedef {import('../../types').ReduxStoreConfig<State,Actions,Selectors>} ReduxStoreConfig\r\n * @template State\r\n * @template {Record<string,import('../../types').ActionCreator>} Actions\r\n * @template Selectors\r\n */\r\n/** @typedef {import('../../types').MapSelect} MapSelect */\r\n/**\r\n * @typedef {import('../../types').UseSelectReturn<T>} UseSelectReturn\r\n * @template {MapSelect|StoreDescriptor<any>} T\r\n */\r\n\r\nfunction Store( registry, suspense ) {\r\n\tconst select = suspense ? registry.suspendSelect : registry.select;\r\n\tconst queueContext = {};\r\n\tlet lastMapSelect;\r\n\tlet lastMapResult;\r\n\tlet lastMapResultValid = false;\r\n\tlet lastIsAsync;\r\n\tlet subscriber;\r\n\tlet didWarnUnstableReference;\r\n\tconst storeStatesOnMount = new Map();\r\n\r\n\tfunction getStoreState( name ) {\r\n\t\t// If there's no store property (custom generic store), return an empty\r\n\t\t// object. When comparing the state, the empty objects will cause the\r\n\t\t// equality check to fail, setting `lastMapResultValid` to false.\r\n\t\treturn registry.stores[ name ]?.store?.getState?.() ?? {};\r\n\t}\r\n\r\n\tconst createSubscriber = ( stores ) => {\r\n\t\t// The set of stores the `subscribe` function is supposed to subscribe to. Here it is\r\n\t\t// initialized, and then the `updateStores` function can add new stores to it.\r\n\t\tconst activeStores = [ ...stores ];\r\n\r\n\t\t// The `subscribe` function, which is passed to the `useSyncExternalStore` hook, could\r\n\t\t// be called multiple times to establish multiple subscriptions. That's why we need to\r\n\t\t// keep a set of active subscriptions;\r\n\t\tconst activeSubscriptions = new Set();\r\n\r\n\t\tfunction subscribe( listener ) {\r\n\t\t\t// Maybe invalidate the value right after subscription was created.\r\n\t\t\t// React will call `getValue` after subscribing, to detect store\r\n\t\t\t// updates that happened in the interval between the `getValue` call\r\n\t\t\t// during render and creating the subscription, which is slightly\r\n\t\t\t// delayed. We need to ensure that this second `getValue` call will\r\n\t\t\t// compute a fresh value only if any of the store states have\r\n\t\t\t// changed in the meantime.\r\n\t\t\tif ( lastMapResultValid ) {\r\n\t\t\t\tfor ( const name of activeStores ) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tstoreStatesOnMount.get( name ) !== getStoreState( name )\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlastMapResultValid = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tstoreStatesOnMount.clear();\r\n\r\n\t\t\tconst onStoreChange = () => {\r\n\t\t\t\t// Invalidate the value on store update, so that a fresh value is computed.\r\n\t\t\t\tlastMapResultValid = false;\r\n\t\t\t\tlistener();\r\n\t\t\t};\r\n\r\n\t\t\tconst onChange = () => {\r\n\t\t\t\tif ( lastIsAsync ) {\r\n\t\t\t\t\trenderQueue.add( queueContext, onStoreChange );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tonStoreChange();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tconst unsubs = [];\r\n\t\t\tfunction subscribeStore( storeName ) {\r\n\t\t\t\tunsubs.push( registry.subscribe( onChange, storeName ) );\r\n\t\t\t}\r\n\r\n\t\t\tfor ( const storeName of activeStores ) {\r\n\t\t\t\tsubscribeStore( storeName );\r\n\t\t\t}\r\n\r\n\t\t\tactiveSubscriptions.add( subscribeStore );\r\n\r\n\t\t\treturn () => {\r\n\t\t\t\tactiveSubscriptions.delete( subscribeStore );\r\n\r\n\t\t\t\tfor ( const unsub of unsubs.values() ) {\r\n\t\t\t\t\t// The return value of the subscribe function could be undefined if the store is a custom generic store.\r\n\t\t\t\t\tunsub?.();\r\n\t\t\t\t}\r\n\t\t\t\t// Cancel existing store updates that were already scheduled.\r\n\t\t\t\trenderQueue.cancel( queueContext );\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Check if `newStores` contains some stores we're not subscribed to yet, and add them.\r\n\t\tfunction updateStores( newStores ) {\r\n\t\t\tfor ( const newStore of newStores ) {\r\n\t\t\t\tif ( activeStores.includes( newStore ) ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// New `subscribe` calls will subscribe to `newStore`, too.\r\n\t\t\t\tactiveStores.push( newStore );\r\n\r\n\t\t\t\t// Add `newStore` to existing subscriptions.\r\n\t\t\t\tfor ( const subscription of activeSubscriptions ) {\r\n\t\t\t\t\tsubscription( newStore );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { subscribe, updateStores };\r\n\t};\r\n\r\n\treturn ( mapSelect, isAsync ) => {\r\n\t\tfunction updateValue() {\r\n\t\t\t// If the last value is valid, and the `mapSelect` callback hasn't changed,\r\n\t\t\t// then we can safely return the cached value. The value can change only on\r\n\t\t\t// store update, and in that case value will be invalidated by the listener.\r\n\t\t\tif ( lastMapResultValid && mapSelect === lastMapSelect ) {\r\n\t\t\t\treturn lastMapResult;\r\n\t\t\t}\r\n\r\n\t\t\tconst listeningStores = { current: null };\r\n\t\t\tconst mapResult = registry.__unstableMarkListeningStores(\r\n\t\t\t\t() => mapSelect( select, registry ),\r\n\t\t\t\tlisteningStores\r\n\t\t\t);\r\n\r\n\t\t\tif ( process.env.NODE_ENV === 'development' ) {\r\n\t\t\t\tif ( ! didWarnUnstableReference ) {\r\n\t\t\t\t\tconst secondMapResult = mapSelect( select, registry );\r\n\t\t\t\t\tif ( ! isShallowEqual( mapResult, secondMapResult ) ) {\r\n\t\t\t\t\t\t// eslint-disable-next-line no-console\r\n\t\t\t\t\t\tconsole.warn(\r\n\t\t\t\t\t\t\t`The 'useSelect' hook returns different values when called with the same state and parameters. This can lead to unnecessary rerenders.`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tdidWarnUnstableReference = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! subscriber ) {\r\n\t\t\t\tfor ( const name of listeningStores.current ) {\r\n\t\t\t\t\tstoreStatesOnMount.set( name, getStoreState( name ) );\r\n\t\t\t\t}\r\n\t\t\t\tsubscriber = createSubscriber( listeningStores.current );\r\n\t\t\t} else {\r\n\t\t\t\tsubscriber.updateStores( listeningStores.current );\r\n\t\t\t}\r\n\r\n\t\t\t// If the new value is shallow-equal to the old one, keep the old one so\r\n\t\t\t// that we don't trigger unwanted updates that do a `===` check.\r\n\t\t\tif ( ! isShallowEqual( lastMapResult, mapResult ) ) {\r\n\t\t\t\tlastMapResult = mapResult;\r\n\t\t\t}\r\n\t\t\tlastMapSelect = mapSelect;\r\n\t\t\tlastMapResultValid = true;\r\n\t\t}\r\n\r\n\t\tfunction getValue() {\r\n\t\t\t// Update the value in case it's been invalidated or `mapSelect` has changed.\r\n\t\t\tupdateValue();\r\n\t\t\treturn lastMapResult;\r\n\t\t}\r\n\r\n\t\t// When transitioning from async to sync mode, cancel existing store updates\r\n\t\t// that have been scheduled, and invalidate the value so that it's freshly\r\n\t\t// computed. It might have been changed by the update we just cancelled.\r\n\t\tif ( lastIsAsync && ! isAsync ) {\r\n\t\t\tlastMapResultValid = false;\r\n\t\t\trenderQueue.cancel( queueContext );\r\n\t\t}\r\n\r\n\t\tupdateValue();\r\n\r\n\t\tlastIsAsync = isAsync;\r\n\r\n\t\t// Return a pair of functions that can be passed to `useSyncExternalStore`.\r\n\t\treturn { subscribe: subscriber.subscribe, getValue };\r\n\t};\r\n}\r\n\r\nfunction useStaticSelect( storeName ) {\r\n\treturn useRegistry().select( storeName );\r\n}\r\n\r\nfunction useMappingSelect( suspense, mapSelect, deps ) {\r\n\tconst registry = useRegistry();\r\n\tconst isAsync = useAsyncMode();\r\n\tconst store = useMemo(\r\n\t\t() => Store( registry, suspense ),\r\n\t\t[ registry, suspense ]\r\n\t);\r\n\r\n\t// These are \"pass-through\" dependencies from the parent hook,\r\n\t// and the parent should catch any hook rule violations.\r\n\t// eslint-disable-next-line react-hooks/exhaustive-deps\r\n\tconst selector = useCallback( mapSelect, deps );\r\n\tconst { subscribe, getValue } = store( selector, isAsync );\r\n\tconst result = useSyncExternalStore( subscribe, getValue, getValue );\r\n\tuseDebugValue( result );\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Custom react hook for retrieving props from registered selectors.\r\n *\r\n * In general, this custom React hook follows the\r\n * [rules of hooks](https://react.dev/reference/rules/rules-of-hooks).\r\n *\r\n * @template {MapSelect | StoreDescriptor<any>} T\r\n * @param {T}         mapSelect Function called on every state change. The returned value is\r\n *                              exposed to the component implementing this hook. The function\r\n *                              receives the `registry.select` method on the first argument\r\n *                              and the `registry` on the second argument.\r\n *                              When a store key is passed, all selectors for the store will be\r\n *                              returned. This is only meant for usage of these selectors in event\r\n *                              callbacks, not for data needed to create the element tree.\r\n * @param {unknown[]} deps      If provided, this memoizes the mapSelect so the same `mapSelect` is\r\n *                              invoked on every state change unless the dependencies change.\r\n *\r\n * @example\r\n * ```js\r\n * import { useSelect } from '@wordpress/data';\r\n * import { store as myCustomStore } from 'my-custom-store';\r\n *\r\n * function HammerPriceDisplay( { currency } ) {\r\n *   const price = useSelect( ( select ) => {\r\n *     return select( myCustomStore ).getPrice( 'hammer', currency );\r\n *   }, [ currency ] );\r\n *   return new Intl.NumberFormat( 'en-US', {\r\n *     style: 'currency',\r\n *     currency,\r\n *   } ).format( price );\r\n * }\r\n *\r\n * // Rendered in the application:\r\n * // <HammerPriceDisplay currency=\"USD\" />\r\n * ```\r\n *\r\n * In the above example, when `HammerPriceDisplay` is rendered into an\r\n * application, the price will be retrieved from the store state using the\r\n * `mapSelect` callback on `useSelect`. If the currency prop changes then\r\n * any price in the state for that currency is retrieved. If the currency prop\r\n * doesn't change and other props are passed in that do change, the price will\r\n * not change because the dependency is just the currency.\r\n *\r\n * When data is only used in an event callback, the data should not be retrieved\r\n * on render, so it may be useful to get the selectors function instead.\r\n *\r\n * **Don't use `useSelect` this way when calling the selectors in the render\r\n * function because your component won't re-render on a data change.**\r\n *\r\n * ```js\r\n * import { useSelect } from '@wordpress/data';\r\n * import { store as myCustomStore } from 'my-custom-store';\r\n *\r\n * function Paste( { children } ) {\r\n *   const { getSettings } = useSelect( myCustomStore );\r\n *   function onPaste() {\r\n *     // Do something with the settings.\r\n *     const settings = getSettings();\r\n *   }\r\n *   return <div onPaste={ onPaste }>{ children }</div>;\r\n * }\r\n * ```\r\n * @return {UseSelectReturn<T>} A custom react hook.\r\n */\r\nexport default function useSelect( mapSelect, deps ) {\r\n\t// On initial call, on mount, determine the mode of this `useSelect` call\r\n\t// and then never allow it to change on subsequent updates.\r\n\tconst staticSelectMode = typeof mapSelect !== 'function';\r\n\tconst staticSelectModeRef = useRef( staticSelectMode );\r\n\r\n\tif ( staticSelectMode !== staticSelectModeRef.current ) {\r\n\t\tconst prevMode = staticSelectModeRef.current ? 'static' : 'mapping';\r\n\t\tconst nextMode = staticSelectMode ? 'static' : 'mapping';\r\n\t\tthrow new Error(\r\n\t\t\t`Switching useSelect from ${ prevMode } to ${ nextMode } is not allowed`\r\n\t\t);\r\n\t}\r\n\r\n\t/* eslint-disable react-hooks/rules-of-hooks */\r\n\t// `staticSelectMode` is not allowed to change during the hook instance's,\r\n\t// lifetime, so the rules of hooks are not really violated.\r\n\treturn staticSelectMode\r\n\t\t? useStaticSelect( mapSelect )\r\n\t\t: useMappingSelect( false, mapSelect, deps );\r\n\t/* eslint-enable react-hooks/rules-of-hooks */\r\n}\r\n\r\n/**\r\n * A variant of the `useSelect` hook that has the same API, but is a compatible\r\n * Suspense-enabled data source.\r\n *\r\n * @template {MapSelect} T\r\n * @param {T}     mapSelect Function called on every state change. The\r\n *                          returned value is exposed to the component\r\n *                          using this hook. The function receives the\r\n *                          `registry.suspendSelect` method as the first\r\n *                          argument and the `registry` as the second one.\r\n * @param {Array} deps      A dependency array used to memoize the `mapSelect`\r\n *                          so that the same `mapSelect` is invoked on every\r\n *                          state change unless the dependencies change.\r\n *\r\n * @throws {Promise} A suspense Promise that is thrown if any of the called\r\n * selectors is in an unresolved state.\r\n *\r\n * @return {ReturnType<T>} Data object returned by the `mapSelect` function.\r\n */\r\nexport function useSuspenseSelect( mapSelect, deps ) {\r\n\treturn useMappingSelect( true, mapSelect, deps );\r\n}\r\n"],"mappings":"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","ignoreList":[]}