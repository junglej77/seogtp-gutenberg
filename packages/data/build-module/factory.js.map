{"version":3,"names":["createRegistrySelector","registrySelector","selectorsByRegistry","WeakMap","wrappedSelector","args","selector","get","registry","select","set","isRegistrySelector","createRegistryControl","registryControl","isRegistryControl"],"sources":["@wordpress/data/src/factory.js"],"sourcesContent":["/**\r\n * Creates a selector function that takes additional curried argument with the\r\n * registry `select` function. While a regular selector has signature\r\n * ```js\r\n * ( state, ...selectorArgs ) => ( result )\r\n * ```\r\n * that allows to select data from the store's `state`, a registry selector\r\n * has signature:\r\n * ```js\r\n * ( select ) => ( state, ...selectorArgs ) => ( result )\r\n * ```\r\n * that supports also selecting from other registered stores.\r\n *\r\n * @example\r\n * ```js\r\n * import { store as coreStore } from '@wordpress/core-data';\r\n * import { store as editorStore } from '@wordpress/editor';\r\n *\r\n * const getCurrentPostId = createRegistrySelector( ( select ) => ( state ) => {\r\n *   return select( editorStore ).getCurrentPostId();\r\n * } );\r\n *\r\n * const getPostEdits = createRegistrySelector( ( select ) => ( state ) => {\r\n *   // calling another registry selector just like any other function\r\n *   const postType = getCurrentPostType( state );\r\n *   const postId = getCurrentPostId( state );\r\n *\t return select( coreStore ).getEntityRecordEdits( 'postType', postType, postId );\r\n * } );\r\n * ```\r\n *\r\n * Note how the `getCurrentPostId` selector can be called just like any other function,\r\n * (it works even inside a regular non-registry selector) and we don't need to pass the\r\n * registry as argument. The registry binding happens automatically when registering the selector\r\n * with a store.\r\n *\r\n * @param {Function} registrySelector Function receiving a registry `select`\r\n *                                    function and returning a state selector.\r\n *\r\n * @return {Function} Registry selector that can be registered with a store.\r\n */\r\nexport function createRegistrySelector( registrySelector ) {\r\n\tconst selectorsByRegistry = new WeakMap();\r\n\t// Create a selector function that is bound to the registry referenced by `selector.registry`\r\n\t// and that has the same API as a regular selector. Binding it in such a way makes it\r\n\t// possible to call the selector directly from another selector.\r\n\tconst wrappedSelector = ( ...args ) => {\r\n\t\tlet selector = selectorsByRegistry.get( wrappedSelector.registry );\r\n\t\t// We want to make sure the cache persists even when new registry\r\n\t\t// instances are created. For example patterns create their own editors\r\n\t\t// with their own core/block-editor stores, so we should keep track of\r\n\t\t// the cache for each registry instance.\r\n\t\tif ( ! selector ) {\r\n\t\t\tselector = registrySelector( wrappedSelector.registry.select );\r\n\t\t\tselectorsByRegistry.set( wrappedSelector.registry, selector );\r\n\t\t}\r\n\t\treturn selector( ...args );\r\n\t};\r\n\r\n\t/**\r\n\t * Flag indicating that the selector is a registry selector that needs the correct registry\r\n\t * reference to be assigned to `selector.registry` to make it work correctly.\r\n\t * be mapped as a registry selector.\r\n\t *\r\n\t * @type {boolean}\r\n\t */\r\n\twrappedSelector.isRegistrySelector = true;\r\n\r\n\treturn wrappedSelector;\r\n}\r\n\r\n/**\r\n * Creates a control function that takes additional curried argument with the `registry` object.\r\n * While a regular control has signature\r\n * ```js\r\n * ( action ) => ( iteratorOrPromise )\r\n * ```\r\n * where the control works with the `action` that it's bound to, a registry control has signature:\r\n * ```js\r\n * ( registry ) => ( action ) => ( iteratorOrPromise )\r\n * ```\r\n * A registry control is typically used to select data or dispatch an action to a registered\r\n * store.\r\n *\r\n * When registering a control created with `createRegistryControl` with a store, the store\r\n * knows which calling convention to use when executing the control.\r\n *\r\n * @param {Function} registryControl Function receiving a registry object and returning a control.\r\n *\r\n * @return {Function} Registry control that can be registered with a store.\r\n */\r\nexport function createRegistryControl( registryControl ) {\r\n\tregistryControl.isRegistryControl = true;\r\n\r\n\treturn registryControl;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,sBAAsBA,CAAEC,gBAAgB,EAAG;EAC1D,MAAMC,mBAAmB,GAAG,IAAIC,OAAO,CAAC,CAAC;EACzC;EACA;EACA;EACA,MAAMC,eAAe,GAAGA,CAAE,GAAGC,IAAI,KAAM;IACtC,IAAIC,QAAQ,GAAGJ,mBAAmB,CAACK,GAAG,CAAEH,eAAe,CAACI,QAAS,CAAC;IAClE;IACA;IACA;IACA;IACA,IAAK,CAAEF,QAAQ,EAAG;MACjBA,QAAQ,GAAGL,gBAAgB,CAAEG,eAAe,CAACI,QAAQ,CAACC,MAAO,CAAC;MAC9DP,mBAAmB,CAACQ,GAAG,CAAEN,eAAe,CAACI,QAAQ,EAAEF,QAAS,CAAC;IAC9D;IACA,OAAOA,QAAQ,CAAE,GAAGD,IAAK,CAAC;EAC3B,CAAC;;EAED;AACD;AACA;AACA;AACA;AACA;AACA;EACCD,eAAe,CAACO,kBAAkB,GAAG,IAAI;EAEzC,OAAOP,eAAe;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,qBAAqBA,CAAEC,eAAe,EAAG;EACxDA,eAAe,CAACC,iBAAiB,GAAG,IAAI;EAExC,OAAOD,eAAe;AACvB","ignoreList":[]}