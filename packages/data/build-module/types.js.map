{"version":3,"names":[],"sources":["@wordpress/data/src/types.ts"],"sourcesContent":["/**\r\n * External dependencies\r\n */\r\n// eslint-disable-next-line no-restricted-imports\r\nimport type { combineReducers as reduxCombineReducers } from 'redux';\r\n\r\ntype MapOf< T > = { [ name: string ]: T };\r\n\r\nexport type ActionCreator = ( ...args: any[] ) => any | Generator;\r\nexport type Resolver = Function | Generator;\r\nexport type Selector = Function;\r\n\r\nexport type AnyConfig = ReduxStoreConfig< any, any, any >;\r\n\r\nexport interface StoreInstance< Config extends AnyConfig > {\r\n\tgetSelectors: () => SelectorsOf< Config >;\r\n\tgetActions: () => ActionCreatorsOf< Config >;\r\n\tsubscribe: ( listener: () => void ) => () => void;\r\n}\r\n\r\nexport interface StoreDescriptor< Config extends AnyConfig > {\r\n\t/**\r\n\t * Store Name\r\n\t */\r\n\tname: string;\r\n\r\n\t/**\r\n\t * Creates a store instance\r\n\t */\r\n\tinstantiate: ( registry: DataRegistry ) => StoreInstance< Config >;\r\n}\r\n\r\nexport interface ReduxStoreConfig<\r\n\tState,\r\n\tActionCreators extends MapOf< ActionCreator >,\r\n\tSelectors,\r\n> {\r\n\tinitialState?: State;\r\n\treducer: ( state: any, action: any ) => any;\r\n\tactions?: ActionCreators;\r\n\tresolvers?: MapOf< Resolver >;\r\n\tselectors?: Selectors;\r\n\tcontrols?: MapOf< Function >;\r\n}\r\n\r\n// Return type for the useSelect() hook.\r\nexport type UseSelectReturn< F extends MapSelect | StoreDescriptor< any > > =\r\n\tF extends MapSelect\r\n\t\t? ReturnType< F >\r\n\t\t: F extends StoreDescriptor< any >\r\n\t\t? CurriedSelectorsOf< F >\r\n\t\t: never;\r\n\r\n// Return type for the useDispatch() hook.\r\nexport type UseDispatchReturn< StoreNameOrDescriptor > =\r\n\tStoreNameOrDescriptor extends StoreDescriptor< any >\r\n\t\t? ActionCreatorsOf< ConfigOf< StoreNameOrDescriptor > >\r\n\t\t: StoreNameOrDescriptor extends undefined\r\n\t\t? DispatchFunction\r\n\t\t: any;\r\n\r\nexport type DispatchFunction = < StoreNameOrDescriptor >(\r\n\tstore: StoreNameOrDescriptor\r\n) => DispatchReturn< StoreNameOrDescriptor >;\r\n\r\nexport type DispatchReturn< StoreNameOrDescriptor > =\r\n\tStoreNameOrDescriptor extends StoreDescriptor< any >\r\n\t\t? ActionCreatorsOf< ConfigOf< StoreNameOrDescriptor > >\r\n\t\t: unknown;\r\n\r\nexport type MapSelect = (\r\n\tselect: SelectFunction,\r\n\tregistry: DataRegistry\r\n) => any;\r\n\r\nexport type SelectFunction = < S >( store: S ) => CurriedSelectorsOf< S >;\r\n\r\n/**\r\n * Callback for store's `subscribe()` method that\r\n * runs when the store data has changed.\r\n */\r\nexport type ListenerFunction = () => void;\r\n\r\nexport type CurriedSelectorsOf< S > = S extends StoreDescriptor<\r\n\tReduxStoreConfig< any, any, infer Selectors >\r\n>\r\n\t? { [ key in keyof Selectors ]: CurriedState< Selectors[ key ] > }\r\n\t: never;\r\n\r\n/**\r\n * Removes the first argument from a function.\r\n *\r\n * By default, it removes the `state` parameter from\r\n * registered selectors since that argument is supplied\r\n * by the editor when calling `select(â€¦)`.\r\n *\r\n * For functions with no arguments, which some selectors\r\n * are free to define, returns the original function.\r\n *\r\n * It is possible to manually provide a custom curried signature\r\n * and avoid the automatic inference. When the\r\n * F generic argument passed to this helper extends the\r\n * SelectorWithCustomCurrySignature type, the F['CurriedSignature']\r\n * property is used verbatim.\r\n *\r\n * This is useful because TypeScript does not correctly remove\r\n * arguments from complex function signatures constrained by\r\n * interdependent generic parameters.\r\n * For more context, see https://github.com/WordPress/gutenberg/pull/41578\r\n */\r\ntype CurriedState< F > = F extends SelectorWithCustomCurrySignature\r\n\t? F[ 'CurriedSignature' ]\r\n\t: F extends ( state: any, ...args: infer P ) => infer R\r\n\t? ( ...args: P ) => R\r\n\t: F;\r\n\r\n/**\r\n * Utility to manually specify curried selector signatures.\r\n *\r\n * It comes handy when TypeScript can't automatically produce the\r\n * correct curried function signature. For example:\r\n *\r\n * ```ts\r\n * type BadlyInferredSignature = CurriedState<\r\n *     <K extends string | number>(\r\n *         state: any,\r\n *         kind: K,\r\n *         key: K extends string ? 'one value' : false\r\n *     ) => K\r\n * >\r\n * // BadlyInferredSignature evaluates to:\r\n * // (kind: string number, key: false \"one value\") => string number\r\n * ```\r\n *\r\n * With SelectorWithCustomCurrySignature, we can provide a custom\r\n * signature and avoid relying on TypeScript inference:\r\n * ```ts\r\n * interface MySelectorSignature extends SelectorWithCustomCurrySignature {\r\n *     <K extends string | number>(\r\n *         state: any,\r\n *         kind: K,\r\n *         key: K extends string ? 'one value' : false\r\n *     ): K;\r\n *\r\n *     CurriedSignature: <K extends string | number>(\r\n *         kind: K,\r\n *         key: K extends string ? 'one value' : false\r\n *     ): K;\r\n * }\r\n * type CorrectlyInferredSignature = CurriedState<MySelectorSignature>\r\n * // <K extends string | number>(kind: K, key: K extends string ? 'one value' : false): K;\r\n *\r\n * For even more context, see https://github.com/WordPress/gutenberg/pull/41578\r\n * ```\r\n */\r\nexport interface SelectorWithCustomCurrySignature {\r\n\tCurriedSignature: Function;\r\n}\r\n\r\nexport interface DataRegistry {\r\n\tregister: ( store: StoreDescriptor< any > ) => void;\r\n}\r\n\r\nexport interface DataEmitter {\r\n\temit: () => void;\r\n\tsubscribe: ( listener: () => void ) => () => void;\r\n\tpause: () => void;\r\n\tresume: () => void;\r\n\tisPaused: boolean;\r\n}\r\n\r\n// Type Helpers.\r\n\r\nexport type ConfigOf< S > = S extends StoreDescriptor< infer C > ? C : never;\r\n\r\nexport type ActionCreatorsOf< Config extends AnyConfig > =\r\n\tConfig extends ReduxStoreConfig< any, infer ActionCreators, any >\r\n\t\t? PromisifiedActionCreators< ActionCreators >\r\n\t\t: never;\r\n\r\n// Takes an object containing all action creators for a store and updates the\r\n// return type of each action creator to account for internal registry details --\r\n// for example, dispatched actions are wrapped with a Promise.\r\nexport type PromisifiedActionCreators<\r\n\tActionCreators extends MapOf< ActionCreator >,\r\n> = {\r\n\t[ Action in keyof ActionCreators ]: PromisifyActionCreator<\r\n\t\tActionCreators[ Action ]\r\n\t>;\r\n};\r\n\r\n// Wraps action creator return types with a Promise and handles thunks.\r\nexport type PromisifyActionCreator< Action extends ActionCreator > = (\r\n\t...args: Parameters< Action >\r\n) => Promise<\r\n\tReturnType< Action > extends ( ..._args: any[] ) => any\r\n\t\t? ThunkReturnType< Action >\r\n\t\t: ReturnType< Action >\r\n>;\r\n\r\n// A thunk is an action creator which returns a function, which can optionally\r\n// return a Promise. The double ReturnType unwraps the innermost function's\r\n// return type, and Awaited gets the type the Promise resolves to. If the return\r\n// type is not a Promise, Awaited returns that original type.\r\nexport type ThunkReturnType< Action extends ActionCreator > = Awaited<\r\n\tReturnType< ReturnType< Action > >\r\n>;\r\n\r\ntype SelectorsOf< Config extends AnyConfig > = Config extends ReduxStoreConfig<\r\n\tany,\r\n\tany,\r\n\tinfer Selectors\r\n>\r\n\t? { [ name in keyof Selectors ]: Function }\r\n\t: never;\r\n\r\nexport type combineReducers = typeof reduxCombineReducers;\r\n"],"mappings":"","ignoreList":[]}