{"version":3,"names":["buildSelector","sequential","join","isVisible","element","offsetWidth","offsetHeight","getClientRects","length","isValidFocusableArea","map","closest","img","ownerDocument","querySelector","name","find","context","elements","querySelectorAll","Array","from","filter","nodeName"],"sources":["@wordpress/dom/src/focusable.js"],"sourcesContent":["/**\r\n * References:\r\n *\r\n * Focusable:\r\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\r\n *\r\n * Sequential focus navigation:\r\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\r\n *\r\n * Disabled elements:\r\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\r\n *\r\n * getClientRects algorithm (requiring layout box):\r\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\r\n *\r\n * AREA elements associated with an IMG:\r\n *  - https://w3c.github.io/html/editing.html#data-model\r\n */\r\n\r\n/**\r\n * Returns a CSS selector used to query for focusable elements.\r\n *\r\n * @param {boolean} sequential If set, only query elements that are sequentially\r\n *                             focusable. Non-interactive elements with a\r\n *                             negative `tabindex` are focusable but not\r\n *                             sequentially focusable.\r\n *                             https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\r\n *\r\n * @return {string} CSS selector.\r\n */\r\nfunction buildSelector( sequential ) {\r\n\treturn [\r\n\t\tsequential ? '[tabindex]:not([tabindex^=\"-\"])' : '[tabindex]',\r\n\t\t'a[href]',\r\n\t\t'button:not([disabled])',\r\n\t\t'input:not([type=\"hidden\"]):not([disabled])',\r\n\t\t'select:not([disabled])',\r\n\t\t'textarea:not([disabled])',\r\n\t\t'iframe:not([tabindex^=\"-\"])',\r\n\t\t'object',\r\n\t\t'embed',\r\n\t\t'area[href]',\r\n\t\t'[contenteditable]:not([contenteditable=false])',\r\n\t].join( ',' );\r\n}\r\n\r\n/**\r\n * Returns true if the specified element is visible (i.e. neither display: none\r\n * nor visibility: hidden).\r\n *\r\n * @param {HTMLElement} element DOM element to test.\r\n *\r\n * @return {boolean} Whether element is visible.\r\n */\r\nfunction isVisible( element ) {\r\n\treturn (\r\n\t\telement.offsetWidth > 0 ||\r\n\t\telement.offsetHeight > 0 ||\r\n\t\telement.getClientRects().length > 0\r\n\t);\r\n}\r\n\r\n/**\r\n * Returns true if the specified area element is a valid focusable element, or\r\n * false otherwise. Area is only focusable if within a map where a named map\r\n * referenced by an image somewhere in the document.\r\n *\r\n * @param {HTMLAreaElement} element DOM area element to test.\r\n *\r\n * @return {boolean} Whether area element is valid for focus.\r\n */\r\nfunction isValidFocusableArea( element ) {\r\n\t/** @type {HTMLMapElement | null} */\r\n\tconst map = element.closest( 'map[name]' );\r\n\tif ( ! map ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/** @type {HTMLImageElement | null} */\r\n\tconst img = element.ownerDocument.querySelector(\r\n\t\t'img[usemap=\"#' + map.name + '\"]'\r\n\t);\r\n\treturn !! img && isVisible( img );\r\n}\r\n\r\n/**\r\n * Returns all focusable elements within a given context.\r\n *\r\n * @param {Element} context              Element in which to search.\r\n * @param {Object}  options\r\n * @param {boolean} [options.sequential] If set, only return elements that are\r\n *                                       sequentially focusable.\r\n *                                       Non-interactive elements with a\r\n *                                       negative `tabindex` are focusable but\r\n *                                       not sequentially focusable.\r\n *                                       https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\r\n *\r\n * @return {HTMLElement[]} Focusable elements.\r\n */\r\nexport function find( context, { sequential = false } = {} ) {\r\n\t/** @type {NodeListOf<HTMLElement>} */\r\n\tconst elements = context.querySelectorAll( buildSelector( sequential ) );\r\n\r\n\treturn Array.from( elements ).filter( ( element ) => {\r\n\t\tif ( ! isVisible( element ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst { nodeName } = element;\r\n\t\tif ( 'AREA' === nodeName ) {\r\n\t\t\treturn isValidFocusableArea(\r\n\t\t\t\t/** @type {HTMLAreaElement} */ ( element )\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t} );\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,aAAaA,CAAEC,UAAU,EAAG;EACpC,OAAO,CACNA,UAAU,GAAG,iCAAiC,GAAG,YAAY,EAC7D,SAAS,EACT,wBAAwB,EACxB,4CAA4C,EAC5C,wBAAwB,EACxB,0BAA0B,EAC1B,6BAA6B,EAC7B,QAAQ,EACR,OAAO,EACP,YAAY,EACZ,gDAAgD,CAChD,CAACC,IAAI,CAAE,GAAI,CAAC;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAEC,OAAO,EAAG;EAC7B,OACCA,OAAO,CAACC,WAAW,GAAG,CAAC,IACvBD,OAAO,CAACE,YAAY,GAAG,CAAC,IACxBF,OAAO,CAACG,cAAc,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAAEL,OAAO,EAAG;EACxC;EACA,MAAMM,GAAG,GAAGN,OAAO,CAACO,OAAO,CAAE,WAAY,CAAC;EAC1C,IAAK,CAAED,GAAG,EAAG;IACZ,OAAO,KAAK;EACb;;EAEA;EACA,MAAME,GAAG,GAAGR,OAAO,CAACS,aAAa,CAACC,aAAa,CAC9C,eAAe,GAAGJ,GAAG,CAACK,IAAI,GAAG,IAC9B,CAAC;EACD,OAAO,CAAC,CAAEH,GAAG,IAAIT,SAAS,CAAES,GAAI,CAAC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,IAAIA,CAAEC,OAAO,EAAE;EAAEhB,UAAU,GAAG;AAAM,CAAC,GAAG,CAAC,CAAC,EAAG;EAC5D;EACA,MAAMiB,QAAQ,GAAGD,OAAO,CAACE,gBAAgB,CAAEnB,aAAa,CAAEC,UAAW,CAAE,CAAC;EAExE,OAAOmB,KAAK,CAACC,IAAI,CAAEH,QAAS,CAAC,CAACI,MAAM,CAAIlB,OAAO,IAAM;IACpD,IAAK,CAAED,SAAS,CAAEC,OAAQ,CAAC,EAAG;MAC7B,OAAO,KAAK;IACb;IAEA,MAAM;MAAEmB;IAAS,CAAC,GAAGnB,OAAO;IAC5B,IAAK,MAAM,KAAKmB,QAAQ,EAAG;MAC1B,OAAOd,oBAAoB,EAC1B,8BAAiCL,OAClC,CAAC;IACF;IAEA,OAAO,IAAI;EACZ,CAAE,CAAC;AACJ","ignoreList":[]}