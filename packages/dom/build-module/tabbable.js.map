{"version":3,"names":["find","findFocusable","getTabIndex","element","tabIndex","getAttribute","parseInt","isTabbableIndex","createStatefulCollapseRadioGroup","CHOSEN_RADIO_BY_NAME","collapseRadioGroup","result","nodeName","type","checked","name","concat","hasChosen","hasOwnProperty","isChosen","hadChosenElement","filter","e","mapElementToObjectTabbable","index","mapObjectTabbableToElement","object","compareObjectTabbables","a","b","aTabIndex","bTabIndex","filterTabbable","focusables","map","sort","reduce","context","findPrevious","ownerDocument","body","reverse","focusable","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","findNext","DOCUMENT_POSITION_FOLLOWING"],"sources":["@wordpress/dom/src/tabbable.js"],"sourcesContent":["/**\r\n * Internal dependencies\r\n */\r\nimport { find as findFocusable } from './focusable';\r\n\r\n/**\r\n * Returns the tab index of the given element. In contrast with the tabIndex\r\n * property, this normalizes the default (0) to avoid browser inconsistencies,\r\n * operating under the assumption that this function is only ever called with a\r\n * focusable node.\r\n *\r\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\r\n *\r\n * @param {Element} element Element from which to retrieve.\r\n *\r\n * @return {number} Tab index of element (default 0).\r\n */\r\nfunction getTabIndex( element ) {\r\n\tconst tabIndex = element.getAttribute( 'tabindex' );\r\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\r\n}\r\n\r\n/**\r\n * Returns true if the specified element is tabbable, or false otherwise.\r\n *\r\n * @param {Element} element Element to test.\r\n *\r\n * @return {boolean} Whether element is tabbable.\r\n */\r\nexport function isTabbableIndex( element ) {\r\n\treturn getTabIndex( element ) !== -1;\r\n}\r\n\r\n/** @typedef {HTMLElement & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */\r\n\r\n/**\r\n * Returns a stateful reducer function which constructs a filtered array of\r\n * tabbable elements, where at most one radio input is selected for a given\r\n * name, giving priority to checked input, falling back to the first\r\n * encountered.\r\n *\r\n * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.\r\n */\r\nfunction createStatefulCollapseRadioGroup() {\r\n\t/** @type {Record<string, MaybeHTMLInputElement>} */\r\n\tconst CHOSEN_RADIO_BY_NAME = {};\r\n\r\n\treturn function collapseRadioGroup(\r\n\t\t/** @type {MaybeHTMLInputElement[]} */ result,\r\n\t\t/** @type {MaybeHTMLInputElement} */ element\r\n\t) {\r\n\t\tconst { nodeName, type, checked, name } = element;\r\n\r\n\t\t// For all non-radio tabbables, construct to array by concatenating.\r\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\r\n\t\t\treturn result.concat( element );\r\n\t\t}\r\n\r\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\r\n\r\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\r\n\t\tconst isChosen = checked || ! hasChosen;\r\n\t\tif ( ! isChosen ) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t// At this point, if there had been a chosen element, the current\r\n\t\t// element is checked and should take priority. Retroactively remove\r\n\t\t// the element which had previously been considered the chosen one.\r\n\t\tif ( hasChosen ) {\r\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\r\n\t\t\tresult = result.filter( ( e ) => e !== hadChosenElement );\r\n\t\t}\r\n\r\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\r\n\r\n\t\treturn result.concat( element );\r\n\t};\r\n}\r\n\r\n/**\r\n * An array map callback, returning an object with the element value and its\r\n * array index location as properties. This is used to emulate a proper stable\r\n * sort where equal tabIndex should be left in order of their occurrence in the\r\n * document.\r\n *\r\n * @param {HTMLElement} element Element.\r\n * @param {number}      index   Array index of element.\r\n *\r\n * @return {{ element: HTMLElement, index: number }} Mapped object with element, index.\r\n */\r\nfunction mapElementToObjectTabbable( element, index ) {\r\n\treturn { element, index };\r\n}\r\n\r\n/**\r\n * An array map callback, returning an element of the given mapped object's\r\n * element value.\r\n *\r\n * @param {{ element: HTMLElement }} object Mapped object with element.\r\n *\r\n * @return {HTMLElement} Mapped object element.\r\n */\r\nfunction mapObjectTabbableToElement( object ) {\r\n\treturn object.element;\r\n}\r\n\r\n/**\r\n * A sort comparator function used in comparing two objects of mapped elements.\r\n *\r\n * @see mapElementToObjectTabbable\r\n *\r\n * @param {{ element: HTMLElement, index: number }} a First object to compare.\r\n * @param {{ element: HTMLElement, index: number }} b Second object to compare.\r\n *\r\n * @return {number} Comparator result.\r\n */\r\nfunction compareObjectTabbables( a, b ) {\r\n\tconst aTabIndex = getTabIndex( a.element );\r\n\tconst bTabIndex = getTabIndex( b.element );\r\n\r\n\tif ( aTabIndex === bTabIndex ) {\r\n\t\treturn a.index - b.index;\r\n\t}\r\n\r\n\treturn aTabIndex - bTabIndex;\r\n}\r\n\r\n/**\r\n * Givin focusable elements, filters out tabbable element.\r\n *\r\n * @param {HTMLElement[]} focusables Focusable elements to filter.\r\n *\r\n * @return {HTMLElement[]} Tabbable elements.\r\n */\r\nfunction filterTabbable( focusables ) {\r\n\treturn focusables\r\n\t\t.filter( isTabbableIndex )\r\n\t\t.map( mapElementToObjectTabbable )\r\n\t\t.sort( compareObjectTabbables )\r\n\t\t.map( mapObjectTabbableToElement )\r\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\r\n}\r\n\r\n/**\r\n * @param {Element} context\r\n * @return {HTMLElement[]} Tabbable elements within the context.\r\n */\r\nexport function find( context ) {\r\n\treturn filterTabbable( findFocusable( context ) );\r\n}\r\n\r\n/**\r\n * Given a focusable element, find the preceding tabbable element.\r\n *\r\n * @param {Element} element The focusable element before which to look. Defaults\r\n *                          to the active element.\r\n *\r\n * @return {HTMLElement|undefined} Preceding tabbable element.\r\n */\r\nexport function findPrevious( element ) {\r\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) )\r\n\t\t.reverse()\r\n\t\t.find(\r\n\t\t\t( focusable ) =>\r\n\t\t\t\t// eslint-disable-next-line no-bitwise\r\n\t\t\t\telement.compareDocumentPosition( focusable ) &\r\n\t\t\t\telement.DOCUMENT_POSITION_PRECEDING\r\n\t\t);\r\n}\r\n\r\n/**\r\n * Given a focusable element, find the next tabbable element.\r\n *\r\n * @param {Element} element The focusable element after which to look. Defaults\r\n *                          to the active element.\r\n *\r\n * @return {HTMLElement|undefined} Next tabbable element.\r\n */\r\nexport function findNext( element ) {\r\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) ).find(\r\n\t\t( focusable ) =>\r\n\t\t\t// eslint-disable-next-line no-bitwise\r\n\t\t\telement.compareDocumentPosition( focusable ) &\r\n\t\t\telement.DOCUMENT_POSITION_FOLLOWING\r\n\t);\r\n}\r\n"],"mappings":"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","ignoreList":[]}