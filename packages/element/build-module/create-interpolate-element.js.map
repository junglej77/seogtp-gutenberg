{"version":3,"names":["createElement","cloneElement","Fragment","isValidElement","indoc","offset","output","stack","tokenizer","createFrame","element","tokenStart","tokenLength","prevOffset","leadingTextStart","children","createInterpolateElement","interpolatedString","conversionMap","lastIndex","isValidConversionMap","TypeError","proceed","isObject","values","Object","length","every","next","nextToken","tokenType","name","startOffset","stackDepth","addText","stackLeadingText","pop","push","substr","addChild","closeOuterElement","stackTop","text","frame","matches","exec","startedAt","index","match","isClosing","isSelfClosed","parent","endOffset"],"sources":["@wordpress/element/src/create-interpolate-element.js"],"sourcesContent":["/**\r\n * Internal dependencies\r\n */\r\nimport { createElement, cloneElement, Fragment, isValidElement } from './react';\r\n\r\n/**\r\n * Object containing a React element.\r\n *\r\n * @typedef {import('react').ReactElement} Element\r\n */\r\n\r\nlet indoc, offset, output, stack;\r\n\r\n/**\r\n * Matches tags in the localized string\r\n *\r\n * This is used for extracting the tag pattern groups for parsing the localized\r\n * string and along with the map converting it to a react element.\r\n *\r\n * There are four references extracted using this tokenizer:\r\n *\r\n * match: Full match of the tag (i.e. <strong>, </strong>, <br/>)\r\n * isClosing: The closing slash, if it exists.\r\n * name: The name portion of the tag (strong, br) (if )\r\n * isSelfClosed: The slash on a self closing tag, if it exists.\r\n *\r\n * @type {RegExp}\r\n */\r\nconst tokenizer = /<(\\/)?(\\w+)\\s*(\\/)?>/g;\r\n\r\n/**\r\n * The stack frame tracking parse progress.\r\n *\r\n * @typedef Frame\r\n *\r\n * @property {Element}   element            A parent element which may still have\r\n * @property {number}    tokenStart         Offset at which parent element first\r\n *                                          appears.\r\n * @property {number}    tokenLength        Length of string marking start of parent\r\n *                                          element.\r\n * @property {number}    [prevOffset]       Running offset at which parsing should\r\n *                                          continue.\r\n * @property {number}    [leadingTextStart] Offset at which last closing element\r\n *                                          finished, used for finding text between\r\n *                                          elements.\r\n * @property {Element[]} children           Children.\r\n */\r\n\r\n/**\r\n * Tracks recursive-descent parse state.\r\n *\r\n * This is a Stack frame holding parent elements until all children have been\r\n * parsed.\r\n *\r\n * @private\r\n * @param {Element} element            A parent element which may still have\r\n *                                     nested children not yet parsed.\r\n * @param {number}  tokenStart         Offset at which parent element first\r\n *                                     appears.\r\n * @param {number}  tokenLength        Length of string marking start of parent\r\n *                                     element.\r\n * @param {number}  [prevOffset]       Running offset at which parsing should\r\n *                                     continue.\r\n * @param {number}  [leadingTextStart] Offset at which last closing element\r\n *                                     finished, used for finding text between\r\n *                                     elements.\r\n *\r\n * @return {Frame} The stack frame tracking parse progress.\r\n */\r\nfunction createFrame(\r\n\telement,\r\n\ttokenStart,\r\n\ttokenLength,\r\n\tprevOffset,\r\n\tleadingTextStart\r\n) {\r\n\treturn {\r\n\t\telement,\r\n\t\ttokenStart,\r\n\t\ttokenLength,\r\n\t\tprevOffset,\r\n\t\tleadingTextStart,\r\n\t\tchildren: [],\r\n\t};\r\n}\r\n\r\n/**\r\n * This function creates an interpolated element from a passed in string with\r\n * specific tags matching how the string should be converted to an element via\r\n * the conversion map value.\r\n *\r\n * @example\r\n * For example, for the given string:\r\n *\r\n * \"This is a <span>string</span> with <a>a link</a> and a self-closing\r\n * <CustomComponentB/> tag\"\r\n *\r\n * You would have something like this as the conversionMap value:\r\n *\r\n * ```js\r\n * {\r\n *     span: <span />,\r\n *     a: <a href={ 'https://github.com' } />,\r\n *     CustomComponentB: <CustomComponent />,\r\n * }\r\n * ```\r\n *\r\n * @param {string}                  interpolatedString The interpolation string to be parsed.\r\n * @param {Record<string, Element>} conversionMap      The map used to convert the string to\r\n *                                                     a react element.\r\n * @throws {TypeError}\r\n * @return {Element}  A wp element.\r\n */\r\nconst createInterpolateElement = ( interpolatedString, conversionMap ) => {\r\n\tindoc = interpolatedString;\r\n\toffset = 0;\r\n\toutput = [];\r\n\tstack = [];\r\n\ttokenizer.lastIndex = 0;\r\n\r\n\tif ( ! isValidConversionMap( conversionMap ) ) {\r\n\t\tthrow new TypeError(\r\n\t\t\t'The conversionMap provided is not valid. It must be an object with values that are React Elements'\r\n\t\t);\r\n\t}\r\n\r\n\tdo {\r\n\t\t// twiddle our thumbs\r\n\t} while ( proceed( conversionMap ) );\r\n\treturn createElement( Fragment, null, ...output );\r\n};\r\n\r\n/**\r\n * Validate conversion map.\r\n *\r\n * A map is considered valid if it's an object and every value in the object\r\n * is a React Element\r\n *\r\n * @private\r\n *\r\n * @param {Object} conversionMap The map being validated.\r\n *\r\n * @return {boolean}  True means the map is valid.\r\n */\r\nconst isValidConversionMap = ( conversionMap ) => {\r\n\tconst isObject = typeof conversionMap === 'object';\r\n\tconst values = isObject && Object.values( conversionMap );\r\n\treturn (\r\n\t\tisObject &&\r\n\t\tvalues.length &&\r\n\t\tvalues.every( ( element ) => isValidElement( element ) )\r\n\t);\r\n};\r\n\r\n/**\r\n * This is the iterator over the matches in the string.\r\n *\r\n * @private\r\n *\r\n * @param {Object} conversionMap The conversion map for the string.\r\n *\r\n * @return {boolean} true for continuing to iterate, false for finished.\r\n */\r\nfunction proceed( conversionMap ) {\r\n\tconst next = nextToken();\r\n\tconst [ tokenType, name, startOffset, tokenLength ] = next;\r\n\tconst stackDepth = stack.length;\r\n\tconst leadingTextStart = startOffset > offset ? offset : null;\r\n\tif ( ! conversionMap[ name ] ) {\r\n\t\taddText();\r\n\t\treturn false;\r\n\t}\r\n\tswitch ( tokenType ) {\r\n\t\tcase 'no-more-tokens':\r\n\t\t\tif ( stackDepth !== 0 ) {\r\n\t\t\t\tconst { leadingTextStart: stackLeadingText, tokenStart } =\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t\toutput.push( indoc.substr( stackLeadingText, tokenStart ) );\r\n\t\t\t}\r\n\t\t\taddText();\r\n\t\t\treturn false;\r\n\r\n\t\tcase 'self-closed':\r\n\t\t\tif ( 0 === stackDepth ) {\r\n\t\t\t\tif ( null !== leadingTextStart ) {\r\n\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\tindoc.substr(\r\n\t\t\t\t\t\t\tleadingTextStart,\r\n\t\t\t\t\t\t\tstartOffset - leadingTextStart\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\toutput.push( conversionMap[ name ] );\r\n\t\t\t\toffset = startOffset + tokenLength;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise we found an inner element.\r\n\t\t\taddChild(\r\n\t\t\t\tcreateFrame( conversionMap[ name ], startOffset, tokenLength )\r\n\t\t\t);\r\n\t\t\toffset = startOffset + tokenLength;\r\n\t\t\treturn true;\r\n\r\n\t\tcase 'opener':\r\n\t\t\tstack.push(\r\n\t\t\t\tcreateFrame(\r\n\t\t\t\t\tconversionMap[ name ],\r\n\t\t\t\t\tstartOffset,\r\n\t\t\t\t\ttokenLength,\r\n\t\t\t\t\tstartOffset + tokenLength,\r\n\t\t\t\t\tleadingTextStart\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t\toffset = startOffset + tokenLength;\r\n\t\t\treturn true;\r\n\r\n\t\tcase 'closer':\r\n\t\t\t// If we're not nesting then this is easy - close the block.\r\n\t\t\tif ( 1 === stackDepth ) {\r\n\t\t\t\tcloseOuterElement( startOffset );\r\n\t\t\t\toffset = startOffset + tokenLength;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise we're nested and we have to close out the current\r\n\t\t\t// block and add it as a innerBlock to the parent.\r\n\t\t\tconst stackTop = stack.pop();\r\n\t\t\tconst text = indoc.substr(\r\n\t\t\t\tstackTop.prevOffset,\r\n\t\t\t\tstartOffset - stackTop.prevOffset\r\n\t\t\t);\r\n\t\t\tstackTop.children.push( text );\r\n\t\t\tstackTop.prevOffset = startOffset + tokenLength;\r\n\t\t\tconst frame = createFrame(\r\n\t\t\t\tstackTop.element,\r\n\t\t\t\tstackTop.tokenStart,\r\n\t\t\t\tstackTop.tokenLength,\r\n\t\t\t\tstartOffset + tokenLength\r\n\t\t\t);\r\n\t\t\tframe.children = stackTop.children;\r\n\t\t\taddChild( frame );\r\n\t\t\toffset = startOffset + tokenLength;\r\n\t\t\treturn true;\r\n\r\n\t\tdefault:\r\n\t\t\taddText();\r\n\t\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Grabs the next token match in the string and returns it's details.\r\n *\r\n * @private\r\n *\r\n * @return {Array}  An array of details for the token matched.\r\n */\r\nfunction nextToken() {\r\n\tconst matches = tokenizer.exec( indoc );\r\n\t// We have no more tokens.\r\n\tif ( null === matches ) {\r\n\t\treturn [ 'no-more-tokens' ];\r\n\t}\r\n\tconst startedAt = matches.index;\r\n\tconst [ match, isClosing, name, isSelfClosed ] = matches;\r\n\tconst length = match.length;\r\n\tif ( isSelfClosed ) {\r\n\t\treturn [ 'self-closed', name, startedAt, length ];\r\n\t}\r\n\tif ( isClosing ) {\r\n\t\treturn [ 'closer', name, startedAt, length ];\r\n\t}\r\n\treturn [ 'opener', name, startedAt, length ];\r\n}\r\n\r\n/**\r\n * Pushes text extracted from the indoc string to the output stack given the\r\n * current rawLength value and offset (if rawLength is provided ) or the\r\n * indoc.length and offset.\r\n *\r\n * @private\r\n */\r\nfunction addText() {\r\n\tconst length = indoc.length - offset;\r\n\tif ( 0 === length ) {\r\n\t\treturn;\r\n\t}\r\n\toutput.push( indoc.substr( offset, length ) );\r\n}\r\n\r\n/**\r\n * Pushes a child element to the associated parent element's children for the\r\n * parent currently active in the stack.\r\n *\r\n * @private\r\n *\r\n * @param {Frame} frame The Frame containing the child element and it's\r\n *                      token information.\r\n */\r\nfunction addChild( frame ) {\r\n\tconst { element, tokenStart, tokenLength, prevOffset, children } = frame;\r\n\tconst parent = stack[ stack.length - 1 ];\r\n\tconst text = indoc.substr(\r\n\t\tparent.prevOffset,\r\n\t\ttokenStart - parent.prevOffset\r\n\t);\r\n\r\n\tif ( text ) {\r\n\t\tparent.children.push( text );\r\n\t}\r\n\r\n\tparent.children.push( cloneElement( element, null, ...children ) );\r\n\tparent.prevOffset = prevOffset ? prevOffset : tokenStart + tokenLength;\r\n}\r\n\r\n/**\r\n * This is called for closing tags. It creates the element currently active in\r\n * the stack.\r\n *\r\n * @private\r\n *\r\n * @param {number} endOffset Offset at which the closing tag for the element\r\n *                           begins in the string. If this is greater than the\r\n *                           prevOffset attached to the element, then this\r\n *                           helps capture any remaining nested text nodes in\r\n *                           the element.\r\n */\r\nfunction closeOuterElement( endOffset ) {\r\n\tconst { element, leadingTextStart, prevOffset, tokenStart, children } =\r\n\t\tstack.pop();\r\n\r\n\tconst text = endOffset\r\n\t\t? indoc.substr( prevOffset, endOffset - prevOffset )\r\n\t\t: indoc.substr( prevOffset );\r\n\r\n\tif ( text ) {\r\n\t\tchildren.push( text );\r\n\t}\r\n\r\n\tif ( null !== leadingTextStart ) {\r\n\t\toutput.push(\r\n\t\t\tindoc.substr( leadingTextStart, tokenStart - leadingTextStart )\r\n\t\t);\r\n\t}\r\n\r\n\toutput.push( cloneElement( element, null, ...children ) );\r\n}\r\n\r\nexport default createInterpolateElement;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,aAAa,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,cAAc,QAAQ,SAAS;;AAE/E;AACA;AACA;AACA;AACA;;AAEA,IAAIC,KAAK,EAAEC,MAAM,EAAEC,MAAM,EAAEC,KAAK;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG,uBAAuB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CACnBC,OAAO,EACPC,UAAU,EACVC,WAAW,EACXC,UAAU,EACVC,gBAAgB,EACf;EACD,OAAO;IACNJ,OAAO;IACPC,UAAU;IACVC,WAAW;IACXC,UAAU;IACVC,gBAAgB;IAChBC,QAAQ,EAAE;EACX,CAAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAGA,CAAEC,kBAAkB,EAAEC,aAAa,KAAM;EACzEd,KAAK,GAAGa,kBAAkB;EAC1BZ,MAAM,GAAG,CAAC;EACVC,MAAM,GAAG,EAAE;EACXC,KAAK,GAAG,EAAE;EACVC,SAAS,CAACW,SAAS,GAAG,CAAC;EAEvB,IAAK,CAAEC,oBAAoB,CAAEF,aAAc,CAAC,EAAG;IAC9C,MAAM,IAAIG,SAAS,CAClB,mGACD,CAAC;EACF;EAEA,GAAG;IACF;EAAA,CACA,QAASC,OAAO,CAAEJ,aAAc,CAAC;EAClC,OAAOlB,aAAa,CAAEE,QAAQ,EAAE,IAAI,EAAE,GAAGI,MAAO,CAAC;AAClD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","ignoreList":[]}