{"version":3,"names":["getProtocol","isValidProtocol","getAuthority","isValidAuthority","getPath","isValidPath","getQueryString","isValidQueryString","getFragment","isValidFragment","isValidHref","href","trimmedHref","trim","test","protocol","startsWith","authority","path","queryString","fragment","createLinkFormat","url","type","id","opensInNewWindow","nofollow","format","attributes","target","rel","getFormatBoundary","value","startIndex","start","endIndex","end","EMPTY_BOUNDARIES","formats","targetFormat","initialIndex","length","newFormats","slice","formatAtStart","find","formatAtEnd","formatAtEndMinusOne","index","indexOf","walkingArgs","walkToStart","walkToEnd","walkToBoundary","targetFormatRef","formatIndex","direction","directions","forwards","backwards","directionIncrement","inverseDirectionIncrement","partialRight","fn","partialArgs","args"],"sources":["@wordpress/format-library/src/link/utils.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport {\r\n\tgetProtocol,\r\n\tisValidProtocol,\r\n\tgetAuthority,\r\n\tisValidAuthority,\r\n\tgetPath,\r\n\tisValidPath,\r\n\tgetQueryString,\r\n\tisValidQueryString,\r\n\tgetFragment,\r\n\tisValidFragment,\r\n} from '@wordpress/url';\r\n\r\n/**\r\n * Check for issues with the provided href.\r\n *\r\n * @param {string} href The href.\r\n *\r\n * @return {boolean} Is the href invalid?\r\n */\r\nexport function isValidHref( href ) {\r\n\tif ( ! href ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tconst trimmedHref = href.trim();\r\n\r\n\tif ( ! trimmedHref ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Does the href start with something that looks like a URL protocol?\r\n\tif ( /^\\S+:/.test( trimmedHref ) ) {\r\n\t\tconst protocol = getProtocol( trimmedHref );\r\n\t\tif ( ! isValidProtocol( protocol ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Add some extra checks for http(s) URIs, since these are the most common use-case.\r\n\t\t// This ensures URIs with an http protocol have exactly two forward slashes following the protocol.\r\n\t\tif (\r\n\t\t\tprotocol.startsWith( 'http' ) &&\r\n\t\t\t! /^https?:\\/\\/[^\\/\\s]/i.test( trimmedHref )\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst authority = getAuthority( trimmedHref );\r\n\t\tif ( ! isValidAuthority( authority ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst path = getPath( trimmedHref );\r\n\t\tif ( path && ! isValidPath( path ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst queryString = getQueryString( trimmedHref );\r\n\t\tif ( queryString && ! isValidQueryString( queryString ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst fragment = getFragment( trimmedHref );\r\n\t\tif ( fragment && ! isValidFragment( fragment ) ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t// Validate anchor links.\r\n\tif ( trimmedHref.startsWith( '#' ) && ! isValidFragment( trimmedHref ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Generates the format object that will be applied to the link text.\r\n *\r\n * @param {Object}  options\r\n * @param {string}  options.url              The href of the link.\r\n * @param {string}  options.type             The type of the link.\r\n * @param {string}  options.id               The ID of the link.\r\n * @param {boolean} options.opensInNewWindow Whether this link will open in a new window.\r\n * @param {boolean} options.nofollow         Whether this link is marked as no follow relationship.\r\n * @return {Object} The final format object.\r\n */\r\nexport function createLinkFormat( {\r\n\turl,\r\n\ttype,\r\n\tid,\r\n\topensInNewWindow,\r\n\tnofollow,\r\n} ) {\r\n\tconst format = {\r\n\t\ttype: 'core/link',\r\n\t\tattributes: {\r\n\t\t\turl,\r\n\t\t},\r\n\t};\r\n\r\n\tif ( type ) {\r\n\t\tformat.attributes.type = type;\r\n\t}\r\n\tif ( id ) {\r\n\t\tformat.attributes.id = id;\r\n\t}\r\n\r\n\tif ( opensInNewWindow ) {\r\n\t\tformat.attributes.target = '_blank';\r\n\t\tformat.attributes.rel = format.attributes.rel\r\n\t\t\t? format.attributes.rel + ' noreferrer noopener'\r\n\t\t\t: 'noreferrer noopener';\r\n\t}\r\n\r\n\tif ( nofollow ) {\r\n\t\tformat.attributes.rel = format.attributes.rel\r\n\t\t\t? format.attributes.rel + ' nofollow'\r\n\t\t\t: 'nofollow';\r\n\t}\r\n\r\n\treturn format;\r\n}\r\n\r\n/* eslint-disable jsdoc/no-undefined-types */\r\n/**\r\n * Get the start and end boundaries of a given format from a rich text value.\r\n *\r\n *\r\n * @param {RichTextValue} value      the rich text value to interrogate.\r\n * @param {string}        format     the identifier for the target format (e.g. `core/link`, `core/bold`).\r\n * @param {number?}       startIndex optional startIndex to seek from.\r\n * @param {number?}       endIndex   optional endIndex to seek from.\r\n * @return {Object}\tobject containing start and end values for the given format.\r\n */\r\n/* eslint-enable jsdoc/no-undefined-types */\r\nexport function getFormatBoundary(\r\n\tvalue,\r\n\tformat,\r\n\tstartIndex = value.start,\r\n\tendIndex = value.end\r\n) {\r\n\tconst EMPTY_BOUNDARIES = {\r\n\t\tstart: null,\r\n\t\tend: null,\r\n\t};\r\n\r\n\tconst { formats } = value;\r\n\tlet targetFormat;\r\n\tlet initialIndex;\r\n\r\n\tif ( ! formats?.length ) {\r\n\t\treturn EMPTY_BOUNDARIES;\r\n\t}\r\n\r\n\t// Clone formats to avoid modifying source formats.\r\n\tconst newFormats = formats.slice();\r\n\r\n\tconst formatAtStart = newFormats[ startIndex ]?.find(\r\n\t\t( { type } ) => type === format.type\r\n\t);\r\n\r\n\tconst formatAtEnd = newFormats[ endIndex ]?.find(\r\n\t\t( { type } ) => type === format.type\r\n\t);\r\n\r\n\tconst formatAtEndMinusOne = newFormats[ endIndex - 1 ]?.find(\r\n\t\t( { type } ) => type === format.type\r\n\t);\r\n\r\n\tif ( !! formatAtStart ) {\r\n\t\t// Set values to conform to \"start\"\r\n\t\ttargetFormat = formatAtStart;\r\n\t\tinitialIndex = startIndex;\r\n\t} else if ( !! formatAtEnd ) {\r\n\t\t// Set values to conform to \"end\"\r\n\t\ttargetFormat = formatAtEnd;\r\n\t\tinitialIndex = endIndex;\r\n\t} else if ( !! formatAtEndMinusOne ) {\r\n\t\t// This is an edge case which will occur if you create a format, then place\r\n\t\t// the caret just before the format and hit the back ARROW key. The resulting\r\n\t\t// value object will have start and end +1 beyond the edge of the format boundary.\r\n\t\ttargetFormat = formatAtEndMinusOne;\r\n\t\tinitialIndex = endIndex - 1;\r\n\t} else {\r\n\t\treturn EMPTY_BOUNDARIES;\r\n\t}\r\n\r\n\tconst index = newFormats[ initialIndex ].indexOf( targetFormat );\r\n\r\n\tconst walkingArgs = [ newFormats, initialIndex, targetFormat, index ];\r\n\r\n\t// Walk the startIndex \"backwards\" to the leading \"edge\" of the matching format.\r\n\tstartIndex = walkToStart( ...walkingArgs );\r\n\r\n\t// Walk the endIndex \"forwards\" until the trailing \"edge\" of the matching format.\r\n\tendIndex = walkToEnd( ...walkingArgs );\r\n\r\n\t// Safe guard: start index cannot be less than 0.\r\n\tstartIndex = startIndex < 0 ? 0 : startIndex;\r\n\r\n\t// // Return the indicies of the \"edges\" as the boundaries.\r\n\treturn {\r\n\t\tstart: startIndex,\r\n\t\tend: endIndex,\r\n\t};\r\n}\r\n\r\n/**\r\n * Walks forwards/backwards towards the boundary of a given format within an\r\n * array of format objects. Returns the index of the boundary.\r\n *\r\n * @param {Array}  formats         the formats to search for the given format type.\r\n * @param {number} initialIndex    the starting index from which to walk.\r\n * @param {Object} targetFormatRef a reference to the format type object being sought.\r\n * @param {number} formatIndex     the index at which we expect the target format object to be.\r\n * @param {string} direction       either 'forwards' or 'backwards' to indicate the direction.\r\n * @return {number} the index of the boundary of the given format.\r\n */\r\nfunction walkToBoundary(\r\n\tformats,\r\n\tinitialIndex,\r\n\ttargetFormatRef,\r\n\tformatIndex,\r\n\tdirection\r\n) {\r\n\tlet index = initialIndex;\r\n\r\n\tconst directions = {\r\n\t\tforwards: 1,\r\n\t\tbackwards: -1,\r\n\t};\r\n\r\n\tconst directionIncrement = directions[ direction ] || 1; // invalid direction arg default to forwards\r\n\tconst inverseDirectionIncrement = directionIncrement * -1;\r\n\r\n\twhile (\r\n\t\tformats[ index ] &&\r\n\t\tformats[ index ][ formatIndex ] === targetFormatRef\r\n\t) {\r\n\t\t// Increment/decrement in the direction of operation.\r\n\t\tindex = index + directionIncrement;\r\n\t}\r\n\r\n\t// Restore by one in inverse direction of operation\r\n\t// to avoid out of bounds.\r\n\tindex = index + inverseDirectionIncrement;\r\n\r\n\treturn index;\r\n}\r\n\r\nconst partialRight =\r\n\t( fn, ...partialArgs ) =>\r\n\t( ...args ) =>\r\n\t\tfn( ...args, ...partialArgs );\r\n\r\nconst walkToStart = partialRight( walkToBoundary, 'backwards' );\r\n\r\nconst walkToEnd = partialRight( walkToBoundary, 'forwards' );\r\n"],"mappings":"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","ignoreList":[]}