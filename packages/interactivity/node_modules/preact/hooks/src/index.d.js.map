{"version":3,"names":[],"sources":["D:/jungle/gutenberg/packages/interactivity/node_modules/preact/hooks/src/index.d.ts"],"sourcesContent":["import { ErrorInfo, PreactContext, Ref as PreactRef } from '../..';\n\ntype Inputs = ReadonlyArray<unknown>;\n\nexport type StateUpdater<S> = (value: S | ((prevState: S) => S)) => void;\n/**\n * Returns a stateful value, and a function to update it.\n * @param initialState The initial value (or a function that returns the initial value)\n */\nexport function useState<S>(initialState: S | (() => S)): [S, StateUpdater<S>];\n\nexport function useState<S = undefined>(): [\n\tS | undefined,\n\tStateUpdater<S | undefined>\n];\n\nexport type Reducer<S, A> = (prevState: S, action: A) => S;\nexport type Dispatch<A> = (action: A) => void;\n/**\n * An alternative to `useState`.\n *\n * `useReducer` is usually preferable to `useState` when you have complex state logic that involves\n * multiple sub-values. It also lets you optimize performance for components that trigger deep\n * updates because you can pass `dispatch` down instead of callbacks.\n * @param reducer Given the current state and an action, returns the new state\n * @param initialState The initial value to store as state\n */\nexport function useReducer<S, A>(\n\treducer: Reducer<S, A>,\n\tinitialState: S\n): [S, Dispatch<A>];\n\n/**\n * An alternative to `useState`.\n *\n * `useReducer` is usually preferable to `useState` when you have complex state logic that involves\n * multiple sub-values. It also lets you optimize performance for components that trigger deep\n * updates because you can pass `dispatch` down instead of callbacks.\n * @param reducer Given the current state and an action, returns the new state\n * @param initialArg The initial argument to pass to the `init` function\n * @param init A function that, given the `initialArg`, returns the initial value to store as state\n */\nexport function useReducer<S, A, I>(\n\treducer: Reducer<S, A>,\n\tinitialArg: I,\n\tinit: (arg: I) => S\n): [S, Dispatch<A>];\n\n/** @deprecated Use the `Ref` type instead. */\ntype PropRef<T> = MutableRef<T>;\ninterface Ref<T> {\n\treadonly current: T | null;\n}\n\ninterface MutableRef<T> {\n\tcurrent: T;\n}\n\n/**\n * `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n * (`initialValue`). The returned object will persist for the full lifetime of the component.\n *\n * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\n * value around similar to how you’d use instance fields in classes.\n *\n * @param initialValue the initial value to store in the ref object\n */\nexport function useRef<T>(initialValue: T): MutableRef<T>;\nexport function useRef<T>(initialValue: T | null): Ref<T>;\nexport function useRef<T = undefined>(): MutableRef<T | undefined>;\n\ntype EffectCallback = () => void | (() => void);\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n * The effects run after browser paint, without blocking it.\n *\n * @param effect Imperative function that can return a cleanup function\n * @param inputs If present, effect will only activate if the values in the list change (using ===).\n */\nexport function useEffect(effect: EffectCallback, inputs?: Inputs): void;\n\ntype CreateHandle = () => object;\n\n/**\n * @param ref The ref that will be mutated\n * @param create The function that will be executed to get the value that will be attached to\n * ref.current\n * @param inputs If present, effect will only activate if the values in the list change (using ===).\n */\nexport function useImperativeHandle<T, R extends T>(\n\tref: PreactRef<T>,\n\tcreate: () => R,\n\tinputs?: Inputs\n): void;\n\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n * Use this to read layout from the DOM and synchronously re-render.\n * Updates scheduled inside `useLayoutEffect` will be flushed synchronously, after all DOM mutations but before the browser has a chance to paint.\n * Prefer the standard `useEffect` hook when possible to avoid blocking visual updates.\n *\n * @param effect Imperative function that can return a cleanup function\n * @param inputs If present, effect will only activate if the values in the list change (using ===).\n */\nexport function useLayoutEffect(effect: EffectCallback, inputs?: Inputs): void;\n\n/**\n * Returns a memoized version of the callback that only changes if one of the `inputs`\n * has changed (using ===).\n */\nexport function useCallback<T extends Function>(callback: T, inputs: Inputs): T;\n\n/**\n * Pass a factory function and an array of inputs.\n * useMemo will only recompute the memoized value when one of the inputs has changed.\n * This optimization helps to avoid expensive calculations on every render.\n * If no array is provided, a new value will be computed whenever a new function instance is passed as the first argument.\n */\n// for `inputs`, allow undefined, but don't make it optional as that is very likely a mistake\nexport function useMemo<T>(factory: () => T, inputs: Inputs | undefined): T;\n\n/**\n * Returns the current context value, as given by the nearest context provider for the given context.\n * When the provider updates, this Hook will trigger a rerender with the latest context value.\n *\n * @param context The context you want to use\n */\nexport function useContext<T>(context: PreactContext<T>): T;\n\n/**\n * Customize the displayed value in the devtools panel.\n *\n * @param value Custom hook name or object that is passed to formatter\n * @param formatter Formatter to modify value before sending it to the devtools\n */\nexport function useDebugValue<T>(value: T, formatter?: (value: T) => any): void;\n\nexport function useErrorBoundary(\n\tcallback?: (error: any, errorInfo: ErrorInfo) => Promise<void> | void\n): [any, () => void];\n\nexport function useId(): string;\n"],"mappings":"","ignoreList":[]}