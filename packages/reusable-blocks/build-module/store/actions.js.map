{"version":3,"names":["store","blockEditorStore","createBlock","isReusableBlock","parse","serialize","__","__experimentalConvertBlockToStatic","clientId","registry","oldBlock","select","getBlock","reusableBlock","getEditedEntityRecord","attributes","ref","newBlocks","content","dispatch","replaceBlocks","__experimentalConvertBlocksToReusable","clientIds","title","syncType","meta","wp_pattern_sync_status","undefined","getBlocksByClientId","status","updatedRecord","saveEntityRecord","newBlock","id","__experimentalSetEditingReusableBlock","__experimentalDeleteReusableBlock","allBlocks","getBlocks","associatedBlocks","filter","block","associatedBlockClientIds","map","length","removeBlocks","deleteEntityRecord","isEditing","type"],"sources":["@wordpress/reusable-blocks/src/store/actions.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { store as blockEditorStore } from '@wordpress/block-editor';\r\nimport {\r\n\tcreateBlock,\r\n\tisReusableBlock,\r\n\tparse,\r\n\tserialize,\r\n} from '@wordpress/blocks';\r\nimport { __ } from '@wordpress/i18n';\r\n\r\n/**\r\n * Returns a generator converting a reusable block into a static block.\r\n *\r\n * @param {string} clientId The client ID of the block to attach.\r\n */\r\nexport const __experimentalConvertBlockToStatic =\r\n\t( clientId ) =>\r\n\t( { registry } ) => {\r\n\t\tconst oldBlock = registry\r\n\t\t\t.select( blockEditorStore )\r\n\t\t\t.getBlock( clientId );\r\n\t\tconst reusableBlock = registry\r\n\t\t\t.select( 'core' )\r\n\t\t\t.getEditedEntityRecord(\r\n\t\t\t\t'postType',\r\n\t\t\t\t'wp_block',\r\n\t\t\t\toldBlock.attributes.ref\r\n\t\t\t);\r\n\r\n\t\tconst newBlocks = parse(\r\n\t\t\ttypeof reusableBlock.content === 'function'\r\n\t\t\t\t? reusableBlock.content( reusableBlock )\r\n\t\t\t\t: reusableBlock.content\r\n\t\t);\r\n\t\tregistry\r\n\t\t\t.dispatch( blockEditorStore )\r\n\t\t\t.replaceBlocks( oldBlock.clientId, newBlocks );\r\n\t};\r\n\r\n/**\r\n * Returns a generator converting one or more static blocks into a pattern.\r\n *\r\n * @param {string[]}             clientIds The client IDs of the block to detach.\r\n * @param {string}               title     Pattern title.\r\n * @param {undefined|'unsynced'} syncType  They way block is synced, current undefined (synced) and 'unsynced'.\r\n */\r\nexport const __experimentalConvertBlocksToReusable =\r\n\t( clientIds, title, syncType ) =>\r\n\tasync ( { registry, dispatch } ) => {\r\n\t\tconst meta =\r\n\t\t\tsyncType === 'unsynced'\r\n\t\t\t\t? {\r\n\t\t\t\t\t\twp_pattern_sync_status: syncType,\r\n\t\t\t\t  }\r\n\t\t\t\t: undefined;\r\n\r\n\t\tconst reusableBlock = {\r\n\t\t\ttitle: title || __( 'Untitled pattern block' ),\r\n\t\t\tcontent: serialize(\r\n\t\t\t\tregistry\r\n\t\t\t\t\t.select( blockEditorStore )\r\n\t\t\t\t\t.getBlocksByClientId( clientIds )\r\n\t\t\t),\r\n\t\t\tstatus: 'publish',\r\n\t\t\tmeta,\r\n\t\t};\r\n\r\n\t\tconst updatedRecord = await registry\r\n\t\t\t.dispatch( 'core' )\r\n\t\t\t.saveEntityRecord( 'postType', 'wp_block', reusableBlock );\r\n\r\n\t\tif ( syncType === 'unsynced' ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst newBlock = createBlock( 'core/block', {\r\n\t\t\tref: updatedRecord.id,\r\n\t\t} );\r\n\t\tregistry\r\n\t\t\t.dispatch( blockEditorStore )\r\n\t\t\t.replaceBlocks( clientIds, newBlock );\r\n\t\tdispatch.__experimentalSetEditingReusableBlock(\r\n\t\t\tnewBlock.clientId,\r\n\t\t\ttrue\r\n\t\t);\r\n\t};\r\n\r\n/**\r\n * Returns a generator deleting a reusable block.\r\n *\r\n * @param {string} id The ID of the reusable block to delete.\r\n */\r\nexport const __experimentalDeleteReusableBlock =\r\n\t( id ) =>\r\n\tasync ( { registry } ) => {\r\n\t\tconst reusableBlock = registry\r\n\t\t\t.select( 'core' )\r\n\t\t\t.getEditedEntityRecord( 'postType', 'wp_block', id );\r\n\r\n\t\t// Don't allow a reusable block with a temporary ID to be deleted.\r\n\t\tif ( ! reusableBlock ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remove any other blocks that reference this reusable block.\r\n\t\tconst allBlocks = registry.select( blockEditorStore ).getBlocks();\r\n\t\tconst associatedBlocks = allBlocks.filter(\r\n\t\t\t( block ) => isReusableBlock( block ) && block.attributes.ref === id\r\n\t\t);\r\n\t\tconst associatedBlockClientIds = associatedBlocks.map(\r\n\t\t\t( block ) => block.clientId\r\n\t\t);\r\n\r\n\t\t// Remove the parsed block.\r\n\t\tif ( associatedBlockClientIds.length ) {\r\n\t\t\tregistry\r\n\t\t\t\t.dispatch( blockEditorStore )\r\n\t\t\t\t.removeBlocks( associatedBlockClientIds );\r\n\t\t}\r\n\r\n\t\tawait registry\r\n\t\t\t.dispatch( 'core' )\r\n\t\t\t.deleteEntityRecord( 'postType', 'wp_block', id );\r\n\t};\r\n\r\n/**\r\n * Returns an action descriptor for SET_EDITING_REUSABLE_BLOCK action.\r\n *\r\n * @param {string}  clientId  The clientID of the reusable block to target.\r\n * @param {boolean} isEditing Whether the block should be in editing state.\r\n * @return {Object} Action descriptor.\r\n */\r\nexport function __experimentalSetEditingReusableBlock( clientId, isEditing ) {\r\n\treturn {\r\n\t\ttype: 'SET_EDITING_REUSABLE_BLOCK',\r\n\t\tclientId,\r\n\t\tisEditing,\r\n\t};\r\n}\r\n"],"mappings":"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","ignoreList":[]}