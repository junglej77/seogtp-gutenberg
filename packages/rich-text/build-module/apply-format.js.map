{"version":3,"names":["normaliseFormats","replace","array","index","value","slice","applyFormat","format","startIndex","start","endIndex","end","formats","activeFormats","newFormats","startFormat","find","type","indexOf","position","Infinity","filter","length","splice"],"sources":["@wordpress/rich-text/src/apply-format.js"],"sourcesContent":["/**\r\n * Internal dependencies\r\n */\r\n\r\nimport { normaliseFormats } from './normalise-formats';\r\n\r\n/** @typedef {import('./types').RichTextValue} RichTextValue */\r\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\r\n\r\nfunction replace( array, index, value ) {\r\n\tarray = array.slice();\r\n\tarray[ index ] = value;\r\n\treturn array;\r\n}\r\n\r\n/**\r\n * Apply a format object to a Rich Text value from the given `startIndex` to the\r\n * given `endIndex`. Indices are retrieved from the selection if none are\r\n * provided.\r\n *\r\n * @param {RichTextValue}  value        Value to modify.\r\n * @param {RichTextFormat} format       Format to apply.\r\n * @param {number}         [startIndex] Start index.\r\n * @param {number}         [endIndex]   End index.\r\n *\r\n * @return {RichTextValue} A new value with the format applied.\r\n */\r\nexport function applyFormat(\r\n\tvalue,\r\n\tformat,\r\n\tstartIndex = value.start,\r\n\tendIndex = value.end\r\n) {\r\n\tconst { formats, activeFormats } = value;\r\n\tconst newFormats = formats.slice();\r\n\r\n\t// The selection is collapsed.\r\n\tif ( startIndex === endIndex ) {\r\n\t\tconst startFormat = newFormats[ startIndex ]?.find(\r\n\t\t\t( { type } ) => type === format.type\r\n\t\t);\r\n\r\n\t\t// If the caret is at a format of the same type, expand start and end to\r\n\t\t// the edges of the format. This is useful to apply new attributes.\r\n\t\tif ( startFormat ) {\r\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\r\n\r\n\t\t\twhile (\r\n\t\t\t\tnewFormats[ startIndex ] &&\r\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\r\n\t\t\t) {\r\n\t\t\t\tnewFormats[ startIndex ] = replace(\r\n\t\t\t\t\tnewFormats[ startIndex ],\r\n\t\t\t\t\tindex,\r\n\t\t\t\t\tformat\r\n\t\t\t\t);\r\n\t\t\t\tstartIndex--;\r\n\t\t\t}\r\n\r\n\t\t\tendIndex++;\r\n\r\n\t\t\twhile (\r\n\t\t\t\tnewFormats[ endIndex ] &&\r\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\r\n\t\t\t) {\r\n\t\t\t\tnewFormats[ endIndex ] = replace(\r\n\t\t\t\t\tnewFormats[ endIndex ],\r\n\t\t\t\t\tindex,\r\n\t\t\t\t\tformat\r\n\t\t\t\t);\r\n\t\t\t\tendIndex++;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\t// Determine the highest position the new format can be inserted at.\r\n\t\tlet position = +Infinity;\r\n\r\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\r\n\t\t\tif ( newFormats[ index ] ) {\r\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\r\n\t\t\t\t\t( { type } ) => type !== format.type\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst length = newFormats[ index ].length;\r\n\r\n\t\t\t\tif ( length < position ) {\r\n\t\t\t\t\tposition = length;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnewFormats[ index ] = [];\r\n\t\t\t\tposition = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\r\n\t\t\tnewFormats[ index ].splice( position, 0, format );\r\n\t\t}\r\n\t}\r\n\r\n\treturn normaliseFormats( {\r\n\t\t...value,\r\n\t\tformats: newFormats,\r\n\t\t// Always revise active formats. This serves as a placeholder for new\r\n\t\t// inputs with the format so new input appears with the format applied,\r\n\t\t// and ensures a format of the same type uses the latest values.\r\n\t\tactiveFormats: [\r\n\t\t\t...( activeFormats?.filter(\r\n\t\t\t\t( { type } ) => type !== format.type\r\n\t\t\t) || [] ),\r\n\t\t\tformat,\r\n\t\t],\r\n\t} );\r\n}\r\n"],"mappings":"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","ignoreList":[]}