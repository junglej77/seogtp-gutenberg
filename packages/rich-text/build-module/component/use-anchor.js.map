{"version":3,"names":["usePrevious","useState","useLayoutEffect","getFormatElement","range","editableContentElement","tagName","className","element","startContainer","nodeType","TEXT_NODE","startOffset","length","nextSibling","firstChild","ELEMENT_NODE","parentElement","contains","selector","matches","createVirtualAnchorElement","contextElement","getBoundingClientRect","getAnchor","ownerDocument","defaultView","selection","getSelection","rangeCount","getRangeAt","formatElement","useAnchor","settings","isActive","anchor","setAnchor","wasActive","callback","attach","addEventListener","detach","removeEventListener","activeElement"],"sources":["@wordpress/rich-text/src/component/use-anchor.js"],"sourcesContent":["/**\r\n * WordPress dependencies\r\n */\r\nimport { usePrevious } from '@wordpress/compose';\r\nimport { useState, useLayoutEffect } from '@wordpress/element';\r\n\r\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\r\n/** @typedef {import('../types').RichTextValue} RichTextValue */\r\n\r\n/**\r\n * Given a range and a format tag name and class name, returns the closest\r\n * format element.\r\n *\r\n * @param {Range}       range                  The Range to check.\r\n * @param {HTMLElement} editableContentElement The editable wrapper.\r\n * @param {string}      tagName                The tag name of the format element.\r\n * @param {string}      className              The class name of the format element.\r\n *\r\n * @return {HTMLElement|undefined} The format element, if found.\r\n */\r\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\r\n\tlet element = range.startContainer;\r\n\r\n\t// Even if the active format is defined, the actualy DOM range's start\r\n\t// container may be outside of the format's DOM element:\r\n\t// `a‸<strong>b</strong>` (DOM) while visually it's `a<strong>‸b</strong>`.\r\n\t// So at a given selection index, start with the deepest format DOM element.\r\n\tif (\r\n\t\telement.nodeType === element.TEXT_NODE &&\r\n\t\trange.startOffset === element.length &&\r\n\t\telement.nextSibling\r\n\t) {\r\n\t\telement = element.nextSibling;\r\n\r\n\t\twhile ( element.firstChild ) {\r\n\t\t\telement = element.firstChild;\r\n\t\t}\r\n\t}\r\n\r\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\r\n\t\telement = element.parentElement;\r\n\t}\r\n\r\n\tif ( ! element ) {\r\n\t\treturn;\r\n\t}\r\n\tif ( element === editableContentElement ) {\r\n\t\treturn;\r\n\t}\r\n\tif ( ! editableContentElement.contains( element ) ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst selector = tagName + ( className ? '.' + className : '' );\r\n\r\n\t// .closest( selector ), but with a boundary. Check if the element matches\r\n\t// the selector. If it doesn't match, try the parent element if it's not the\r\n\t// editable wrapper. We don't want to try to match ancestors of the editable\r\n\t// wrapper, which is what .closest( selector ) would do. When the element is\r\n\t// the editable wrapper (which is most likely the case because most text is\r\n\t// unformatted), this never runs.\r\n\twhile ( element !== editableContentElement ) {\r\n\t\tif ( element.matches( selector ) ) {\r\n\t\t\treturn element;\r\n\t\t}\r\n\r\n\t\telement = element.parentElement;\r\n\t}\r\n}\r\n\r\n/**\r\n * @typedef {Object} VirtualAnchorElement\r\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\r\n * @property {HTMLElement}   contextElement        The actual DOM element\r\n */\r\n\r\n/**\r\n * Creates a virtual anchor element for a range.\r\n *\r\n * @param {Range}       range                  The range to create a virtual anchor element for.\r\n * @param {HTMLElement} editableContentElement The editable wrapper.\r\n *\r\n * @return {VirtualAnchorElement} The virtual anchor element.\r\n */\r\nfunction createVirtualAnchorElement( range, editableContentElement ) {\r\n\treturn {\r\n\t\tcontextElement: editableContentElement,\r\n\t\tgetBoundingClientRect() {\r\n\t\t\treturn editableContentElement.contains( range.startContainer )\r\n\t\t\t\t? range.getBoundingClientRect()\r\n\t\t\t\t: editableContentElement.getBoundingClientRect();\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Get the anchor: a format element if there is a matching one based on the\r\n * tagName and className or a range otherwise.\r\n *\r\n * @param {HTMLElement} editableContentElement The editable wrapper.\r\n * @param {string}      tagName                The tag name of the format\r\n *                                             element.\r\n * @param {string}      className              The class name of the format\r\n *                                             element.\r\n *\r\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\r\n */\r\nfunction getAnchor( editableContentElement, tagName, className ) {\r\n\tif ( ! editableContentElement ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst { ownerDocument } = editableContentElement;\r\n\tconst { defaultView } = ownerDocument;\r\n\tconst selection = defaultView.getSelection();\r\n\r\n\tif ( ! selection ) {\r\n\t\treturn;\r\n\t}\r\n\tif ( ! selection.rangeCount ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst range = selection.getRangeAt( 0 );\r\n\r\n\tif ( ! range || ! range.startContainer ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst formatElement = getFormatElement(\r\n\t\trange,\r\n\t\teditableContentElement,\r\n\t\ttagName,\r\n\t\tclassName\r\n\t);\r\n\r\n\tif ( formatElement ) {\r\n\t\treturn formatElement;\r\n\t}\r\n\r\n\treturn createVirtualAnchorElement( range, editableContentElement );\r\n}\r\n\r\n/**\r\n * This hook, to be used in a format type's Edit component, returns the active\r\n * element that is formatted, or a virtual element for the selection range if\r\n * no format is active. The returned value is meant to be used for positioning\r\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\r\n *\r\n * @param {Object}           $1                        Named parameters.\r\n * @param {HTMLElement|null} $1.editableContentElement The element containing\r\n *                                                     the editable content.\r\n * @param {WPFormat=}        $1.settings               The format type's settings.\r\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\r\n */\r\nexport function useAnchor( { editableContentElement, settings = {} } ) {\r\n\tconst { tagName, className, isActive } = settings;\r\n\tconst [ anchor, setAnchor ] = useState( () =>\r\n\t\tgetAnchor( editableContentElement, tagName, className )\r\n\t);\r\n\tconst wasActive = usePrevious( isActive );\r\n\r\n\tuseLayoutEffect( () => {\r\n\t\tif ( ! editableContentElement ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfunction callback() {\r\n\t\t\tsetAnchor(\r\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfunction attach() {\r\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\r\n\t\t}\r\n\r\n\t\tfunction detach() {\r\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\r\n\t\t}\r\n\r\n\t\tconst { ownerDocument } = editableContentElement;\r\n\r\n\t\tif (\r\n\t\t\teditableContentElement === ownerDocument.activeElement ||\r\n\t\t\t// When a link is created, we need to attach the popover to the newly created anchor.\r\n\t\t\t( ! wasActive && isActive ) ||\r\n\t\t\t// Sometimes we're _removing_ an active anchor, such as the inline color popover.\r\n\t\t\t// When we add the color, it switches from a virtual anchor to a `<mark>` element.\r\n\t\t\t// When we _remove_ the color, it switches from a `<mark>` element to a virtual anchor.\r\n\t\t\t( wasActive && ! isActive )\r\n\t\t) {\r\n\t\t\tsetAnchor(\r\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\r\n\t\t\t);\r\n\t\t\tattach();\r\n\t\t}\r\n\r\n\t\teditableContentElement.addEventListener( 'focusin', attach );\r\n\t\teditableContentElement.addEventListener( 'focusout', detach );\r\n\r\n\t\treturn () => {\r\n\t\t\tdetach();\r\n\r\n\t\t\teditableContentElement.removeEventListener( 'focusin', attach );\r\n\t\t\teditableContentElement.removeEventListener( 'focusout', detach );\r\n\t\t};\r\n\t}, [ editableContentElement, tagName, className, isActive, wasActive ] );\r\n\r\n\treturn anchor;\r\n}\r\n"],"mappings":"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","ignoreList":[]}